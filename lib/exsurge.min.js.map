{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///exsurge.min.js","webpack:///webpack/bootstrap 8075a7bf4bf4cb707836","webpack:///./src/index.js","webpack:///./src/Exsurge.Core.js","webpack:///./src/Exsurge.Text.js","webpack:///./src/Exsurge.Glyphs.js","webpack:///./src/Exsurge.Drawing.js","webpack:///./src/addAccent.js","webpack:///./src/makeLigature.js","webpack:///./src/greextraGlyphs.js","webpack:///./src/Exsurge.Chant.js","webpack:///./src/Exsurge.Chant.ChantLine.js","webpack:///./src/Exsurge.Chant.Markings.js","webpack:///./src/Exsurge.Chant.Signs.js","webpack:///./src/Exsurge.Gabc.js","webpack:///./src/Exsurge.Chant.Neumes.js","webpack:///./src/Exsurge.Titles.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","Object","defineProperty","value","_ExsurgeCore","keys","forEach","key","enumerable","get","_ExsurgeText","_ExsurgeGlyphs","_ExsurgeDrawing","_ExsurgeChant","_ExsurgeChantChantLine","_ExsurgeChantMarkings","_ExsurgeChantSigns","_ExsurgeChantNeumes","_ExsurgeGabc","_ExsurgeTitles","_greextraGlyphs","_classCallCheck","instance","Constructor","TypeError","DeviceIndependent","n","Centimeters","Units","ToDeviceIndependent","Millimeters","Inches","ToCentimeters","FromDeviceIndependent","ToMillimeters","ToInches","generateRandomGuid","s4","Math","floor","random","toString","substring","getCssForProperties","properties","entries","map","_ref","_ref2","_slicedToArray","val","join","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","push","length","err","Array","isArray","_createClass","defineProperties","target","props","descriptor","configurable","writable","protoProps","staticProps","prototype","DeviceIndepenedent","DIU_PER_INCH","DIU_PER_CENTIMETER","inputUnits","outputUnits","StringToUnitsType","s","ToLower","UnitsTypeToString","units","Point","x","y","point","Step","Rect","width","height","Infinity","rect","other","right","max","bottom","min","Margins","left","top","margins","Size","size","Do","Du","Re","Me","Mi","Fa","Fu","So","La","Te","Ti","__StepToStaffPosition","__StaffOffsetToStep","Pitch","step","octave","toInt","pitch","offset","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","Language","name","centerNeume","text","parsedWords","words","split","end","syllabifyWord","English","_Language","_this","getPrototypeOf","regexLetter","startIndex","match","exec","slice","found","index","Latin","_Language2","_this2","diphthongs","possibleDiphthongs","concat","regexVowel","wordExceptions","vowels","vowelsThatMightBeConsonants","muteConsonantsAndF","liquidConsonants","isVowelThatMightBeConsonant","isVowel","word","lookahead","haveLookahead","syllables","haveCompleteSyllable","previousWasVowel","workingString","toLowerCase","startSyllable","makeSyllable","substr","wordLength","cIsVowel","isDiphthong","isMuteConsonantOrF","isLiquidConsonant","ignore","_this3","lastIndex","stringSlice","isIgnoredMatch","endIndex","inIgnore","find","Spanish","_Language3","_this4","weakVowels","strongVowels","uDiphthongExceptions","previousIsVowel","previousIsStrongVowel","cIsStrongVowel","isStrongVowel","createSyllable","consonant2","numberOfConsonants","j","d","indexOf","tripthong","endj","findVowelSegment","language","english","latin","spanish","Glyphs","None","paths","type","data","bounds","origin","align","AcuteAccent","GraveAccent","Circle","Semicircle","ReversedSemicircle","Stropha","BeginningAscLiquescent","BeginningDesLiquescent","CustosDescLong","CustosDescShort","CustosLong","CustosShort","DoClef","FaClef","TrebleClef","TrebleClefSmall","Flat","Mora","Natural","Sharp","OriscusAsc","OriscusDes","OriscusLiquescent","PodatusLower","PodatusUpper","Porrectus1","Porrectus2","Porrectus3","Porrectus4","PunctumCavum","PunctumQuadratum","PunctumQuadratumLiquescent","PunctumQuadratumAscLiquescent","PunctumQuadratumDesLiquescent","PunctumInclinatum","PunctumInclinatumLiquescent","Quilisma","TerminatingAscLiquescent","TerminatingDesLiquescent","VerticalEpisemaAbove","VerticalEpisemaBelow","VirgaLong","VirgaShort","Virgula","_toConsumableArray","arr2","from","getFontFilenameForProperties","arguments","url","italic","bold","replace","ChantNotationElement","Annotations","Annotation","TextLeftRight","Subtitle","Title","Supertitle","TitleTextElement","DropCap","TranslationText","AboveLinesText","ChoralSign","Lyric","LyricArray","LyricType","TextElement","TextSpan","CurlyBraceVisualizer","RoundBraceVisualizer","GlyphVisualizer","LineaVisualizer","VirgaLineVisualizer","NeumeLineVisualizer","DividerLineVisualizer","ChantLayoutElement","ChantContext","TextMeasuringStrategy","QuickSvg","GlyphCode","DefaultTrailingSpace","TextTypesByClass","TextTypes","MarkingPositionHint","_get","object","property","receiver","Function","desc","getOwnPropertyDescriptor","parent","getter","_addAccent","_makeLigature","canAccessDOM","document","__getNeumeFromSvgElem","score","elem","note","notes","parentElement","querySelector","getAttribute","neume","Default","Above","Below","supertitle","display","defaultSize","containedInScore","titles","hasSupertitle","getFromScore","title","hasTitle","subtitle","hasSubtitle","leftRight","cssClass","hasTextLeft","hasTextRight","extraClass","getFromSvgElem","classList","contains","annotation","_ref$elementIndex","elementIndex","annotations","querySelectorAll","dropCap","al","hasAboveLinesText","notations","notation","notationIndex","alText","alIndex","choralSign","ctxt","staffInterval","lyric","hasLyrics","lyrics","lyricIndex","translation","hasTranslations","translationText","translationIndex","_ref3","entry","intraNeumeSpacing","interSyllabicMultiplier","isDefault","StrophaLiquescent","UpperBrace","ns","xmlns","xlink","hasDOMAccess","svg","node","createElementNS","setAttribute","setAttributeNS","defs","appendChild","clearNotations","removeChild","hasChildNodes","lastChild","line","x1","y1","x2","y2","g","tspan","str","textContent","use","nodeRef","svgFragmentForGlyph","glyph","fillColor","svgSrc","path","createFragment","fill","nodesForGlyph","functionName","nodes","createNode","attributes","children","source","attr","hasOwnProperty","createSvgTree","_len","_key","className","class","convertKeysToCamelCase","obj","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","test","camelCase","whole","letter","toUpperCase","return","style","sourceGabc","child","fragment","parseFragment","well","createElement","container","innerHTML","il","firstChild","childNodes","translate","scale","sx","sy","Svg","Canvas","OpenTypeJS","textMeasuringStrategy","fontDictionary","staffLineCount","makeDefs","defsNode","textStyles","textColor","setFont","rubricColor","specialCharProperties","font-family","textBeforeSpecialChar","textAfterSpecialChar","specialCharMap","℣","℟","+","*","plusProperties","asteriskProperties","specialCharText","char","fontStyleDictionary","b","font-weight","font-style","u","text-decoration","ul","sc","font-variant","v","e","font-size","markupSymbolDictionary","_","^","%","prefix","padding","minLedgerSeparation","minSpaceAboveStaff","minSpaceBelowStaff","spaceBetweenSystems","glyphPunctumWidth","glyphPunctumHeight","maxExtraSpaceInStaffIntervals","activeClef","neumeLineColor","staffLineColor","dividerLineColor","defaultLanguage","pixelRatio","window","devicePixelRatio","svgTextMeasurer","body","insertBefore","makeCanvasIfNeeded","syllableConnector","scaleDefs","setGlyphScaling","accidentalSpaceMultiplier","interVerbalMultiplier","drawGuides","drawDebuggingBounds","activeNotations","currNotationIndex","minSyllablesLastLine","minNotesLastLine","condensingTolerance","autoColor","useExtraTextOnly","noteIdPrefix","insertFontsInDoc","setMergeAnnotationWithTextLeft","staffPosition","staffPositionSymmetric","fontFamily","keyWithFontFamily","Regular","font","baseStyle","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","_step2$value","textType","textStyle","color","baseTextStyle","merge","mergeAnnotationWithTextLeft","__mergeAnnotationWithTextLeft","glyphScaling","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","_step3$value","_textStyles$key","createStyleCss","hyphen","SingleSyllable","multiplier","minLyricWordSpacing","hyphenWidth","staffHeight","staffLineWeight","ceil","neumeLineWeight","dividerLineWeight","episemaLineWeight","updateHyphenWidth","styleElement","getElementById","head","isNeume","hasNoWidth","canvas","canvasCtxt","getContext","setTransform","selected","highlighted","_ChantLayoutElement","staffPosition0","staffPosition1","divider","y0","calculateHeightFromStaffPosition","temp","fillStyle","fillRect","sourceIndex","getSvgProps","_ChantLayoutElement2","note0","note1","hanging","abs","_ChantLayoutElement3","_ChantLayoutElement4","_this5","_this6","_this7","apply","_this8","_ChantLayoutElement5","glyphCode","_this9","setGlyph","getDefProps","options","transform","makeDef","makeSvgTree","Path2D","noteIndex","nextNote","isSelected","model","result","xlink:href","glyphVisualizer","getSvgAttributes","_ChantLayoutElement6","isAbove","_this10","ignoreBounds","braceHeight","_getPathPoints","getPathPoints","cx1","cx2","cy","beginPath","moveTo","bezierCurveTo","stroke","generatePathString","stroke-width","getSvgPathProps","accent","createSvgNode","createSvgFragment","dx","dy","_getPathPoints2","dp","toFixed","_ChantLayoutElement7","addAcuteAccent","_this11","union","h","q","qy1","qx2","qy2","tx1","ty1","qy3","qx4","qy4","propertyArray","activeTags","extraProps","xOffset","newLine","assign","MarkupStackFrame","tagName","symbol","extraProperties","__subsForTspans","&","<",">","_ChantLayoutElement8","fontSize","textAnchor","_this12","dominantBaseline","generateSpansFromText","recalculateMetrics","_this13","spans","markupStack","spanStartIndex","newLineInNextSpan","filterFrames","frame","closeSpan","spanText","span","markupRegex","vTagRegex","openedAsterisk","closeCurrentSpan","_match","_match2","vTag","asterisk","plus","tilde","vowelLigature","specialChar","specialChar2","specialChar3","markupSymbol","closingTag","family","enclosedText","vMatch","iOffset","_vMatch","_vMatch2","grecross","greextra","diphthong","makeLigature","addAccent","greextraGlyphs","pop","vowel","filter","findIndex","splice","createStackFrame","parseFloat","resize","measureSubstring","returnBBox","lines","widths","newLineSpans","subStringLength","numLines","bbox","myText","parseInt","rightAligned","firstLineMaxWidth","getCanvasFontForProperties","metrics","measureText","actualBoundingBoxLeft","actualBoundingBoxAscent","actualBoundingBoxDescent","getFontForProperties","features","liga","smcp","spanFontSize","subBbox","getPath","getBoundingBox","subWidth","getAdvanceWidth","resetNewLines","maxWidth","createStyleNode","getBBox","measureSubstringBBox","reduce","percentage","lastWidth","lastMatch","regex","_spans","spanIndex","splitSpan","textLeft","textRight","newSpans","needsLayout","textAlign","translateWidth","translateHeight","count","getExtraStyleProperties","fillText","textLength","source-index","getCssClasses","trim","text-anchor","useStyleObject","lengthAdjust","getSpanOptions","extraStyleProperties","svgNode","escapeForTspan","setFontFamilyAttributes","string","String","BeginningSyllable","MiddleSyllable","EndingSyllable","Directive","getLeft","lyricArray","NaN","Number","MAX_VALUE","getRight","presumeConnectorNeeded","MIN_VALUE","l","allowsConnector","needsConnector","getConnectorWidth","hasOnlyOneLyric","originalText","indexOfLyric","mergeIn","newLyrics","mergeInArray","setNotation","_TextElement","lyricType","_this14","centerStartIndex","centerLength","connectorSpan","force","forceConnector","needs","setConnectorWidth","widthWithoutConnector","connectorWidth","defaultConnectorWidth","setNeedsConnector","activeLanguage","vowelSegmentWidth","getSubStringLength","lastIndexOf","indexOffset","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","includes","dropCapSpan","clone","dropCapLowerCase","dropCapSourceGabcLength","classes","_TextElement2","_this15","positionHint","_TextElement3","_this16","_TextElement4","gabcSource","anchor","_this17","_TextElement5","_this18","_TextElement6","_TitleTextElement","_this20","_TitleTextElement2","_this21","_TitleTextElement3","_this22","_TitleTextElement4","_this23","headerKey","_TextElement7","_this24","__connectorSpan","_ChantLayoutElement9","_this25","lineHeight","_len2","texts","_key2","updateBounds","draw","_ChantLayoutElement10","_this26","leadingSpace","trailingSpace","keepWithNext","visualizers","chantLayoutElement","isEmpty","unshift","calculatedTrailingSpace","_this27","calculateLyricX","inner","getInnerSvgNodes","svgProps","_len3","annotationSpans","_key3","Æ","Œ","A","E","I","O","U","Y","æ","œ","a","o","AE","Ae","ae","OE","Oe","oe","MedicaeaFlat","HufnagelCustosUpShort","HufnagelCustosUpLong","HufnagelCustosUpMedium","HufnagelCustosDownShort","HufnagelCustosDownLong","HufnagelCustosDownMedium","MedicaeaCustosUpShort","MedicaeaCustosUpLong","MedicaeaCustosUpMedium","MedicaeaCustosDownShort","MedicaeaCustosDownLong","MedicaeaCustosDownMedium","MensuralCustosUpShort","MensuralCustosUpLong","MensuralCustosUpMedium","MensuralCustosDownShort","MensuralCustosDownLong","MensuralCustosDownMedium","MensuralFlat","HufnagelFlat","MedicaeaCClef","MedicaeaCClefChange","MedicaeaFClef","MedicaeaFClefChange","HufnagelCClef","HufnagelCClefChange","HufnagelFClef","HufnagelFClefChange","HugnagelCFClef","HufnagelCFClefChange","MensuralFlatHole","HufnagelFlatHole","MedicaeaFlatHole","StarSix","Dagger","Bar.alt","StarHeight","Cross","RBar.alt","VBar.alt","Drawing1","Drawing2","RWithBarGoth","VWithBarGoth","Line1","Line2","Line3","Line4","Line5","Cross.alt","ABarCaption","RBarCaption","VBarCaption","ABarCaptionSC","RBarCaptionSC","VBarCaptionSC","ABar","RBar","VBar","ABarSC","RBarSC","VBarSC","ABarSmall","RBarSmall","VBarSmall","ABarSmallSC","RBarSmallSC","VBarSmallSC","RBar.alt2","VBar.alt2","ABarCaptionSlant","RBarCaptionSlant","VBarCaptionSlant","ABarSlant","RBarSlant","VBarSlant","ABarSmallSlant","RBarSmallSlant","VBarSmallSlant","ChantDocument","ChantScore","ChantMapping","ChantLineBreak","TextOnly","Clef","Note","NoteShapeModifiers","NoteShape","LiquescentType","Large","Small","Ascending","Descending","InitioDebilis","LargeAscending","LargeDescending","SmallAscending","SmallDescending","Virga","Inclinatum","Oriscus","Cavum","Stemmed","Linea","Reverse","liquescent","shape","shapeModifiers","episemata","morae","setStaffPosition","shapeModifier","_ChantNotationElement","defaultAccidental","isClef","activeAccidental","performLayout","accidentalGlyph","createGlyphVisualizer","addVisualizer","small","__defaultDoClef","_Clef","stepToStaffOffset","octaveOffset","staffOffsetToStep","accidentalType","finishLayout","_Clef2","_Clef3","_ChantNotationElement2","sourceLength","_ChantNotationElement3","justify","lb","mappings","useDropCap","Titles","startingClef","compiled","autoColoring","extendLastSystemStaffLines","updateNotations","startLine","endLine","lastLine","selection","elementSelection","element","indices","selectedIndices","insertion","afterElementIndex","insertionCursor","insertionElement","insertionLine","chantLine","InsertionCursor","mapping","nonNoteElementCount","default","elements","recreateDropCap","generateDropCap","initializeLayout","finishedCallback","setTimeout","onFontLoaded","performLayoutAsync","layoutElementsAsync","timeout","Date","getTime","overrideTextLeft","mapAnnotationSpansToTextLeft","layoutTitles","currIndex","ChantLine","buildFromChantNotationIndex","notationsStartIndex","numNotationsOnLine","firstLine","pages","updateSelection","pageHeightOffset","startLineIndex","pageHeight","copyLines","setCanvasSize","clearRect","zoom","xmlns:xlink","version","editable","viewBox","cloneNode","createStyleTree","def","createStyle","lineFragment","fragmentDefs","createDropCap","Gabc","parseChantNotations","unsanitizedText","defaults","layout","default-font","page","margin-left","margin-top","margin-right","margin-bottom","scores","copyLayout","to","unserializeFromJson","serializeToJson","notationBounds","staffLeft","staffRight","custos","ledgerLines","braces","nextLine","previousLine","lyricLineHeight","lyricLineBaseline","numLyricLines","spaceAfterNotations","spaceBetweenTextTracks","lastLyrics","staffSpaces","lastNeumeIndex","extraTextOnlyIndex","altLineHeight","altLineBaseline","numAltLines","translationLineHeight","translationLineBaseline","numTranslationLines","aboveLinesLineHeight","notationBoundsOffset","extraTextOnlyHeight","extraTextOnlyLyricIndex","lastNotation","extraLines","lineWidth","lowestPossibleAnnotationY","lyricAndTextRect","altLineTextRect","totalHeight","strokeStyle","lineTo","layoutInsertionCursor","ledgerLine","functionNames","quickSvg","getInnerNodes","element-index","len","qx1","qx3","newElementStart","beginningLyrics","prev","prevNeume","prevLyrics","condensableSpaces","paddingLeft","DoubleBar","newLyric","elidesToNext","MAX_SAFE_INTEGER","minX","curr","rightNotationBoundary","lastTranslationTextWithEndNeume","lastNotationIndex","lastStartBrace","lastLyricsBeforeTextOnly","textOnlyStartIndex","actualRightBoundary","Custos","isDivider","forceBreak","fitsOnLine","positionNotationElement","candidateForExtraTextOnlyLine","currentLyric","nextNotation","firstOnLine","startExtraTextOnlyFromFirst","lastNotationWithLyrics","reverse","lastLyricRight","setMaxWidth","isTextOnlyBeforeDivider","firstDivider","every","notationsAfterBreak","countSyllables","countNotes","flatMap","cne","firstWithNoWidth","allowLineBreakBeforeNext","maxNumNotationsOnLine","findNeumesToJustify","extraSpace","getWhitespaceOnRight","toJustify","sum","condensable","endNeume","last","isLastLine","whitespace","rightEdge","minHyphenWidth","justifyElements","centerDividers","oldBoundsX","barWidth","leftPoint","rightPoint","FullBar","nextOrCurr","isAccidental","lastRightNeume","lastRightLyric","doJustify","extraSpaceBeforeCustos","increment","toJustifyIndex","nextToJustify","incrementOffsetAtNextChance","startBrace","k","startNote","BraceShape","RoundBrace","getAttachmentX","braceEnd","AccentedCurlyBrace","processElementForLedgerLine","endElem","offsetX","ledgerLinePositionAbove","half","minY","maxY","positionNonLyricText","rightX","beyondStaffRight","ll","episema","spaceBetweenEpisemata","terminating","alignment","HorizontalEpisemaAlignment","Left","Center","Right","newY","newWidth","handleEndBrace","braceStart","nextNotationButOne","nextNoteButOne","BracePoint","BraceAttachment","space","fixedX","total","maxRight","currLyric","minLeft","firstOfSyllable","hasShifted","atLeastOneWithoutConnector","prevLyricRight","condensableSpacesSincePrevLyric","condensableSpaceSincePrevLyric","notationI","currLyricLeft","shift","spaceBetweenSyls","pLyrics","lastCondensable","useMidpoint","minIndex","maxIndex","curIndex","notationX","closenessToLeft","closenessToRight","Ictus","HorizontalEpisema","Accent","_GlyphVisualizer","minDistanceAway","punctumInclinatumShorten","prevNote","staffLineCountParity","staffLineCountNonParity","convertStaffPositionToSymmetric","_GlyphVisualizer2","horizontalOffset","collisionWithEpisema","verticalOffset","shortOffset","extraOffset","collisionWithStaffLine","_GlyphVisualizer3","CurlyBrace","attachment","Accidental","AccidentalType","DominicanBar","HalfBar","QuarterBar","Divider","auto","findNextNeume","pitchToStaffPosition","getGlyphCode","withCarryover","hasCarryover","resetsAccidentals","_Divider","_Divider2","_Divider3","_Divider4","_Divider5","parity","_Divider6","line0","line1","adjustStep","_Divider7","_interopRequireWildcard","__esModule","newObj","GabcHeader","Markings","Signs","Neumes","__syllablesRegex","__altTranslationRegex","__notationsRegex","__notationsRegex_group_bar","__notationsRegex_group_insideBraces","__bracketedCommandRegex","__braceSpecRegex","TrailingSpaceForAccidental","TrailingSpaceMultiple","regexHeaderEnd","regexHeaderLine","regexHeaderComment","comments","cValues","original","txtHeader","arrayName","gabc","alternateKey","array","console","warn","elementCountForNotations","items","item","headerLength","getLength","splitWords","createMappingsFromWords","clef","before","after","oldIndexMap","startOld","startNew","subLength","inew","overlap","_overlap","iold","diffDescriptorsAndNewWords","newGabcSource","insertionIndex","oldInsertionIndex","newWords","results","lastTranslationNeumes","resultCode","resultValues","sourceIndexDiff","elementCount","createMappingFromWord","curNotation","prevIsAccidental","resetDependencies","resetAccidentals","staffPositionToPitch","automatic","needToEndBrace","transText","lastTranslationText","matches","currSyllable","lyricText","pre","main","post","notationData","parseNotations","firstOfParentheses","notationWithLyrics","proposedLyricType","createSyllableLyrics","lyricTexts","_loop","lyricTextWithoutVTags","vtagRegex","vtags","indexClosingBracket","getTrueIndex","indexWithoutVTags","accum","makeLyric","textIndex","centerEndIndex","elides","setForceConnector","baseSourceIndex","addToLastSourceGabc","addNotation","neumes","createNeumesFromNotes","prevNotation","RegExp","atom","bar","barWithCarryover","endsWith","gabcHeightToExsurgeHeight","noteArray","createNoteFromData","accidental","gabcHeightToExsurgePitch","bracketedNotations","finalTrailingSpace","firstNoteIndex","currNoteIndex","createNeume","includeCurrNote","lastNoteIndex","includePrevNote","addNote","unknownState","Punctum","handle","currNote","virgaState","apostrophaState","oriscusState","punctaInclinataState","punctumState","notesRemaining","state","ictus","podatusState","climacusState","clivisState","distrophaState","PunctaInclinata","PesQuassus","Clivis","Podatus","salicusState","scandicusState","pesSubpunctisState","torculusState","porrectusState","Ancus","Climacus","Porrectus","PorrectusFlexus","PesSubpunctis","Salicus","salicusFlexusState","SalicusFlexus","Scandicus","scandicusFlexusState","ScandicusFlexus","bivirgaState","Bivirga","Trivirga","Apostropha","Distropha","tristrophaState","Tristropha","Torculus","prevNoteButOne","torculusResupinusState","TorculusResupinus","TorculusResupinusFlexus","mark","episemaNoteIndex","episemaNote","previousNote","previousMora","episemaHadModifier","newNote","shapeModifers","processInstructionForNote","instruction","sourceIndexOffset","cmd","above","attachmentPoint","gabcNotations","parseWords","gabcWords","parseWord","gabcWord","gabcHeight","charCodeAt","exsurgeHeight","Neume","NeumeBuilder","startingX","lastNote","lineIsHanging","previousNotation","withLineTo","noteAlignsRight","needsLine","linea","noteAt","lowerNote","upperNote","upperGlyph","lowerGlyph","upper","lower","lineFrom","withClivisUpper","withClivisLower","prevStaffPosition","advanceWidth","multiple","start","requiresLedgerLine","positionMarkings","firstAbove","needsAbove","firstBelow","needsBelow","endI","position","positionEpisemata","bottomNote","topNote","positionEpisemataBelow","positionEpisemataAbove","positionPodatusEpisemata","positionPodatusMorae","firstNote","secondNote","thirdNote","hasTopEpisema","positionClivisMarkings","positionClivisMorae","positionClivisEpisemata","positionPodatusMarkings","first","second","third","fourth","_Neume","build","getNoteGlyphCode","_Neume2","virgaAt","advanceBy","_Neume3","_Neume4","positionInclinataMorae","withInclinata","_Neume5","withClivis","_Neume6","middle","builder","middleGlyph","_Neume7","glyphCodes","glyphAdvance","_Neume8","nextNoteStaffPosition","_Neume9","lowerStaffPos","upperStaffPos","withLineEndingAt","_Neume10","withPodatus","_Neume11","_Neume12","positionPorrectusMarkings","thirdGlyph","withPorrectusSwash","_Neume13","positionPorrectusFlexusMarkings","fourthGlyph","_Neume14","_Neume15","_Neume16","_Neume17","positionTorculusMarkings","_Neume18","_Neume19","_Neume20","glyph1","glyph3","note2","note3","_Neume21","firstGlyph","_Neume22","fifthGlyph","fifth","_Neume23","_Neume24","setSupertitle","setTitle","setSubtitle","setTextLeft","setTextRight","elementName","setBoundsX","finalY","el","_arr2","_i2","_arr3","_i3"],"mappings":"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","file":"exsurge.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"exsurge\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"exsurge\"] = factory();\n\telse\n\t\troot[\"exsurge\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"exsurge\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"exsurge\"] = factory();\n\telse\n\t\troot[\"exsurge\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t//\n\t// Author(s):\n\t// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>\n\t//\n\t// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a copy\n\t// of this software and associated documentation files (the \"Software\"), to deal\n\t// in the Software without restriction, including without limitation the rights\n\t// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\t// copies of the Software, and to permit persons to whom the Software is\n\t// furnished to do so, subject to the following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included in\n\t// all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\t// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\t// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\t// THE SOFTWARE.\n\t//\n\t\n\t'use strict';\n\t\n\t// import { Annotation, ChantContext } from './Exsurge.Drawing.js'\n\t// import { Gabc } from './Exsurge.Gabc.js'\n\t//\n\t// // client side support\n\t//\n\t// if (typeof document !== 'undefined' && document.registerElement) {\n\t//   var ChantVisualElementPrototype = Object.create(HTMLElement.prototype);\n\t//\n\t//   ChantVisualElementPrototype.createdCallback = function() {\n\t//     var ctxt = new ChantContext();\n\t//\n\t//     ctxt.setFont(\"'Crimson Text', serif\", 19.2);\n\t//\n\t//     var useDropCap = true;\n\t//     var useDropCapAttr = this.getAttribute(\"use-drop-cap\");\n\t//     if (useDropCapAttr === 'false')\n\t//       useDropCap = false;\n\t//\n\t//     var score = Gabc.loadChantScore(ctxt, this.innerText, useDropCap);\n\t//\n\t//     var annotationAttr = this.getAttribute(\"annotation\");\n\t//     if (annotationAttr) {\n\t//       // add an annotation\n\t//       score.annotation = new Annotation(ctxt, annotationAttr);\n\t//     }\n\t//\n\t//     var _element = this;\n\t//\n\t//     var width = 0;\n\t//     var doLayout = function() {\n\t//       var newWidth = _element.parentElement.clientWidth;\n\t//       if(width === newWidth) return;\n\t//       width = newWidth;\n\t//       // perform layout on the chant\n\t//       score.performLayout(ctxt, function() {\n\t//         score.layoutChantLines(ctxt, width, function() {\n\t//           // render the score to svg code\n\t//           _element.appendElement(score.createSvgNode(ctxt));\n\t//         });\n\t//       });\n\t//     }\n\t//     doLayout();\n\t//     if (window.addEventListener)\n\t//       window.addEventListener('resize',doLayout,false);\n\t//     else if (window.attachEvent)\n\t//       window.attachEvent('onresize',doLayout);\n\t//   }\n\t//\n\t//   ChantVisualElementPrototype.attachedCallback = function() {\n\t//\n\t//   }\n\t//\n\t//   // register the custom element\n\t//   // if(window.customElements && window.customElements.define) {\n\t//   //   window.customElements.define('chant-visual', ChantVisualElementPrototype);\n\t//   // } else {\n\t//     document.registerElement('chant-visual', {\n\t//       prototype: ChantVisualElementPrototype\n\t//     });\n\t//   // }\n\t// }\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _ExsurgeCore = __webpack_require__(1);\n\t\n\tObject.keys(_ExsurgeCore).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _ExsurgeCore[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _ExsurgeText = __webpack_require__(2);\n\t\n\tObject.keys(_ExsurgeText).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _ExsurgeText[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _ExsurgeGlyphs = __webpack_require__(3);\n\t\n\tObject.keys(_ExsurgeGlyphs).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _ExsurgeGlyphs[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _ExsurgeDrawing = __webpack_require__(4);\n\t\n\tObject.keys(_ExsurgeDrawing).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _ExsurgeDrawing[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _ExsurgeChant = __webpack_require__(8);\n\t\n\tObject.keys(_ExsurgeChant).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _ExsurgeChant[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _ExsurgeChantChantLine = __webpack_require__(9);\n\t\n\tObject.keys(_ExsurgeChantChantLine).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _ExsurgeChantChantLine[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _ExsurgeChantMarkings = __webpack_require__(10);\n\t\n\tObject.keys(_ExsurgeChantMarkings).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _ExsurgeChantMarkings[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _ExsurgeChantSigns = __webpack_require__(11);\n\t\n\tObject.keys(_ExsurgeChantSigns).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _ExsurgeChantSigns[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _ExsurgeChantNeumes = __webpack_require__(13);\n\t\n\tObject.keys(_ExsurgeChantNeumes).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _ExsurgeChantNeumes[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _ExsurgeGabc = __webpack_require__(12);\n\t\n\tObject.keys(_ExsurgeGabc).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _ExsurgeGabc[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _ExsurgeTitles = __webpack_require__(14);\n\t\n\tObject.keys(_ExsurgeTitles).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _ExsurgeTitles[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _greextraGlyphs = __webpack_require__(7);\n\t\n\tObject.keys(_greextraGlyphs).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _greextraGlyphs[key];\n\t    }\n\t  });\n\t});\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\texports.DeviceIndependent = DeviceIndependent;\n\texports.Centimeters = Centimeters;\n\texports.Millimeters = Millimeters;\n\texports.Inches = Inches;\n\texports.ToCentimeters = ToCentimeters;\n\texports.ToMillimeters = ToMillimeters;\n\texports.ToInches = ToInches;\n\texports.generateRandomGuid = generateRandomGuid;\n\texports.getCssForProperties = getCssForProperties;\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t//\n\t// Author(s):\n\t// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>\n\t//\n\t// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a copy\n\t// of this software and associated documentation files (the \"Software\"), to deal\n\t// in the Software without restriction, including without limitation the rights\n\t// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\t// copies of the Software, and to permit persons to whom the Software is\n\t// furnished to do so, subject to the following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included in\n\t// all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\t// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\t// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\t// THE SOFTWARE.\n\t//\n\t\n\tvar Units = exports.Units = {\n\t  // enums\n\t  DeviceIndepenedent: 0, // device independent units: 96/inch\n\t  Centimeters: 1,\n\t  Millimeters: 2,\n\t  Inches: 3,\n\t\n\t  // constants for device independent units (diu)\n\t  DIU_PER_INCH: 96,\n\t  DIU_PER_CENTIMETER: 96 / 2.54,\n\t\n\t  ToDeviceIndependent: function ToDeviceIndependent(n, inputUnits) {\n\t    switch (inputUnits) {\n\t      case Centimeters:\n\t        return n * Units.DIU_PER_CENTIMETER;\n\t      case Millimeters:\n\t        return n * Units.DIU_PER_CENTIMETER / 10;\n\t      case Inches:\n\t        return n * Units.DIU_PER_INCH;\n\t      default:\n\t        return n;\n\t    }\n\t  },\n\t\n\t  FromDeviceIndependent: function FromDeviceIndependent(n, outputUnits) {\n\t    switch (outputUnits) {\n\t      case Centimeters:\n\t        return n / Units.DIU_PER_CENTIMETER;\n\t      case Millimeters:\n\t        return n / Units.DIU_PER_CENTIMETER * 10;\n\t      case Inches:\n\t        return n / Units.DIU_PER_INCH;\n\t      default:\n\t        return n;\n\t    }\n\t  },\n\t\n\t  StringToUnitsType: function StringToUnitsType(s) {\n\t    switch (s.ToLower()) {\n\t      case \"in\":\n\t      case \"inches\":\n\t        return Units.Inches;\n\t\n\t      case \"cm\":\n\t      case \"centimeters\":\n\t        return Units.Centimeters;\n\t\n\t      case \"mm\":\n\t      case \"millimeters\":\n\t        return Units.Millimeters;\n\t\n\t      case \"di\":\n\t      case \"device-independent\":\n\t        return Units.DeviceIndepenedent;\n\t\n\t      default:\n\t        return Units.DeviceIndepenedent;\n\t    }\n\t  },\n\t\n\t  UnitsTypeToString: function UnitsTypeToString(units) {\n\t    switch (units) {\n\t      case Units.Inches:\n\t        return \"in\";\n\t      case Units.Centimeters:\n\t        return \"cm\";\n\t      case Units.Millimeters:\n\t        return \"mm\";\n\t      case Units.DeviceIndepenedent:\n\t        return \"device-independent\";\n\t      default:\n\t        return \"device-independent\";\n\t    }\n\t  }\n\t};\n\t\n\tfunction DeviceIndependent(n) {\n\t  return n;\n\t}\n\t\n\tfunction Centimeters(n) {\n\t  return Units.ToDeviceIndependent(n, Units.Centimeters);\n\t}\n\t\n\tfunction Millimeters(n) {\n\t  return Units.ToDeviceIndependent(n, Units.Millimeters);\n\t}\n\t\n\tfunction Inches(n) {\n\t  return Units.ToDeviceIndependent(n, Units.Inches);\n\t}\n\t\n\tfunction ToCentimeters(n) {\n\t  return Units.FromDeviceIndependent(n, Units.Centimeters);\n\t}\n\t\n\tfunction ToMillimeters(n) {\n\t  return Units.FromDeviceIndependent(n, Units.Millimeters);\n\t}\n\t\n\tfunction ToInches(n) {\n\t  return Units.FromDeviceIndependent(n, Units.Inches);\n\t}\n\t\n\t/*\n\t * Point\n\t */\n\t\n\tvar Point = exports.Point = function () {\n\t  function Point(x, y) {\n\t    _classCallCheck(this, Point);\n\t\n\t    this.x = typeof x !== 'undefined' ? x : 0;\n\t    this.y = typeof y !== 'undefined' ? y : 0;\n\t  }\n\t\n\t  _createClass(Point, [{\n\t    key: \"clone\",\n\t    value: function clone() {\n\t      return new Point(this.x, this.y);\n\t    }\n\t  }, {\n\t    key: \"equals\",\n\t    value: function equals(point) {\n\t      return this.x === point.x && this.y === point.y;\n\t    }\n\t  }]);\n\t\n\t  return Point;\n\t}();\n\t\n\t/*\n\t * Rect\n\t */\n\t\n\t\n\tvar Rect = exports.Rect = function () {\n\t  function Rect(x, y, width, height) {\n\t    _classCallCheck(this, Rect);\n\t\n\t    this.x = typeof x !== 'undefined' ? x : Infinity;\n\t    this.y = typeof y !== 'undefined' ? y : Infinity;\n\t    this.width = typeof width !== 'undefined' ? width : -Infinity;\n\t    this.height = typeof height !== 'undefined' ? height : -Infinity;\n\t  }\n\t\n\t  _createClass(Rect, [{\n\t    key: \"clone\",\n\t    value: function clone() {\n\t      return new Rect(this.x, this.y, this.width, this.height);\n\t    }\n\t  }, {\n\t    key: \"isEmpty\",\n\t    value: function isEmpty() {\n\t      return this.x === Infinity && this.y === Infinity && this.width === -Infinity && this.height === -Infinity;\n\t    }\n\t\n\t    // convenience method\n\t\n\t  }, {\n\t    key: \"right\",\n\t    value: function right() {\n\t      return this.x + this.width;\n\t    }\n\t  }, {\n\t    key: \"bottom\",\n\t    value: function bottom() {\n\t      return this.y + this.height;\n\t    }\n\t  }, {\n\t    key: \"equals\",\n\t    value: function equals(rect) {\n\t      return this.x === rect.x && this.y === rect.y && this.width === rect.width && this.height === rect.height;\n\t    }\n\t\n\t    // other can be a Point or a Rect\n\t\n\t  }, {\n\t    key: \"contains\",\n\t    value: function contains(other) {\n\t      if (other instanceof Point) {\n\t        return other.x >= this.x && other.x <= this.x + this.width && other.y >= this.y && other.y <= this.y + this.height;\n\t      } else {\n\t        // better be instance of Rect\n\t        return this.x <= other.x && this.x + this.width >= other.x + other.width && this.y <= other.y && this.y + this.height >= other.y + other.height;\n\t      }\n\t    }\n\t  }, {\n\t    key: \"union\",\n\t    value: function union(rect) {\n\t\n\t      var right = Math.max(this.x + this.width, rect.x + rect.width);\n\t      var bottom = Math.max(this.y + this.height, rect.y + rect.height);\n\t\n\t      this.x = Math.min(this.x, rect.x);\n\t      this.y = Math.min(this.y, rect.y);\n\t\n\t      this.width = right - this.x;\n\t      this.height = bottom - this.y;\n\t    }\n\t  }]);\n\t\n\t  return Rect;\n\t}();\n\t\n\t/**\n\t * Margins\n\t *\n\t * @class\n\t */\n\t\n\t\n\tvar Margins = exports.Margins = function () {\n\t  function Margins(left, top, right, bottom) {\n\t    _classCallCheck(this, Margins);\n\t\n\t    this.left = typeof left !== 'undefined' ? left : 0;\n\t    this.top = typeof top !== 'undefined' ? top : 0;\n\t    this.right = typeof right !== 'undefined' ? right : 0;\n\t    this.bottom = typeof bottom !== 'undefined' ? bottom : 0;\n\t  }\n\t\n\t  _createClass(Margins, [{\n\t    key: \"clone\",\n\t    value: function clone() {\n\t      return new Margins(this.left, this.top, this.right, this.bottom);\n\t    }\n\t  }, {\n\t    key: \"equals\",\n\t    value: function equals(margins) {\n\t      return this.left === margins.left && this.top === margins.top && this.right === margins.right && this.bottom === margins.bottom;\n\t    }\n\t  }]);\n\t\n\t  return Margins;\n\t}();\n\t\n\t/**\n\t * Size\n\t *\n\t * @class\n\t */\n\t\n\t\n\tvar Size = exports.Size = function () {\n\t  function Size(width, height) {\n\t    _classCallCheck(this, Size);\n\t\n\t    this.width = typeof width !== 'undefined' ? width : 0;\n\t    this.height = typeof height !== 'undefined' ? height : 0;\n\t  }\n\t\n\t  _createClass(Size, [{\n\t    key: \"clone\",\n\t    value: function clone() {\n\t      return new Size(this.width, this.height);\n\t    }\n\t  }, {\n\t    key: \"equals\",\n\t    value: function equals(size) {\n\t      return this.width === size.width && this.height === size.height;\n\t    }\n\t  }]);\n\t\n\t  return Size;\n\t}();\n\t\n\t/*\n\t * Pitches, notes\n\t */\n\t\n\t\n\tvar Step = exports.Step = {\n\t  Do: 0,\n\t  Du: 1,\n\t  Re: 2,\n\t  Me: 3,\n\t  Mi: 4,\n\t  Fa: 5,\n\t  Fu: 6,\n\t  So: 7,\n\t  La: 9,\n\t  Te: 10,\n\t  Ti: 11\n\t};\n\t\n\t// this little array helps map step values to staff positions. The numeric values of steps\n\t// correspond to whole step increments (2) or half step increments (1). This gives us the ability\n\t// to compare pitches precisely, but makes it challenging to place steps on the staff. this little\n\t// array maps the steps to an incremental position the steps take on the staff line. This works\n\t// so simply because chant only uses do and fa clefs, and only has a flatted ti (te), making\n\t// for relatively easy mapping to staff line locations.\n\t//                         Do Du Re Me Mi Fa Fu So    La Te Ti\n\tvar __StepToStaffPosition = [0, 0, 1, 1, 2, 3, 3, 4, 4, 5, 6, 6];\n\tvar __StaffOffsetToStep = [Step.Do, Step.Re, Step.Mi, Step.Fa, Step.So, Step.La, Step.Ti]; // no accidentals in this one\n\t\n\t\n\tvar Pitch = exports.Pitch = function () {\n\t  function Pitch(step, octave) {\n\t    _classCallCheck(this, Pitch);\n\t\n\t    if (typeof octave === 'undefined') {\n\t      octave = Math.floor(step / 12);\n\t      step = step % 12;\n\t    }\n\t    this.step = step;\n\t    this.octave = octave;\n\t  }\n\t\n\t  _createClass(Pitch, [{\n\t    key: \"toInt\",\n\t    value: function toInt() {\n\t      return this.octave * 12 + this.step;\n\t    }\n\t  }, {\n\t    key: \"transpose\",\n\t    value: function transpose(step) {\n\t      return new Pitch(this.toInt() + step);\n\t    }\n\t  }, {\n\t    key: \"isHigherThan\",\n\t    value: function isHigherThan(pitch) {\n\t      return this.toInt() > pitch.toInt();\n\t    }\n\t  }, {\n\t    key: \"isLowerThan\",\n\t    value: function isLowerThan(pitch) {\n\t      return this.toInt() < pitch.toInt();\n\t    }\n\t  }, {\n\t    key: \"equals\",\n\t    value: function equals(pitch) {\n\t      return this.toInt() === pitch.toInt();\n\t    }\n\t  }], [{\n\t    key: \"stepToStaffOffset\",\n\t    value: function stepToStaffOffset(step) {\n\t      return __StepToStaffPosition[step];\n\t    }\n\t  }, {\n\t    key: \"staffOffsetToStep\",\n\t    value: function staffOffsetToStep(offset) {\n\t      while (offset < 0) {\n\t        offset = __StaffOffsetToStep.length + offset;\n\t      }return __StaffOffsetToStep[offset % __StaffOffsetToStep.length];\n\t    }\n\t  }]);\n\t\n\t  return Pitch;\n\t}();\n\t\n\tfunction generateRandomGuid() {\n\t  function s4() {\n\t    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n\t  }\n\t  return s4() + s4();\n\t}\n\t\n\tfunction getCssForProperties(properties) {\n\t  return Object.entries(properties).map(function (_ref) {\n\t    var _ref2 = _slicedToArray(_ref, 2),\n\t        key = _ref2[0],\n\t        val = _ref2[1];\n\t\n\t    return key && val && key !== \"class\" ? key + \": \" + val + \";\" : \"\";\n\t  }).join(\"\");\n\t}\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t//\n\t\n\t/**\n\t * @class\n\t */\n\tvar Language = exports.Language = function () {\n\t  function Language(name) {\n\t    _classCallCheck(this, Language);\n\t\n\t    this.name = typeof name !== \"undefined\" ? name : \"<unknown>\";\n\t    this.centerNeume = false;\n\t  }\n\t\n\t  /**\n\t   * @param {String} text The string to parsed into words.\n\t   * @return {Word[]} the resulting parsed words from syllabification\n\t   */\n\t\n\t\n\t  _createClass(Language, [{\n\t    key: \"syllabify\",\n\t    value: function syllabify(text) {\n\t      var parsedWords = [];\n\t\n\t      if (typeof text === \"undefined\" || text === \"\") return parsedWords;\n\t\n\t      // Divide the text into words separated by whitespace\n\t      var words = text.split(/[\\s]+/);\n\t\n\t      for (var i = 0, end = words.length; i < end; i++) {\n\t        parsedWords.push(this.syllabifyWord(words[i]));\n\t      }return parsedWords;\n\t    }\n\t  }]);\n\t\n\t  return Language;\n\t}();\n\t\n\tvar English = exports.English = function (_Language) {\n\t  _inherits(English, _Language);\n\t\n\t  function English() {\n\t    _classCallCheck(this, English);\n\t\n\t    var _this = _possibleConstructorReturn(this, (English.__proto__ || Object.getPrototypeOf(English)).call(this, \"English\"));\n\t\n\t    _this.centerNeume = true;\n\t    _this.regexLetter = /[a-z\\u00c0-\\u02af\\u0300-\\u036f\\u1e00-\\u1eff‿]+/i;\n\t    return _this;\n\t  }\n\t\n\t  /**\n\t   * @param {String} s the string to search\n\t   * @param {Number} startIndex The index at which to start searching for a vowel in the string\n\t   * @retuns a custom class with three properties: {found: (true/false) startIndex: (start index in s of vowel segment) length ()}\n\t   */\n\t\n\t\n\t  _createClass(English, [{\n\t    key: \"findVowelSegment\",\n\t    value: function findVowelSegment(s, startIndex) {\n\t      var match = this.regexLetter.exec(s.slice(startIndex));\n\t      if (match) return {\n\t        found: true,\n\t        startIndex: startIndex + match.index,\n\t        length: match[0].length\n\t      };\n\t\n\t      // no vowels sets found after startIndex!\n\t      return { found: false, startIndex: -1, length: -1 };\n\t    }\n\t  }]);\n\t\n\t  return English;\n\t}(Language);\n\t\n\t/**\n\t * @class\n\t */\n\t\n\t\n\tvar Latin = exports.Latin = function (_Language2) {\n\t  _inherits(Latin, _Language2);\n\t\n\t  /**\n\t   * @constructs\n\t   */\n\t  function Latin() {\n\t    _classCallCheck(this, Latin);\n\t\n\t    // fixme: ui is only diphthong in the exceptional cases below (according to Wheelock's Latin)\n\t    var _this2 = _possibleConstructorReturn(this, (Latin.__proto__ || Object.getPrototypeOf(Latin)).call(this, \"Latin\"));\n\t\n\t    _this2.diphthongs = [\"ae\", \"au\", \"oe\", \"aé\", \"áu\", \"oé\"];\n\t    // for centering over the vowel, we will need to know any combinations that might be diphthongs:\n\t    _this2.possibleDiphthongs = _this2.diphthongs.concat([\"ei\", \"eu\", \"ui\", \"éi\", \"éu\", \"úi\"]);\n\t    _this2.regexVowel = /(i|(?:[qg]|^)u)?([eé][iu]|[uú]i|[ao][eé]|[aá]u|[aeiouáéíóúäëïöüāēīōūăĕĭŏŭåe̊o̊ůæœǽyýÿ])/gi;\n\t\n\t    // some words that are simply exceptions to standard syllabification rules!\n\t    var wordExceptions = new Object();\n\t\n\t    // ui combos pronounced as diphthongs\n\t    wordExceptions[\"huius\"] = [\"hui\", \"us\"];\n\t    wordExceptions[\"cuius\"] = [\"cui\", \"us\"];\n\t    wordExceptions[\"huic\"] = [\"huic\"];\n\t    wordExceptions[\"cui\"] = [\"cui\"];\n\t    wordExceptions[\"hui\"] = [\"hui\"];\n\t\n\t    // eu combos pronounced as diphthongs\n\t    wordExceptions[\"euge\"] = [\"eu\", \"ge\"];\n\t    wordExceptions[\"seu\"] = [\"seu\"];\n\t\n\t    _this2.vowels = [\"a\", \"e\", \"i\", \"o\", \"u\", \"á\", \"é\", \"í\", \"ó\", \"ú\", \"ä\", \"ë\", \"ï\", \"ö\", \"ü\", \"ā\", \"ē\", \"ī\", \"ō\", \"ū\", \"ă\", \"ĕ\", \"ĭ\", \"ŏ\", \"ŭ\", \"å\", \"e̊\", \"o̊\", \"ů\", \"æ\", \"œ\", \"ǽ\", // no accented œ in unicode?\n\t    \"y\", \"ý\", \"ÿ\"]; // y is treated as a vowel; not native to Latin but useful for words borrowed from Greek\n\t\n\t    _this2.vowelsThatMightBeConsonants = [\"i\", \"u\"];\n\t\n\t    _this2.muteConsonantsAndF = [\"b\", \"c\", \"d\", \"g\", \"p\", \"t\", \"f\"];\n\t\n\t    _this2.liquidConsonants = [\"l\", \"r\"];\n\t    return _this2;\n\t  }\n\t\n\t  // c must be lowercase!\n\t\n\t\n\t  _createClass(Latin, [{\n\t    key: \"isVowel\",\n\t    value: function isVowel(c) {\n\t      for (var i = 0, end = this.vowels.length; i < end; i++) {\n\t        if (this.vowels[i] === c) return true;\n\t      }return false;\n\t    }\n\t  }, {\n\t    key: \"isVowelThatMightBeConsonant\",\n\t    value: function isVowelThatMightBeConsonant(c) {\n\t      for (var i = 0, end = this.vowelsThatMightBeConsonants.length; i < end; i++) {\n\t        if (this.vowelsThatMightBeConsonants[i] === c) return true;\n\t      }return false;\n\t    }\n\t\n\t    // substring should be a vowel and the character following\n\t\n\t  }, {\n\t    key: \"isVowelActingAsConsonant\",\n\t    value: function isVowelActingAsConsonant(substring) {\n\t      return this.isVowelThatMightBeConsonant(substring[0]) && this.isVowel(substring[1]);\n\t    }\n\t\n\t    /**\n\t     * f is not a mute consonant, but we lump it together for syllabification\n\t     * since it is syntactically treated the same way\n\t     *\n\t     * @param {String} c The character to test; must be lowercase\n\t     * @return {boolean} true if c is an f or a mute consonant\n\t     */\n\t\n\t  }, {\n\t    key: \"isMuteConsonantOrF\",\n\t    value: function isMuteConsonantOrF(c) {\n\t      for (var i = 0, end = this.muteConsonantsAndF.length; i < end; i++) {\n\t        if (this.muteConsonantsAndF[i] === c) return true;\n\t      }return false;\n\t    }\n\t\n\t    /**\n\t     *\n\t     * @param {String} c The character to test; must be lowercase\n\t     * @return {boolean} true if c is a liquid consonant\n\t     */\n\t\n\t  }, {\n\t    key: \"isLiquidConsonant\",\n\t    value: function isLiquidConsonant(c) {\n\t      for (var i = 0, end = this.liquidConsonants.length; i < end; i++) {\n\t        if (this.liquidConsonants[i] === c) return true;\n\t      }return false;\n\t    }\n\t\n\t    /**\n\t     *\n\t     * @param {String} s The string to test; must be lowercase\n\t     * @return {boolean} true if s is a diphthong\n\t     */\n\t\n\t  }, {\n\t    key: \"isDiphthong\",\n\t    value: function isDiphthong(s) {\n\t      for (var i = 0, end = this.diphthongs.length; i < end; i++) {\n\t        if (this.diphthongs[i] === s) return true;\n\t      }return false;\n\t    }\n\t\n\t    /**\n\t     *\n\t     * @param {String} s The string to test; must be lowercase\n\t     * @return {boolean} true if s is a diphthong\n\t     */\n\t\n\t  }, {\n\t    key: \"isPossibleDiphthong\",\n\t    value: function isPossibleDiphthong(s) {\n\t      for (var i = 0, end = this.possibleDiphthongs.length; i < end; i++) {\n\t        if (this.possibleDiphthongs[i] === s) return true;\n\t      }return false;\n\t    }\n\t\n\t    /**\n\t     * Rules for Latin syllabification (from Collins, \"A Primer on Ecclesiastical Latin\")\n\t     *\n\t     * Divisions occur when:\n\t     *   1. After open vowels (those not followed by a consonant) (e.g., \"pi-us\" and \"De-us\")\n\t     *   2. After vowels followed by a single consonant (e.g., \"vi-ta\" and \"ho-ra\")\n\t     *   3. After the first consonant when two or more consonants follow a vowel\n\t     *      (e.g., \"mis-sa\", \"minis-ter\", and \"san-ctus\").\n\t     *\n\t     * Exceptions:\n\t     *   1. In compound words the consonants stay together (e.g., \"de-scribo\").\n\t     *   2. A mute consonant (b, c, d, g, p, t) or f followed by a liquid consonant (l, r)\n\t     *      go with the succeeding vowel: \"la-crima\", \"pa-tris\"\n\t     *\n\t     * In addition to these rules, Wheelock's Latin provides this sound exception:\n\t     *   -  Also counted as single consonants are qu and the aspirates ch, ph,\n\t     *      th, which should never be separated in syllabification:\n\t     *      architectus, ar-chi-tec-tus; loquacem, lo-qua-cem.\n\t     *\n\t     */\n\t\n\t  }, {\n\t    key: \"syllabifyWord\",\n\t    value: function syllabifyWord(word) {\n\t      var syllables = [];\n\t      var haveCompleteSyllable = false;\n\t      var previousWasVowel = false;\n\t      var workingString = word.toLowerCase();\n\t      var startSyllable = 0;\n\t\n\t      var c, lookahead, haveLookahead;\n\t\n\t      // a helper function to create syllables\n\t      var makeSyllable = function makeSyllable(length) {\n\t        if (haveCompleteSyllable) {\n\t          syllables.push(word.substr(startSyllable, length));\n\t          startSyllable += length;\n\t        }\n\t\n\t        haveCompleteSyllable = false;\n\t      };\n\t\n\t      for (var i = 0, wordLength = workingString.length; i < wordLength; i++) {\n\t        c = workingString[i];\n\t\n\t        // get our lookahead in case we need them...\n\t        lookahead = \"*\";\n\t        haveLookahead = i + 1 < wordLength;\n\t\n\t        if (haveLookahead) lookahead = workingString[i + 1];\n\t\n\t        var cIsVowel = this.isVowel(c);\n\t\n\t        // i is a special case for a vowel. when i is at the beginning\n\t        // of the word (Iesu) or i is between vowels (alleluia),\n\t        // then the i is treated as a consonant (y)\n\t        if (c === \"i\") {\n\t          if (i === 0 && haveLookahead && this.isVowel(lookahead)) cIsVowel = false;else if (previousWasVowel && haveLookahead && this.isVowel(lookahead)) {\n\t            cIsVowel = false;\n\t          }\n\t        }\n\t\n\t        if (c === \"-\") {\n\t          // a hyphen forces a syllable break, which effectively resets\n\t          // the logic...\n\t\n\t          haveCompleteSyllable = true;\n\t          previousWasVowel = false;\n\t          makeSyllable(i - startSyllable);\n\t          startSyllable++;\n\t        } else if (cIsVowel) {\n\t          // once we get a vowel, we have a complete syllable\n\t          haveCompleteSyllable = true;\n\t\n\t          if (previousWasVowel && !this.isDiphthong(workingString[i - 1] + \"\" + c)) {\n\t            makeSyllable(i - startSyllable);\n\t            haveCompleteSyllable = true;\n\t          }\n\t\n\t          previousWasVowel = true;\n\t        } else if (haveLookahead) {\n\t          if (c === \"q\" && lookahead === \"u\" || lookahead === \"h\" && (c === \"c\" || c === \"p\" || c === \"t\")) {\n\t            // handle wheelock's exceptions for qu, ch, ph and th\n\t            makeSyllable(i - startSyllable);\n\t            i++; // skip over the 'h' or 'u'\n\t          } else if (previousWasVowel && this.isVowel(lookahead)) {\n\t            // handle division rule 2\n\t            makeSyllable(i - startSyllable);\n\t          } else if (this.isMuteConsonantOrF(c) && this.isLiquidConsonant(lookahead)) {\n\t            // handle exception 2\n\t            makeSyllable(i - startSyllable);\n\t          } else if (haveCompleteSyllable) {\n\t            // handle division rule 3\n\t            makeSyllable(i + 1 - startSyllable);\n\t          }\n\t\n\t          previousWasVowel = false;\n\t        }\n\t      }\n\t\n\t      // if we have a complete syllable, we can add it as a new one. Otherwise\n\t      // we tack the remaining characters onto the last syllable.\n\t      if (haveCompleteSyllable) syllables.push(word.substr(startSyllable));else if (startSyllable > 0) syllables[syllables.length - 1] += word.substr(startSyllable);\n\t\n\t      return syllables;\n\t    }\n\t\n\t    /**\n\t     * @param {String} s the string to search\n\t     * @param {Number} startIndex The index at which to start searching for a vowel in the string\n\t     * @retuns a custom class with three properties: {found: (true/false) startIndex: (start index in s of vowel segment) length ()}\n\t     */\n\t\n\t  }, {\n\t    key: \"findVowelSegment\",\n\t    value: function findVowelSegment(s, startIndex, ignore) {\n\t      var _this3 = this;\n\t\n\t      this.regexVowel.lastIndex = 0;\n\t      var stringSlice = s.slice(startIndex);\n\t      var match = this.regexVowel.exec(stringSlice);\n\t      var isIgnoredMatch = function isIgnoredMatch(_ref) {\n\t        var index = _ref.index,\n\t            endIndex = _ref.endIndex;\n\t        return index <= match.index && endIndex > match.index || index < _this3.regexVowel.lastIndex && endIndex >= _this3.regexVowel.lastIndex;\n\t      };\n\t      var inIgnore = match && ignore && ignore.length && ignore.find(isIgnoredMatch);\n\t      while (inIgnore) {\n\t        match = this.regexVowel.exec(stringSlice);\n\t        inIgnore = match && ignore.find(isIgnoredMatch);\n\t      }\n\t      if (match) {\n\t        if (match[1]) {\n\t          // the first group should be ignored, as it is to separate an i or u that is used as a consonant.\n\t          match.index += match[1].length;\n\t        }\n\t        return {\n\t          found: true,\n\t          startIndex: startIndex + match.index,\n\t          length: match[2].length\n\t        };\n\t      }\n\t\n\t      // no vowels sets found after startIndex!\n\t      return { found: false, startIndex: -1, length: -1 };\n\t    }\n\t  }]);\n\t\n\t  return Latin;\n\t}(Language);\n\t\n\t/**\n\t * @class\n\t */\n\t\n\t\n\tvar Spanish = exports.Spanish = function (_Language3) {\n\t  _inherits(Spanish, _Language3);\n\t\n\t  function Spanish() {\n\t    _classCallCheck(this, Spanish);\n\t\n\t    var _this4 = _possibleConstructorReturn(this, (Spanish.__proto__ || Object.getPrototypeOf(Spanish)).call(this, \"Spanish\"));\n\t\n\t    _this4.vowels = [\"a\", \"e\", \"i\", \"o\", \"u\", \"y\", \"á\", \"é\", \"í\", \"ó\", \"ú\", \"ü\"];\n\t\n\t    _this4.weakVowels = [\"i\", \"u\", \"ü\", \"y\"];\n\t\n\t    _this4.strongVowels = [\"a\", \"e\", \"o\", \"á\", \"é\", \"í\", \"ó\", \"ú\"];\n\t\n\t    _this4.diphthongs = [\"ai\", \"ei\", \"oi\", \"ui\", \"ia\", \"ie\", \"io\", \"iu\", \"au\", \"eu\", \"ou\", \"ua\", \"ue\", \"uo\", \"ái\", \"éi\", \"ói\", \"úi\", \"iá\", \"ié\", \"ió\", \"iú\", \"áu\", \"éu\", \"óu\", \"uá\", \"ué\", \"uó\", \"üe\", \"üi\"];\n\t\n\t    _this4.uDiphthongExceptions = [\"gue\", \"gui\", \"qua\", \"que\", \"qui\", \"quo\"];\n\t    return _this4;\n\t  }\n\t\n\t  // c must be lowercase!\n\t\n\t\n\t  _createClass(Spanish, [{\n\t    key: \"isVowel\",\n\t    value: function isVowel(c) {\n\t      for (var i = 0, end = this.vowels.length; i < end; i++) {\n\t        if (this.vowels[i] === c) return true;\n\t      }return false;\n\t    }\n\t\n\t    /**\n\t     * @param {String} c The character to test; must be lowercase\n\t     * @return {boolean} true if c is an f or a mute consonant\n\t     */\n\t\n\t  }, {\n\t    key: \"isWeakVowel\",\n\t    value: function isWeakVowel(c) {\n\t      for (var i = 0, end = this.weakVowels.length; i < end; i++) {\n\t        if (this.weakVowels[i] === c) return true;\n\t      }return false;\n\t    }\n\t\n\t    /**\n\t     * @param {String} c The character to test; must be lowercase\n\t     * @return {boolean} true if c is an f or a mute consonant\n\t     */\n\t\n\t  }, {\n\t    key: \"isStrongVowel\",\n\t    value: function isStrongVowel(c) {\n\t      for (var i = 0, end = this.strongVowels.length; i < end; i++) {\n\t        if (this.strongVowels[i] === c) return true;\n\t      }return false;\n\t    }\n\t\n\t    /**\n\t     *\n\t     * @param {String} s The string to test; must be lowercase\n\t     * @return {boolean} true if s is a diphthong\n\t     */\n\t\n\t  }, {\n\t    key: \"isDiphthong\",\n\t    value: function isDiphthong(s) {\n\t      for (var i = 0, end = this.diphthongs.length; i < end; i++) {\n\t        if (this.diphthongs[i] === s) return true;\n\t      }return false;\n\t    }\n\t  }, {\n\t    key: \"createSyllable\",\n\t    value: function createSyllable(text) {\n\t      /*\n\t      var accented = false;\n\t      var ellidesToNext = false;\n\t       if (text.length > 0) {\n\t           if (text[0] == '`') {\n\t              accented = true;\n\t              text = text.substr(1);\n\t          }\n\t           if (text[text.length - 1] == '_') {\n\t              ellidesToNext = true;\n\t              text = text.substr(0, text.length - 1);\n\t          }\n\t      }\n\t       var s = new Syllable(text);\n\t       s.isMusicalAccent = accented;\n\t      s.elidesToNext = ellidesToNext;*/\n\t\n\t      return text;\n\t    }\n\t\n\t    /**\n\t     */\n\t\n\t  }, {\n\t    key: \"syllabifyWord\",\n\t    value: function syllabifyWord(word) {\n\t      var syllables = [];\n\t\n\t      var haveCompleteSyllable = false;\n\t      var previousIsVowel = false;\n\t      var previousIsStrongVowel = false; // only valid if previousIsVowel == true\n\t      var startSyllable = 0;\n\t\n\t      // fixme: first check for prefixes\n\t\n\t      for (var i = 0; i < word.length; i++) {\n\t        var c = word[i].toLowerCase();\n\t\n\t        if (this.isVowel(c)) {\n\t          // we have a complete syllable as soon as we have a vowel\n\t          haveCompleteSyllable = true;\n\t\n\t          var cIsStrongVowel = this.isStrongVowel(c);\n\t\n\t          if (previousIsVowel) {\n\t            // if we're at a strong vowel, then we finish out the last syllable\n\t            if (cIsStrongVowel) {\n\t              if (previousIsStrongVowel) {\n\t                syllables.push(this.createSyllable(word.substr(startSyllable, i - startSyllable)));\n\t                startSyllable = i;\n\t              }\n\t            }\n\t          }\n\t\n\t          previousIsVowel = true;\n\t          previousIsStrongVowel = cIsStrongVowel;\n\t        } else {\n\t          if (!haveCompleteSyllable) {\n\t            // do nothing since we don't have a complete syllable yet...\n\t          } else {\n\t            // handle explicit syllable breaks\n\t            if (word[i] === \"-\") {\n\t              // start new syllable\n\t              syllables.push(this.createSyllable(word.substr(startSyllable, i - startSyllable)));\n\t              startSyllable = ++i;\n\t            } else {\n\t              var numberOfConsonants = 1,\n\t                  consonant2;\n\t\n\t              // count how many more consonants there are\n\t              for (var j = i + 1; j < word.length; j++) {\n\t                if (this.isVowel(word[j])) break;\n\t                numberOfConsonants++;\n\t              }\n\t\n\t              if (numberOfConsonants === 1) {\n\t                // start new syllable\n\t                syllables.push(this.createSyllable(word.substr(startSyllable, i - startSyllable)));\n\t                startSyllable = i;\n\t              } else if (numberOfConsonants === 2) {\n\t                consonant2 = word[i + 1].toLowerCase();\n\t                if (consonant2 === \"l\" || consonant2 === \"r\" || c === \"c\" && consonant2 === \"h\") {\n\t                  // split before the consonant pair\n\t                  syllables.push(this.createSyllable(word.substr(startSyllable, i - startSyllable)));\n\t                  startSyllable = i++;\n\t                } else {\n\t                  //split the consonants\n\t                  syllables.push(this.createSyllable(word.substr(startSyllable, ++i - startSyllable)));\n\t                  startSyllable = i;\n\t                }\n\t              } else if (numberOfConsonants === 3) {\n\t                consonant2 = word[i + 1].toLowerCase();\n\t\n\t                // if second consonant is s, divide cc-c, otherwise divide c-cc\n\t                if (consonant2 === \"s\") {\n\t                  i += 2;\n\t                  syllables.push(this.createSyllable(word.substr(startSyllable, i - startSyllable)));\n\t                } else syllables.push(this.createSyllable(word.substr(startSyllable, ++i - startSyllable)));\n\t\n\t                startSyllable = i;\n\t              } else if (numberOfConsonants === 4) {\n\t                // four always get split cc-cc\n\t                syllables.push(this.createSyllable(word.substr(startSyllable, i - startSyllable + 2)));\n\t                startSyllable = i + 2;\n\t                i += 3;\n\t              }\n\t            }\n\t\n\t            haveCompleteSyllable = false;\n\t          }\n\t\n\t          previousIsVowel = false;\n\t        }\n\t      }\n\t\n\t      // if we have a complete syllable, we can add it as a new one. Otherwise\n\t      // we tack the remaining characters onto the last syllable.\n\t      if (haveCompleteSyllable) syllables.push(word.substr(startSyllable));else if (startSyllable > 0) syllables[syllables.length - 1] += word.substr(startSyllable);else if (syllables.length === 0) syllables.push(this.createSyllable(word));\n\t\n\t      return syllables;\n\t    }\n\t\n\t    /**\n\t     * @param {String} s the string to search\n\t     * @param {Number} startIndex The index at which to start searching for a vowel in the string\n\t     * @retuns a custom class with three properties: {found: (true/false) startIndex: (start index in s of vowel segment) length ()}\n\t     */\n\t\n\t  }, {\n\t    key: \"findVowelSegment\",\n\t    value: function findVowelSegment(s, startIndex) {\n\t      var i, end, index;\n\t      var workingString = s.toLowerCase();\n\t\n\t      // do we have a diphthongs?\n\t      for (i = 0, end = this.diphthongs.length; i < end; i++) {\n\t        var d = this.diphthongs[i];\n\t        index = workingString.indexOf(d, startIndex);\n\t\n\t        if (index >= 0) {\n\t          // check the exceptions...\n\t          if (d[0] === \"u\" && index > 0) {\n\t            var tripthong = s.substr(index - 1, 3).toLowerCase();\n\t\n\t            for (var j = 0, endj = this.uDiphthongExceptions.length; i < endj; j++) {\n\t              if (tripthong === this.uDiphthongExceptions[j]) {\n\t                // search from after the u...\n\t                return this.findVowelSegment(s, index + 1);\n\t              }\n\t            }\n\t          }\n\t\n\t          return { found: true, startIndex: index, length: d.length };\n\t        }\n\t      }\n\t\n\t      // no diphthongs. Let's look for single vowels then...\n\t      for (i = 0, end = this.vowels.length; i < end; i++) {\n\t        index = workingString.indexOf(this.vowels[i], startIndex);\n\t\n\t        if (index >= 0) return { found: true, startIndex: index, length: 1 };\n\t      }\n\t\n\t      // no vowels sets found after startIndex!\n\t      return { found: false, startIndex: -1, length: -1 };\n\t    }\n\t  }]);\n\t\n\t  return Spanish;\n\t}(Language);\n\t\n\tvar language = exports.language = {\n\t  english: new English(),\n\t  latin: new Latin(),\n\t  spanish: new Spanish()\n\t};\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t//\n\t// Author(s):\n\t// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>\n\t//\n\t// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a copy\n\t// of this software and associated documentation files (the \"Software\"), to deal\n\t// in the Software without restriction, including without limitation the rights\n\t// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\t// copies of the Software, and to permit persons to whom the Software is\n\t// furnished to do so, subject to the following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included in\n\t// all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\t// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\t// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\t// THE SOFTWARE.\n\t//\n\t\n\t// generated based on the svg data\n\tvar Glyphs = exports.Glyphs = {\n\t  None: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 0,\n\t      height: 0\n\t    },\n\t    origin: {\n\t      x: 0,\n\t      y: 0\n\t    },\n\t    align: \"left\"\n\t  },\n\t  AcuteAccent: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M4 0C-.614.52-.614.52-.803-3.182l60.768-108.422c4.52-7.182 10.543-13.67 18.075-13.67 5.27 0 14.31 1.264 23.346 7.793 7.53 5.223 8.803 11.752 8.803 16.975 0 3.917-.52 11.1-8.05 17.628L4 0z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 0, // TODO: figure out a better way to align this horizontally.  width should be 110.992,\n\t      height: 125.794\n\t    },\n\t    origin: {\n\t      x: 0.803,\n\t      y: 125.274\n\t    },\n\t    align: \"left\"\n\t  },\n\t  GraveAccent: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M105.386.26C110 .78 110 .78 110.189-2.922l-60.768-108.422c-4.52-7.182-10.543-13.67-18.075-13.67-5.27 0-14.31 1.264-23.346 7.793-7.53 5.223-8.803 11.752-8.803 16.975 0 3.917.52 11.1 8.05 17.628L105.386.26z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 0, //110.992,\n\t      height: 125.794\n\t    },\n\t    origin: {\n\t      x: 0, // -110.992,\n\t      y: 125.274\n\t    },\n\t    align: \"left\"\n\t  },\n\t  Circle: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M0 -50A50 50 0 0 0 100 -50 50 50 0 0 0 0 -50M10 -50A40 40 0 0 1 90 -50 40 40 0 0 1 10 -50\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 100,\n\t      height: 100\n\t    },\n\t    origin: {\n\t      x: -50,\n\t      y: 100\n\t    }\n\t  },\n\t  Semicircle: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M0 -50A50 50 0 0 0 100 -50 5 5 0 0 0 90 -50 40 40 0 0 1 10 -50 5 5 0 0 0 0 -50\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 100,\n\t      height: 55\n\t    },\n\t    origin: {\n\t      x: -50,\n\t      y: 50\n\t    }\n\t  },\n\t  ReversedSemicircle: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M0 0A50 50 0 0 1 100 0 5 5 0 0 1 90 0 40 40 0 0 0 10 0 5 5 0 0 1 0 0\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 100,\n\t      height: 55\n\t    },\n\t    origin: {\n\t      x: -50,\n\t      y: 50\n\t    }\n\t  },\n\t  Stropha: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M1.22-73.438c4.165 13.02 12.238 27.084 24.217 42.188L49.657 0 34.812 27.344C18.666 55.47-.084 72.396-21.438 78.124c4.687-3.645 7.03-8.593 7.03-14.843 0-8.853-4.947-20.572-14.843-35.155L-48 0 1.22-73.438z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 97.657,\n\t      height: 151.562\n\t    },\n\t    origin: {\n\t      x: 48,\n\t      y: 73.438\n\t    },\n\t    align: \"left\"\n\t  },\n\t  BeginningAscLiquescent: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M-50 43.688V-61c4.167 7.292 12.76 10.938 25.78 10.938 9.376 0 20.053-1.563 32.032-4.688C31.773-60.48 45.833-71.677 50-88.344v117.97C43.75 42.645 32.812 51.5 17.187 56.186-.52 61.398-15.886 64-28.906 64-42.97 64-50 57.23-50 43.687z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 100,\n\t      height: 152.344\n\t    },\n\t    origin: {\n\t      x: 50,\n\t      y: 88.344\n\t    },\n\t    align: \"left\"\n\t  },\n\t  BeginningDesLiquescent: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M-50-56.03c0-13.022 7.03-19.532 21.094-19.532 13.02 0 28.385 2.604 46.093 7.812C32.813-63.583 43.75-54.73 50-41.187V76C45.833 59.854 31.77 48.656 7.812 42.406c-11.98-3.125-22.656-4.687-32.03-4.687-13.022 0-21.615 3.905-25.782 11.718v-105.47z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 100,\n\t      height: 151.562\n\t    },\n\t    origin: {\n\t      x: 50,\n\t      y: 75.562\n\t    },\n\t    align: \"left\"\n\t  },\n\t  CustosDescLong: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M39.063 273.472c5.73.52 7.29-6.25 4.687-20.312V-65.59c-13.542 2.083-24.22 5.468-32.03 10.156C3.905-50.226 0-43.714 0-35.904V71.91c5.73-5.21 10.677-8.594 14.844-10.157 5.73-1.562 12.24-2.343 19.53-2.343v196.875c0 11.458 1.563 17.187 4.688 17.187\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 46.353,\n\t      height: 339.582\n\t    },\n\t    origin: {\n\t      x: 0,\n\t      y: 65.59\n\t    },\n\t    align: \"left\"\n\t  },\n\t  CustosDescShort: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M34.375 191.923c0 8.333 1.563 12.24 4.688 11.72 3.125-.522 4.687-7.033 4.687-19.533v-250c-13.542 2.084-24.22 5.47-32.03 10.157C3.905-50.525 0-44.015 0-36.203V71.61c5.73-5.208 10.677-8.593 14.844-10.156 5.73-1.562 12.24-2.344 19.53-2.344v132.813z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 43.75,\n\t      height: 270.053\n\t    },\n\t    origin: {\n\t      x: 0,\n\t      y: 65.89\n\t    },\n\t    align: \"left\"\n\t  },\n\t  CustosLong: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M39.063-269.562c5.73-.52 7.29 6.25 4.687 20.312V69.5c-13.542-2.083-24.22-5.47-32.03-10.156C3.905 54.134 0 47.624 0 39.812V-68c5.73 5.208 10.677 8.594 14.844 10.156 5.73 1.563 12.24 2.344 19.53 2.344v-196.875c0-11.458 1.563-17.187 4.688-17.187z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 46.353,\n\t      height: 339.582\n\t    },\n\t    origin: {\n\t      x: 0,\n\t      y: 270.082\n\t    },\n\t    align: \"left\"\n\t  },\n\t  CustosShort: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M34.375-188.125c0-8.333 1.563-12.24 4.688-11.72 3.125.522 4.687 7.033 4.687 19.532v250c-13.542-2.083-24.22-5.468-32.03-10.156C3.905 54.324 0 47.813 0 40V-67.813c5.73 5.21 10.677 8.594 14.844 10.157 5.73 1.562 12.24 2.344 19.53 2.343v-132.812z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 43.75,\n\t      height: 270.052\n\t    },\n\t    origin: {\n\t      x: 0,\n\t      y: 200.365\n\t    },\n\t    align: \"left\"\n\t  },\n\t  DoClef: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M0 98.406V-97.688C0-118 5.99-134.275 17.97-146.516c11.978-12.24 27.603-18.36 46.874-18.36 10.937 0 19.53 3.126 25.78 9.376s9.376 14.583 9.376 25v107.813l-6.25-5.47c-4.167-3.645-10.287-7.42-18.36-11.327-8.072-3.907-16.796-5.86-26.17-5.86-11.46 0-21.486 4.427-30.08 13.282-8.593 8.854-12.89 19.53-12.89 32.03s4.297 23.308 12.89 32.423c8.594 9.115 18.62 13.672 30.08 13.672 9.374 0 18.098-1.822 26.17-5.468 8.073-3.646 14.193-7.292 18.36-10.938l6.25-6.25V132c0 9.896-3.125 18.1-9.375 24.61-6.25 6.51-14.844 9.765-25.78 9.765-19.272 0-34.897-6.25-46.876-18.75C5.99 135.125 0 118.72 0 98.405z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 100,\n\t      height: 331.251\n\t    },\n\t    origin: {\n\t      x: 0,\n\t      y: 164.876\n\t    },\n\t    align: \"left\"\n\t  },\n\t  FaClef: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M85.156-32v193.75c0 9.375-1.562 14.323-4.687 14.844-1.564 0-2.605-.52-3.126-1.563-.52-1.04-.782-2.603-.78-4.686V56.28c-8.335-8.332-19.793-12.5-34.376-12.5-17.71 0-31.77 3.907-42.188 11.72V-32c0-18.23 14.193-27.344 42.578-27.344 28.385 0 42.578 9.115 42.578 27.344zM98.438 93V-92.156c0-19.27 5.73-34.896 17.187-46.875 11.458-11.98 26.562-17.97 45.313-17.97 10.937 0 19.14 2.865 24.61 8.594 5.467 5.73 8.202 13.542 8.202 23.437v103.126l-5.47-4.687c-3.645-3.647-9.374-7.293-17.186-10.94-7.813-3.645-15.886-5.467-24.22-5.468-11.978 0-22.004 4.167-30.077 12.5-8.073 8.334-12.11 18.36-12.11 30.08 0 11.717 4.037 22.004 12.11 30.858s18.1 13.28 30.078 13.28c8.333 0 16.406-1.822 24.22-5.468 7.81-3.645 13.54-7.03 17.186-10.156l5.47-5.468V125.81c0 9.896-2.865 17.84-8.594 23.83-5.73 5.988-13.802 8.983-24.22 8.983-18.75 0-33.853-6.12-45.31-18.36-11.46-12.24-17.19-27.994-17.19-47.265z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 193.752,\n\t      height: 333.595\n\t    },\n\t    origin: {\n\t      x: 0.001,\n\t      y: 157.001\n\t    },\n\t    align: \"left\"\n\t  },\n\t  TrebleClef: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M291 202C95 202 0 70 0-70c0-161 122-276 238-371 9-8 8-9 7-19-6-33-11-85-11-131 0-83 19-183 78-249 16-18 41-38 52-38 9 0 30 22 42 40 32 48 52 116 52 186 0 122-66 224-152 305-5 5-7 5-5 15l20 116c2 14 2 14 23 14 118 0 193 91 193 193 0 91-54 159-135 191-11 4-12 4-10 13 9 50 23 126 23 171 0 136-104 160-157 160-121 0-152-78-152-130 0-50 32-92 85-92 49 0 77 38 77 82 0 46-29 68-54 75-18 5-25 8-25 13 0 11 21 24 64 24 47 0 127-15 127-133 0-38-12-107-22-161-1-10-3-9-12-7-16 3-36 5-55 5ZM64-16c0 111 90 189 230 189 16 0 32-2 45-4 12-3 13-3 11-11L310-81c-1-9-3-9-16-6-48 13-80 48-80 93 0 37 24 72 58 86 6 2 12 5 12 10s-3 9-10 9c-5 0-15-2-21-5-55-18-92-69-92-141 0-68 45-131 116-155 14-5 14-4 12-20l-17-102c-2-9-3-10-11-3-38 30-75 60-123 113C72-126 64-63 64-16Zm312-738c-49 0-106 76-106 201 0 26 1 53 4 74 2 10 5 11 11 6 63-55 139-127 139-216 0-44-22-65-48-65ZM353-94c-10 0-11 2-9 12l39 228c2 9 3 9 13 4 45-22 75-63 75-113 0-71-53-125-118-131Z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 671 * 0.8,\n\t      height: 1756 * 0.8\n\t    },\n\t    origin: {\n\t      x: 0,\n\t      y: 1098 * 0.8\n\t    },\n\t    align: \"left\"\n\t  },\n\t  TrebleClefSmall: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M218 151C71 151 0 52 0-52c0-121 92-207 178-279 7-6 7-7 6-14-5-25-9-64-9-98 0-63 15-138 59-187 12-13 31-29 39-29 7 0 22 17 31 30 25 36 39 88 39 140 0 92-49 168-114 229-3 3-5 4-3 11l15 87c1 11 1 11 17 11 88 0 145 68 145 144 0 68-41 119-101 143-9 4-9 3-8 10 7 38 17 95 17 129 0 102-78 120-118 120-90 0-114-59-114-98 0-37 24-69 64-69 37 0 58 28 58 61 0 35-22 51-40 57-14 4-19 6-19 10 0 8 15 17 48 17 35 0 95-11 95-99 0-29-9-81-16-121-1-7-3-7-9-5-12 2-28 3-42 3ZM48-12c0 83 68 142 173 142 12 0 24-2 33-3 9-2 10-2 9-9L233-61c-1-6-3-7-12-4-37 10-60 36-60 70 0 27 18 53 43 64 4 2 9 4 9 8 0 3-2 6-7 6-4 0-12-1-16-3-41-14-69-52-69-106 0-51 34-99 87-117 10-3 10-3 9-14l-13-77c-1-7-2-7-8-2-29 22-56 45-92 85C54-95 48-47 48-12Zm234-554c-37 0-80 58-80 151 0 20 1 40 4 56 1 7 3 8 8 4 47-41 104-95 104-162 0-33-16-49-36-49ZM265-70c-8-1-8 1-7 8l29 171c2 7 3 7 10 4 34-17 56-48 56-85 0-53-40-94-88-98Z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 671 * 0.6,\n\t      height: 1756 * 0.6\n\t    },\n\t    origin: {\n\t      x: 0,\n\t      y: 1098 * 0.6\n\t    },\n\t    align: \"left\"\n\t  },\n\t  Flat: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M7.813-204.406c4.166 0 6.25 5.208 6.25 15.625L12.5-10.657C33.854 13.302 54.167 25.28 73.438 25.28c9.374 0 14.062-4.686 14.062-14.06 0-6.25-1.042-11.72-3.125-16.407-2.083-4.688-7.03-9.766-14.844-15.235-7.81-5.47-13.02-8.984-15.624-10.547L27.344-45.81V-80.97c17.187 0 33.073 4.82 47.656 14.454C89.583-56.88 96.875-47.376 96.875-38c0 67.708-.26 101.562-.78 101.563-38.543 0-69.532-12.24-92.97-36.72C0-52.322-1.042-123.936 0-188c0-10.937 2.604-16.406 7.813-16.406z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 97.917,\n\t      height: 267.969\n\t    },\n\t    origin: {\n\t      x: 1.042,\n\t      y: 204.406\n\t    },\n\t    align: \"left\"\n\t  },\n\t  Mora: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M47.478-24c6.957 0 12.793 2.288 17.49 6.883C69.662-12.52 72-6.904 72-.267c0 6.64-2.337 12.352-7.033 17.118C60.27 21.618 54.435 24 47.477 24c-6.26 0-11.748-2.383-16.444-7.15C26.337 12.086 24 6.374 24-.265c0-6.638 2.337-12.255 7.033-16.85C35.73-21.713 41.217-24 47.478-24z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 48,\n\t      height: 48\n\t    },\n\t    origin: {\n\t      x: -24,\n\t      y: 24\n\t    },\n\t    align: \"left\"\n\t  },\n\t  Natural: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M7.906-166.563c-2.864 0-5.614.52-8.218 1.563v13.28l.78 56.25.782 78.907v85.157c.52 3.646 2.604 5.73 6.25 6.25l23.438-3.906 23.437-3.907v29.69c0 42.186-.26 63.54-.78 64.06l6.25 2.345c1.04.52 2.082.78 3.124.78 2.603 0 4.947-1.3 7.03-3.905L67.656-71.25c-.52-2.604-2.083-3.906-4.687-3.906-7.814 0-17.19 1.04-28.126 3.125l-19.53 3.124.78-38.28V-165c-2.604-1.042-5.323-1.562-8.188-1.563zM55.938-40v71.875l-41.407 7.03c0-48.436.262-72.655.783-72.655L55.938-40z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 70.311,\n\t      height: 330.469\n\t    },\n\t    origin: {\n\t      x: 0.312,\n\t      y: 166.563\n\t    },\n\t    align: \"left\"\n\t  },\n\t  Sharp: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"m41.725,-73.773c-5.421,-0.241-10.878,5.856-6.549,12.357L67.061,-20.473 61.264,-12.5 13.436,-71.199c-5.634,-5.934-16.988,1.032-11.232,9.783L50.756,0.182 2.203,61.416c-6.745,7.984 3.442,17.859 11.232,9.783L61.264,12.5l5.797,7.973-31.885,40.943c-5.578,6.844 5.588,16.005 11.594,9.783L77.568,33.154 108.367,71.199c4.894,6.717 17.343,-1.575 11.232,-9.783L87.715,20.473 93.873,12.5 141.34,71.199c6.725,7.67 17.509,-2.248 11.596,-9.783L104.02,0.182 152.936,-61.416c5.52,-7.02-5.541,-16.309-11.596,-9.783L93.873,-12.5l-6.158,-7.973 31.884766,-40.943c5.407,-7.045-5.505,-15.924-11.232,-9.783L77.568,-33.154 46.77,-71.199c-1.435,-1.708-3.238,-2.494-5.044922,-2.574zM77.568,-8.516 84.09,0.182 77.568,8.516 70.684,0.182Z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 154.646,\n\t      height: 147.987\n\t    },\n\t    origin: {\n\t      x: 0,\n\t      y: 74.098\n\t    },\n\t    align: \"left\"\n\t  },\n\t  OriscusAsc: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M50 30.25c0 12.5-3.125 21.354-9.375 26.562-3.125 2.605-7.813 3.907-14.063 3.907-3.125 0-5.99-.522-8.593-1.564-2.605-1.04-5.6-2.474-8.986-4.297C5.6 53.035 2.734 51.603.39 50.56c-2.343-1.04-5.338-2.474-8.984-4.296-3.646-1.823-6.77-3.256-9.375-4.297-2.603-1.043-5.468-1.564-8.593-1.564-6.25 0-10.937 1.563-14.062 4.688C-46.875 50.824-50 59.677-50 71.656v-106.25c0-13.02 3.125-21.875 9.375-26.562 3.125-2.604 7.813-3.906 14.063-3.907 3.125 0 5.99.52 8.593 1.563 2.605 1.042 5.73 2.474 9.376 4.297 3.646 1.823 6.51 2.995 8.594 3.516l10.938 5.468c6.25 3.126 11.458 4.69 15.624 4.69 6.25 0 10.938-1.564 14.063-4.69C46.875-55.426 50-64.02 50-76V30.25z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 100,\n\t      height: 147.656\n\t    },\n\t    origin: {\n\t      x: 50,\n\t      y: 76\n\t    },\n\t    align: \"left\"\n\t  },\n\t  OriscusDes: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M-50 30.844v-106.25c0 11.458 3.125 20.052 9.375 25.78 3.125 3.126 7.813 4.69 14.063 4.688 4.687 0 13.41-3.255 26.17-9.765 12.762-6.51 21.746-9.766 26.954-9.766 6.25 0 10.938 1.303 14.063 3.907C46.875-55.874 50-47.02 50-34V72.25c0-11.98-3.125-20.833-9.375-26.563C37.5 42.563 32.812 41 26.562 41 21.875 41 13.023 44.385 0 51.156c-4.167 2.604-8.594 4.948-13.28 7.032-4.69 2.083-9.116 3.124-13.283 3.124-6.25 0-10.937-1.302-14.062-3.906C-46.875 52.198-50 43.344-50 30.844z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 100,\n\t      height: 147.656\n\t    },\n\t    origin: {\n\t      x: 50,\n\t      y: 75.406\n\t    },\n\t    align: \"left\"\n\t  },\n\t  OriscusLiquescent: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M 19.055,78.887 C 20.242,78.487 21.532,77.890 22.925,77.097 24.318,76.304 26.700882,74.417 30.074,71.438 33.447,68.458 36.524,64.985 39.303,61.019 42.083,57.052 44.563,51.396 46.743,44.05 48.923,36.704 50.013,28.671 50.013,19.950525 L 50.013,-34.226 C 50.013,-54.464 42.074,-64.584 26.195,-64.584 20.248,-64.584 11.519,-61.410 0.007,-55.064 -11.506,-48.717 -20.235,-45.544 -26.182,-45.544 -34.515,-45.544 -40.568,-48.520 -44.340791,-54.473 -48.114,-60.426 -50.000,-67.369 -50.000,-75.303 L -50.000,30.07 C -50.000,49.909 -42.060754,59.829 -26.182,59.829 -21.023,59.829 -12.39,56.455 -0.284,49.709 11.822,42.963 20.648,39.59 26.195,39.59 29.369,40.777 30.362,44.25 29.17479,50.009 27.988,55.768 26.001,62.020829 23.216,68.767 z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 100,\n\t      height: 147.656\n\t    },\n\t    origin: {\n\t      x: 50,\n\t      y: 75.406\n\t    },\n\t    align: \"left\"\n\t  },\n\t  PodatusLower: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M-4.688-30.28c22.396 0 34.636-.262 36.72-.782 5.728-1.563 8.593-5.21 8.593-10.938H50v97.656c0 2.604-1.302 4.167-3.906 4.688-5.21.52-21.355.78-48.438.78-23.958 0-38.54-.26-43.75-.78-2.604 0-3.906-1.302-3.906-3.906v-82.032c0-3.646 1.302-5.468 3.906-5.468h2.344c2.604.52 15.625.78 39.063.78z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 100,\n\t      height: 103.124\n\t    },\n\t    origin: {\n\t      x: 50,\n\t      y: 42\n\t    },\n\t    align: \"left\"\n\t  },\n\t  PodatusUpper: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M-46.094-63.78c13.542 0 24.61 2.473 33.203 7.42C-4.298-51.41 0-43.99 0-34.093V62h-9.375c0-10.938-2.604-19.14-7.812-24.61-5.21-5.468-14.844-8.203-28.907-8.202-18.23 0-33.333 4.166-45.312 12.5v-75.782c0-19.79 15.104-29.687 45.312-29.687z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 91.406,\n\t      height: 125.781\n\t    },\n\t    origin: {\n\t      x: 91.406,\n\t      y: 63.781\n\t    },\n\t    align: \"right\"\n\t  },\n\t  Porrectus1: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M233.594 162.875c-58.855 0-107.032-6.25-144.53-18.75C34.895 125.895-11.46 99.855-50 66V-52.75C-21.354-24.625 26.302 6.885 92.97 41.78 123.697 57.928 163.54 66 212.5 66c21.354 0 34.635-9.896 39.844-29.688V151.94c0 7.29-6.25 10.937-18.75 10.937z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 302.344,\n\t      height: 215.627\n\t    },\n\t    origin: {\n\t      x: 50,\n\t      y: 52.75\n\t    },\n\t    align: \"left\"\n\t  },\n\t  Porrectus2: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M309.375 259.375c-50.52 0-110.938-22.396-181.25-67.188C48.437 141.667-10.938 94.272-50 50V-68.75C0-3.125 60.417 52.083 131.25 96.875c58.333 36.98 110.677 58.854 157.03 65.625h7.033c16.145 0 26.822-9.896 32.03-29.688v114.844c0 7.812-5.99 11.72-17.968 11.72z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 377.343,\n\t      height: 328.126\n\t    },\n\t    origin: {\n\t      x: 50,\n\t      y: 68.75\n\t    },\n\t    align: \"left\"\n\t  },\n\t  Porrectus3: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M309.375 355.78c-48.96-16.666-109.115-55.468-180.47-116.405C79.428 198.23 19.793 134.687-50 48.75V-70C20 40 94.104 103.79 135.25 148.063 190 200 230 230 288.28 258.906c4.168 2.083 8.334 3.125 12.5 3.125 12.5 0 21.355-10.937 26.564-32.81v114.06c0 9.376-3.386 14.063-10.156 14.064-2.084 0-4.688-.522-7.813-1.563z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 377.344,\n\t      height: 427.345\n\t    },\n\t    origin: {\n\t      x: 50,\n\t      y: 70\n\t    },\n\t    align: \"left\"\n\t  },\n\t  Porrectus4: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M350 453.438c-52.754-22.397-120-77.345-201.74-164.844C90.87 227.656 24.784 147.708-50 48.75V-70C-8.84-1.25 58.406 86.51 151.74 193.28c60.868 69.793 119.13 124.22 174.782 163.282 5.797 3.646 11.014 5.47 15.652 5.47 12.173 0 21.45-11.72 27.826-35.157V441.72c0 9.373-3.19 14.06-9.565 14.06-2.9 0-6.377-.78-10.435-2.342z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 420,\n\t      height: 525.78\n\t    },\n\t    origin: {\n\t      x: 50,\n\t      y: 70\n\t    },\n\t    align: \"left\"\n\t  },\n\t  PunctumCavum: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M0-60.906c33.333 0 50 9.635 50 28.906v94.53C39.062 51.595 22.396 46.126 0 46.126s-39.063 5.47-50 16.406V-32c0-19.27 16.667-28.906 50-28.906z\"\n\t    }, {\n\t      type: \"negative\",\n\t      data: \"M.08-42.56c9.585.206 20.126.53 27.954 6.822 4.96 3.9 4.71 10.792 4.574 16.482v51.278C22.09 27.066 7.283 26.072.168 26.01c-7.72.23-21.895.935-32.616 4.674.04-19.197-.083-38.395.064-57.59.567-7.5 7.834-12.33 14.62-13.774 5.818-1.498 11.857-1.86 17.844-1.88z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 100,\n\t      height: 123.438\n\t    },\n\t    origin: {\n\t      x: 50,\n\t      y: 60.906\n\t    },\n\t    align: \"left\"\n\t  },\n\t  PunctumQuadratum: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M0-60.906c33.333 0 50 9.635 50 28.906v94.53C39.062 51.595 22.396 46.126 0 46.126s-39.063 5.47-50 16.406V-32c0-19.27 16.667-28.906 50-28.906z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 100,\n\t      height: 123.438\n\t    },\n\t    origin: {\n\t      x: 50,\n\t      y: 60.906\n\t    },\n\t    align: \"left\"\n\t  },\n\t  PunctumQuadratumLiquescent: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M0-36.5436c19.999799999999997 0 30 5.781 30 17.3436v56.717999999999996C23.437199999999997 30.956999999999997 13.4376 27.6756 0 27.6756s-23.4378 3.2819999999999996-30 9.843599999999999V-19.2c0-11.562 10.000200000000001-17.3436 30-17.3436z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 100,\n\t      height: 123.438\n\t    },\n\t    origin: {\n\t      x: 50,\n\t      y: 60.906\n\t    },\n\t    align: \"left\"\n\t  },\n\t  PunctumQuadratumAscLiquescent: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M-50 43.688V-61c4.167 7.292 12.76 10.938 25.78 10.938 9.376 0 20.053-1.563 32.032-4.688C31.773-60.48 45.833-71.677 50-88.344v117.97C43.75 42.645 32.812 51.5 17.187 56.186-.52 61.398-15.886 64-28.906 64-42.97 64-50 57.23-50 43.687z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 100,\n\t      height: 152.344\n\t    },\n\t    origin: {\n\t      x: 50,\n\t      y: 88.344\n\t    },\n\t    align: \"left\"\n\t  },\n\t  PunctumQuadratumDesLiquescent: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M-50-56.03c0-13.022 7.03-19.532 21.094-19.532 13.02 0 28.385 2.604 46.093 7.812C32.813-63.583 43.75-54.73 50-41.187V76C45.833 59.854 31.77 48.656 7.812 42.406c-11.98-3.125-22.656-4.687-32.03-4.687-13.022 0-21.615 3.905-25.782 11.718v-105.47z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 100,\n\t      height: 151.562\n\t    },\n\t    origin: {\n\t      x: 50,\n\t      y: 75.562\n\t    },\n\t    align: \"left\"\n\t  },\n\t  PunctumInclinatum: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M0-75.78L50 0 0 75-50 0 0-75.78z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 100,\n\t      height: 150.78\n\t    },\n\t    origin: {\n\t      x: 50,\n\t      y: 75.78\n\t    },\n\t    align: \"left\"\n\t  },\n\t  PunctumInclinatumLiquescent: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M 0,-53.164 35,-0.117 0,52.383 -35,-0.117 0,-53.164 z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 100,\n\t      height: 105.546\n\t    },\n\t    origin: {\n\t      x: 50,\n\t      y: 53.164\n\t    },\n\t    align: \"left\"\n\t  },\n\t  Quilisma: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M-50 34.938V-51c5.73 20.833 13.02 31.25 21.875 31.25 7.813 0 12.5-15.625 14.063-46.875 3.645 12.5 6.9 21.224 9.765 26.172s6.9 7.422 12.11 7.422c5.208 0 9.374-14.324 12.5-42.97 5.73 22.917 10.677 34.375 14.843 34.375 5.73 0 10.677-15.885 14.844-47.656v100c0 17.707-3.125 26.56-9.375 26.56-4.688 0-9.115-5.988-13.28-17.968-2.085 21.875-8.074 32.813-17.97 32.813-7.813 0-16.146-7.292-25-21.875-4.688 20.312-10.677 30.47-17.97 30.47-5.207 0-9.244-2.605-12.108-7.814C-48.568 47.698-50 41.708-50 34.938z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 100,\n\t      height: 150\n\t    },\n\t    origin: {\n\t      x: 50,\n\t      y: 89.282\n\t    },\n\t    align: \"left\"\n\t  },\n\t  TerminatingAscLiquescent: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M-9.375 40.22c0-11.98-4.948-17.97-14.844-17.97-10.936 0-19.53 3.646-25.78 10.938v-53.126c0-6.77 2.604-12.76 7.813-17.968 5.208-5.21 10.677-8.594 16.406-10.157 2.603-.52 5.207-.78 7.81-.78 3.647 0 7.032.78 10.157 2.343C-2.603-43.896 0-39.73 0-34V73.03h-9.375V40.22z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 49.999,\n\t      height: 121.873\n\t    },\n\t    origin: {\n\t      x: 49.999,\n\t      y: 48.843\n\t    },\n\t    align: \"right\"\n\t  },\n\t  TerminatingDesLiquescent: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M-9.375-48.156V-80.97H0V26.845c0 5.73-2.604 9.896-7.813 12.5-3.125 1.562-6.51 2.343-10.156 2.343-2.603 0-5.207-.26-7.81-.78-5.73-1.563-11.2-4.95-16.407-10.157C-47.398 25.542-50 19.292-50 12v-52.344c6.25 7.292 14.844 10.938 25.78 10.938 9.897 0 14.845-6.25 14.845-18.75z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 50,\n\t      height: 122.658\n\t    },\n\t    origin: {\n\t      x: 50,\n\t      y: 80.97\n\t    },\n\t    align: \"right\"\n\t  },\n\t  VerticalEpisemaAbove: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M-8-4c2 3 6 4 8 4s6-1 8-4v-52c-2-3-6-4-8-4s-6 1-8 4z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 16,\n\t      height: 60\n\t    },\n\t    origin: {\n\t      x: 8,\n\t      y: 60\n\t    },\n\t    align: \"left\"\n\t  },\n\t  VerticalEpisemaBelow: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M-8 56c2 3 6 4 8 4s6-1 8-4v-52c-2-3-6-4-8-4s-6 1-8 4z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 16,\n\t      height: 60\n\t    },\n\t    origin: {\n\t      x: 8,\n\t      y: 0\n\t    },\n\t    align: \"left\"\n\t  },\n\t  VirgaLong: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M50-38v285.156c0 6.77-2.344 10.937-7.03 12.5-1.564 0-2.605-.78-3.126-2.344-.52-1.562-.782-10.156-.782-25.78V54.186C29.168 45.334 16.146 40.907 0 40.907c-22.917 0-39.583 5.208-50 15.624V-38c0-19.27 16.667-28.906 50-28.906S50-57.27 50-38z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 100,\n\t      height: 326.562\n\t    },\n\t    origin: {\n\t      x: 50,\n\t      y: 66.906\n\t    },\n\t    align: \"left\"\n\t  },\n\t  VirgaShort: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M50-38v211.72c0 7.29-2.344 11.457-7.03 12.5-1.564 0-2.606-.783-3.126-2.345-.52-1.563-.782-10.156-.782-25.78V54.187C29.167 45.332 16.146 40.906 0 40.906c-22.917 0-39.583 5.21-50 15.625V-38c0-19.27 16.667-28.906 50-28.906S50-57.27 50-38z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 100,\n\t      height: 253.126\n\t    },\n\t    origin: {\n\t      x: 50,\n\t      y: 66.906\n\t    },\n\t    align: \"left\"\n\t  },\n\t  Virgula: {\n\t    paths: [{\n\t      type: \"positive\",\n\t      data: \"M8.178-55.66c0-22.137 12.092-33.2 36.287-33.2 11.835 0 23.53 5.66 35.108 16.98C91.15-60.547 96.94-41.766 96.94-15.534c0 53.515-31.646 87.487-94.937 101.895-2.048-2.06-3.077-5.146-3.077-9.273 0-1.03.247-1.8.76-2.316 42.71-19.027 64.075-41.678 64.075-67.92 0-11.322-2.325-20.326-6.945-27.016-4.62-6.69-9.52-11.052-14.676-13.11-5.147-2.048-11.836-3.85-20.07-5.403C12.81-39.707 8.18-45.37 8.18-55.66z\"\n\t    }],\n\t    bounds: {\n\t      x: 0,\n\t      y: 0,\n\t      width: 98.014,\n\t      height: 175.221\n\t    },\n\t    origin: {\n\t      x: 1.074 - 98.014 / 2, // centered\n\t      y: 88.86\n\t    },\n\t    align: \"left\"\n\t  }\n\t};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.ChantNotationElement = exports.Annotations = exports.Annotation = exports.TextLeftRight = exports.Subtitle = exports.Title = exports.Supertitle = exports.TitleTextElement = exports.DropCap = exports.TranslationText = exports.AboveLinesText = exports.ChoralSign = exports.Lyric = exports.LyricArray = exports.LyricType = exports.TextElement = exports.TextSpan = exports.CurlyBraceVisualizer = exports.RoundBraceVisualizer = exports.GlyphVisualizer = exports.LineaVisualizer = exports.VirgaLineVisualizer = exports.NeumeLineVisualizer = exports.DividerLineVisualizer = exports.ChantLayoutElement = exports.ChantContext = exports.TextMeasuringStrategy = exports.QuickSvg = exports.GlyphCode = exports.DefaultTrailingSpace = exports.TextTypesByClass = exports.TextTypes = exports.MarkingPositionHint = undefined;\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); //\n\t// Author(s):\n\t// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>\n\t//\n\t// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a copy\n\t// of this software and associated documentation files (the \"Software\"), to deal\n\t// in the Software without restriction, including without limitation the rights\n\t// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\t// copies of the Software, and to permit persons to whom the Software is\n\t// furnished to do so, subject to the following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included in\n\t// all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\t// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\t// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\t// THE SOFTWARE.\n\t//\n\t\n\tvar _ExsurgeCore = __webpack_require__(1);\n\t\n\tvar _ExsurgeGlyphs = __webpack_require__(3);\n\t\n\tvar _ExsurgeText = __webpack_require__(2);\n\t\n\tvar _addAccent = __webpack_require__(5);\n\t\n\tvar _makeLigature = __webpack_require__(6);\n\t\n\tvar _greextraGlyphs = __webpack_require__(7);\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction getFontFilenameForProperties() {\n\t  var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t  var url = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"{}\";\n\t\n\t  var italic = properties[\"font-style\"] === \"italic\" ? \"Italic\" : \"\",\n\t      bold = properties[\"font-weight\"] === \"bold\" ? \"Bold\" : \"\";\n\t  return url.replace(\"{}\", \"\" + (italic || bold ? \"\" + bold + italic : \"Regular\"));\n\t}\n\t\n\t// load in the web font for special chant characters here:\n\t// var __exsurgeCharactersFont = require(\"url?limit=30000!../assets/fonts/ExsurgeChar.otf\")\n\t\n\tvar canAccessDOM = typeof document !== \"undefined\";\n\t\n\tvar __getNeumeFromSvgElem = function __getNeumeFromSvgElem(score, elem) {\n\t  var note = score.notes[elem.parentElement.querySelector(\"[element-index]\").getAttribute(\"element-index\")];\n\t  return note.neume || note;\n\t};\n\t\n\t// for positioning markings on notes\n\tvar MarkingPositionHint = exports.MarkingPositionHint = {\n\t  Default: 0,\n\t  Above: 1,\n\t  Below: 2\n\t};\n\t\n\t/**\n\t * List of types of text and their defaults relative to lyrics\n\t * @type Array\n\t */\n\tvar TextTypes = exports.TextTypes = {\n\t  supertitle: {\n\t    display: \"Supertitle\",\n\t    defaultSize: function defaultSize(size) {\n\t      return size * 7 / 6;\n\t    }, // 14pt\n\t    containedInScore: function containedInScore(score) {\n\t      return score.titles.hasSupertitle();\n\t    },\n\t    getFromScore: function getFromScore(score) {\n\t      return score.titles.supertitle;\n\t    }\n\t  },\n\t  title: {\n\t    display: \"Title\",\n\t    defaultSize: function defaultSize(size) {\n\t      return size * 3 / 2;\n\t    }, // 18pt\n\t    containedInScore: function containedInScore(score) {\n\t      return score.titles.hasTitle();\n\t    },\n\t    getFromScore: function getFromScore(score) {\n\t      return score.titles.title;\n\t    }\n\t  },\n\t  subtitle: {\n\t    display: \"Subtitle\",\n\t    defaultSize: function defaultSize(size) {\n\t      return size;\n\t    }, // 12pt\n\t    containedInScore: function containedInScore(score) {\n\t      return score.titles.hasSubtitle();\n\t    },\n\t    getFromScore: function getFromScore(score) {\n\t      return score.titles.subtitle;\n\t    }\n\t  },\n\t  leftRight: {\n\t    display: \"Left / Right Text\",\n\t    cssClass: \"textLeftRight\",\n\t    defaultSize: function defaultSize(size) {\n\t      return size * 0.9;\n\t    },\n\t    containedInScore: function containedInScore(score) {\n\t      return score.titles.hasTextLeft() || score.titles.hasTextRight();\n\t    },\n\t    getFromScore: function getFromScore(score, elem) {\n\t      return score.titles[elem.extraClass];\n\t    },\n\t    getFromSvgElem: function getFromSvgElem(score, elem) {\n\t      return score.titles[elem.classList.contains(\"textRight\") ? \"textRight\" : \"textLeft\"];\n\t    }\n\t  },\n\t  annotation: {\n\t    display: \"Annotation\",\n\t    defaultSize: function defaultSize(size) {\n\t      return size * 2 / 3;\n\t    },\n\t    containedInScore: function containedInScore(score) {\n\t      return !!score.annotation;\n\t    },\n\t    getFromScore: function getFromScore(score, _ref) {\n\t      var _ref$elementIndex = _ref.elementIndex,\n\t          elementIndex = _ref$elementIndex === undefined ? 0 : _ref$elementIndex;\n\t      return score.annotation && (score.annotation.annotations ? score.annotation.annotations[elementIndex] : score.annotation);\n\t    },\n\t    getFromSvgElem: function getFromSvgElem(score, elem) {\n\t      return score.annotation && (score.annotation.annotations ? score.annotation.annotations[Array.from(elem.parentElement.querySelectorAll(\"text.annotation\")).indexOf(elem)] : score.annotation);\n\t    }\n\t  },\n\t  dropCap: {\n\t    display: \"Drop Cap\",\n\t    defaultSize: function defaultSize(size) {\n\t      return size * 4;\n\t    },\n\t    containedInScore: function containedInScore(score) {\n\t      return !!score.dropCap;\n\t    },\n\t    getFromScore: function getFromScore(score) {\n\t      return score.dropCap;\n\t    }\n\t  },\n\t  al: {\n\t    display: \"Above Staff\",\n\t    cssClass: \"aboveLinesText\",\n\t    defaultSize: function defaultSize(size) {\n\t      return size;\n\t    },\n\t    containedInScore: function containedInScore(score) {\n\t      return score.hasAboveLinesText;\n\t    },\n\t    getFromScore: function getFromScore(score, elem) {\n\t      return score.notations[elem.notation.notationIndex].alText[elem.alIndex];\n\t    },\n\t    getFromSvgElem: function getFromSvgElem(score, elem) {\n\t      return __getNeumeFromSvgElem(score, elem).alText[elem.getAttribute(\"al-index\") || 0];\n\t    }\n\t  },\n\t  choralSign: {\n\t    display: \"Choral Sign\",\n\t    size: function size(ctxt) {\n\t      return ctxt.staffInterval * 1.5;\n\t    },\n\t    containedInScore: function containedInScore(score) {\n\t      return false;\n\t    },\n\t    getFromScore: function getFromScore(score, elem) {\n\t      return score.notes[elem.note.elementIndex].choralSign;\n\t    }\n\t  },\n\t  lyric: {\n\t    display: \"Lyric\",\n\t    defaultSize: function defaultSize(size) {\n\t      return size * 0.9;\n\t    },\n\t    containedInScore: function containedInScore(score) {\n\t      return score.hasLyrics;\n\t    },\n\t    getFromScore: function getFromScore(score, elem) {\n\t      return score.notations[elem.notation.notationIndex].lyrics[elem.lyricIndex];\n\t    },\n\t    getFromSvgElem: function getFromSvgElem(score, elem) {\n\t      return __getNeumeFromSvgElem(score, elem).lyrics[elem.getAttribute(\"lyric-index\") || 0];\n\t    }\n\t  },\n\t  translation: {\n\t    display: \"Translation\",\n\t    defaultSize: function defaultSize(size) {\n\t      return size * 0.75;\n\t    },\n\t    containedInScore: function containedInScore(score) {\n\t      return score.hasTranslations;\n\t    },\n\t    getFromScore: function getFromScore(score, elem) {\n\t      return score.notations[elem.notation.notationIndex].translationText[elem.translationIndex];\n\t    },\n\t    getFromSvgElem: function getFromSvgElem(score, elem) {\n\t      return __getNeumeFromSvgElem(score, elem).translationText[elem.getAttribute(\"translation-index\") || 0];\n\t    }\n\t  }\n\t};\n\tvar TextTypesByClass = exports.TextTypesByClass = {};\n\tObject.entries(TextTypes).forEach(function (_ref2) {\n\t  var _ref3 = _slicedToArray(_ref2, 2),\n\t      key = _ref3[0],\n\t      entry = _ref3[1];\n\t\n\t  var cssClass = entry.cssClass = entry.cssClass || key;\n\t  entry.key = key;\n\t  TextTypesByClass[cssClass] = entry;\n\t});\n\t\n\tvar DefaultTrailingSpace = exports.DefaultTrailingSpace = function DefaultTrailingSpace(ctxt) {\n\t  return ctxt.intraNeumeSpacing * ctxt.interSyllabicMultiplier;\n\t};\n\tDefaultTrailingSpace.isDefault = true;\n\t\n\tvar GlyphCode = exports.GlyphCode = {\n\t  None: \"None\",\n\t\n\t  AcuteAccent: \"AcuteAccent\",\n\t  GraveAccent: \"GraveAccent\",\n\t  Circle: \"Circle\",\n\t  Semicircle: \"Semicircle\",\n\t  ReversedSemicircle: \"ReversedSemicircle\",\n\t  Stropha: \"Stropha\",\n\t  StrophaLiquescent: \"StrophaLiquescent\",\n\t\n\t  BeginningAscLiquescent: \"BeginningAscLiquescent\",\n\t  BeginningDesLiquescent: \"BeginningDesLiquescent\",\n\t\n\t  CustosDescLong: \"CustosDescLong\",\n\t  CustosDescShort: \"CustosDescShort\",\n\t  CustosLong: \"CustosLong\",\n\t  CustosShort: \"CustosShort\",\n\t\n\t  // clefs and other markings\n\t  DoClef: \"DoClef\",\n\t  FaClef: \"FaClef\",\n\t  TrebleClef: \"TrebleClef\",\n\t  TrebleClefSmall: \"TrebleClefSmall\",\n\t  Flat: \"Flat\",\n\t  Mora: \"Mora\",\n\t  Natural: \"Natural\",\n\t  OriscusAsc: \"OriscusAsc\",\n\t  OriscusDes: \"OriscusDes\",\n\t  OriscusLiquescent: \"OriscusLiquescent\",\n\t\n\t  PodatusLower: \"PodatusLower\",\n\t  PodatusUpper: \"PodatusUpper\",\n\t\n\t  Porrectus1: \"Porrectus1\", // 1 staff line difference,\n\t  Porrectus2: \"Porrectus2\", // 2 lines difference, etc...\n\t  Porrectus3: \"Porrectus3\",\n\t  Porrectus4: \"Porrectus4\",\n\t\n\t  PunctumCavum: \"PunctumCavum\",\n\t  PunctumQuadratum: \"PunctumQuadratum\",\n\t  PunctumQuadratumLiquescent: \"PunctumQuadratumLiquescent\",\n\t  PunctumQuadratumAscLiquescent: \"PunctumQuadratumAscLiquescent\",\n\t  PunctumQuadratumDesLiquescent: \"PunctumQuadratumDesLiquescent\",\n\t  PunctumInclinatum: \"PunctumInclinatum\",\n\t  PunctumInclinatumLiquescent: \"PunctumInclinatumLiquescent\",\n\t  Quilisma: \"Quilisma\",\n\t\n\t  Sharp: \"Sharp\",\n\t  TerminatingAscLiquescent: \"TerminatingAscLiquescent\",\n\t  TerminatingDesLiquescent: \"TerminatingDesLiquescent\",\n\t  VerticalEpisemaAbove: \"VerticalEpisemaAbove\",\n\t  VerticalEpisemaBelow: \"VerticalEpisemaBelow\",\n\t  VirgaLong: \"VirgaLong\",\n\t  VirgaShort: \"VirgaShort\",\n\t  Virgula: \"Virgula\",\n\t\n\t  UpperBrace: \"UpperBrace\"\n\t}; // GlyphCode\n\t\n\tvar QuickSvg = exports.QuickSvg = {\n\t  // namespaces\n\t  ns: \"http://www.w3.org/2000/svg\",\n\t  xmlns: \"https://www.w3.org/2000/xmlns/\",\n\t  xlink: \"http://www.w3.org/1999/xlink\",\n\t\n\t  hasDOMAccess: function hasDOMAccess() {\n\t    return canAccessDOM;\n\t  },\n\t\n\t  // create the root level svg object\n\t  svg: function svg(width, height) {\n\t    var node = document.createElementNS(this.ns, \"svg\");\n\t\n\t    node.setAttribute(\"xmlns\", this.ns);\n\t    node.setAttribute(\"version\", \"1.1\");\n\t    node.setAttributeNS(this.xmlns, \"xmlns:xlink\", this.xlink);\n\t\n\t    node.setAttribute(\"width\", width);\n\t    node.setAttribute(\"height\", height);\n\t\n\t    // create the defs element\n\t    var defs = document.createElementNS(this.ns, \"defs\");\n\t    node.appendChild(defs);\n\t\n\t    node.defs = defs;\n\t\n\t    node.clearNotations = function () {\n\t      // clear out all children except defs\n\t      node.removeChild(defs);\n\t\n\t      while (node.hasChildNodes()) {\n\t        node.removeChild(node.lastChild);\n\t      }node.appendChild(defs);\n\t    };\n\t\n\t    return node;\n\t  },\n\t\n\t  rect: function rect(width, height) {\n\t    var node = document.createElementNS(this.ns, \"rect\");\n\t\n\t    node.setAttribute(\"width\", width);\n\t    node.setAttribute(\"height\", height);\n\t\n\t    return node;\n\t  },\n\t\n\t  line: function line(x1, y1, x2, y2) {\n\t    var node = document.createElementNS(this.ns, \"line\");\n\t\n\t    node.setAttribute(\"x1\", x1);\n\t    node.setAttribute(\"y1\", y1);\n\t    node.setAttribute(\"x2\", x2);\n\t    node.setAttribute(\"y2\", y2);\n\t\n\t    return node;\n\t  },\n\t\n\t  g: function g() {\n\t    var node = document.createElementNS(this.ns, \"g\");\n\t\n\t    return node;\n\t  },\n\t\n\t  text: function text() {\n\t    var node = document.createElementNS(this.ns, \"text\");\n\t\n\t    return node;\n\t  },\n\t\n\t  tspan: function tspan(str) {\n\t    var node = document.createElementNS(this.ns, \"tspan\");\n\t    node.textContent = str;\n\t\n\t    return node;\n\t  },\n\t\n\t  // nodeRef should be the id of the object in defs (without the #)\n\t  use: function use(nodeRef) {\n\t    var node = document.createElementNS(this.ns, \"use\");\n\t    node.setAttributeNS(this.xlink, \"xlink:href\", \"#\" + nodeRef);\n\t\n\t    return node;\n\t  },\n\t\n\t  svgFragmentForGlyph: function svgFragmentForGlyph(glyph) {\n\t    var fillColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"#000\";\n\t\n\t    var svgSrc = \"\";\n\t    for (var i = 0; i < glyph.paths.length; ++i) {\n\t      var path = glyph.paths[i];\n\t      svgSrc += QuickSvg.createFragment(path.data ? \"path\" : \"g\", {\n\t        d: path.data || undefined,\n\t        fill: path.type === \"negative\" ? \"#fff\" : fillColor\n\t      });\n\t    }\n\t    return svgSrc;\n\t  },\n\t\n\t  nodesForGlyph: function nodesForGlyph(glyph) {\n\t    var functionName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"createNode\";\n\t    var fillColor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"#000\";\n\t\n\t    var nodes = [];\n\t    for (var i = 0; i < glyph.paths.length; ++i) {\n\t      var path = glyph.paths[i];\n\t      var props = {};\n\t      if (path.data) props.d = path.data;\n\t      //if (path.type === \"negative\") props.fill = \"#fff\";\n\t      props.fill = path.type === \"negative\" ? \"#fff\" : fillColor;\n\t      nodes.push(QuickSvg[functionName](path.data ? \"path\" : \"g\", props));\n\t    }\n\t    return nodes;\n\t  },\n\t\n\t  createNode: function createNode(name, attributes, children) {\n\t    var node = document.createElementNS(this.ns, name);\n\t    if (attributes && attributes.source) {\n\t      node.source = attributes.source;\n\t      delete attributes.source;\n\t    }\n\t    for (var attr in attributes) {\n\t      if (attributes.hasOwnProperty(attr) && typeof attributes[attr] !== \"undefined\") {\n\t        var val = attributes[attr];\n\t        var match = attr.match(/^([^:]+):([^:]+)$/);\n\t        if (match) {\n\t          node.setAttributeNS(this[match[1]], match[2], val);\n\t        } else {\n\t          node.setAttribute(attr, val);\n\t        }\n\t      }\n\t    }\n\t    if (children) {\n\t      if (typeof children === \"string\") {\n\t        node.textContent = children;\n\t      } else if (children.constructor === [].constructor) {\n\t        for (var i = 0; i < children.length; ++i) {\n\t          node.appendChild(children[i]);\n\t        }\n\t      } else {\n\t        node.appendChild(children);\n\t      }\n\t    }\n\t    return node;\n\t  },\n\t\n\t  createSvgTree: function createSvgTree(name, props) {\n\t    for (var _len = arguments.length, children = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n\t      children[_key - 2] = arguments[_key];\n\t    }\n\t\n\t    if (\"class\" in props) {\n\t      props.className = props.class;\n\t      delete props.class;\n\t    }\n\t    if (children.length === 1 && children[0] instanceof Array) {\n\t      children = children[0];\n\t    }\n\t    var convertKeysToCamelCase = function convertKeysToCamelCase(obj) {\n\t      var _iteratorNormalCompletion = true;\n\t      var _didIteratorError = false;\n\t      var _iteratorError = undefined;\n\t\n\t      try {\n\t        for (var _iterator = Object.keys(obj)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t          var key = _step.value;\n\t\n\t          if (/[-:][a-z]/.test(key)) {\n\t            if (/^\\w+-index$/.test(key)) continue;\n\t            var camelCase = key.replace(/[-:]([a-z])/g, function (whole, letter) {\n\t              return letter.toUpperCase();\n\t            });\n\t            obj[camelCase] = obj[key];\n\t            delete obj[key];\n\t          }\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError = true;\n\t        _iteratorError = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion && _iterator.return) {\n\t            _iterator.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError) {\n\t            throw _iteratorError;\n\t          }\n\t        }\n\t      }\n\t    };\n\t    convertKeysToCamelCase(props);\n\t    if (props.style) convertKeysToCamelCase(props.style);\n\t    var source = props.source;\n\t    if (source && source.sourceGabc) {\n\t      props[\"source-gabc\"] = source.sourceGabc;\n\t    }\n\t    return { name: name, props: props, children: children };\n\t  },\n\t\n\t\n\t  createFragment: function createFragment(name, attributes, child) {\n\t    if (child === undefined || child === null) child = \"\";\n\t\n\t    var fragment = \"<\" + name + \" \";\n\t\n\t    for (var attr in attributes) {\n\t      if (attributes.hasOwnProperty(attr) && typeof attributes[attr] !== \"undefined\") fragment += attr + '=\"' + attributes[attr] + '\" ';\n\t    }\n\t\n\t    fragment += \">\" + child + \"</\" + name + \">\";\n\t\n\t    return fragment;\n\t  },\n\t\n\t  parseFragment: function parseFragment(fragment) {\n\t    // create temporary holder\n\t    var well = document.createElement(\"svg\");\n\t\n\t    // act as a setter if svg is given\n\t    if (fragment) {\n\t      var container = this.g();\n\t\n\t      // dump raw svg\n\t      // do this to allow the browser to automatically create svg nodes?\n\t      well.innerHTML = \"<svg>\" + fragment.replace(/\\n/, \"\").replace(/<(\\w+)([^<]+?)\\/>/g, \"<$1$2></$1>\") + \"</svg>\";\n\t\n\t      // transplant nodes\n\t      for (var i = 0, il = well.firstChild.childNodes.length; i < il; i++) {\n\t        container.appendChild(well.firstChild.firstChild);\n\t      }return container;\n\t    }\n\t  },\n\t\n\t  translate: function translate(node, x, y) {\n\t    node.setAttribute(\"transform\", \"translate(\" + x + \",\" + y + \")\");\n\t    return node;\n\t  },\n\t\n\t  scale: function scale(node, sx, sy) {\n\t    node.setAttribute(\"transform\", \"scale(\" + sx + \",\" + sy + \")\");\n\t    return node;\n\t  }\n\t};\n\t\n\tvar TextMeasuringStrategy = exports.TextMeasuringStrategy = {\n\t  // shapes\n\t  Svg: 0,\n\t  Canvas: 1,\n\t  OpenTypeJS: 2\n\t};\n\t\n\t/*\n\t * ChantContext\n\t */\n\t\n\tvar ChantContext = exports.ChantContext = function () {\n\t  function ChantContext() {\n\t    var _this = this;\n\t\n\t    var textMeasuringStrategy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : QuickSvg.hasDOMAccess() ? TextMeasuringStrategy.Canvas : TextMeasuringStrategy.OpenTypeJS;\n\t\n\t    _classCallCheck(this, ChantContext);\n\t\n\t    /**\n\t     * font dictionary\n\t     * @type {{ [key: string]: import('opentype.js').Font }}\n\t     */\n\t    this.fontDictionary = undefined;\n\t    this.staffLineCount = 4;\n\t    this.textMeasuringStrategy = textMeasuringStrategy;\n\t    this.getFontFilenameForProperties = getFontFilenameForProperties;\n\t    this.defs = {};\n\t    this.makeDefs = [];\n\t    if (QuickSvg.hasDOMAccess()) {\n\t      this.defsNode = QuickSvg.createNode(\"defs\");\n\t    }\n\t\n\t    // font styles\n\t    this.textStyles = {};\n\t    this.textColor = \"#0d0\";\n\t    this.setFont(\"'Palatino Linotype', 'Book Antiqua', Palatino, serif\", 16);\n\t\n\t    this.rubricColor = \"#d00\";\n\t    this.specialCharProperties = {\n\t      \"font-family\": \"'Exsurge Characters'\",\n\t      fill: this.rubricColor,\n\t      class: 'rubric'\n\t    };\n\t    this.textBeforeSpecialChar = \"\";\n\t    this.textAfterSpecialChar = \".\";\n\t    this.specialCharMap = {\n\t      \"℣\": 'v',\n\t      \"℟\": 'r',\n\t      \"+\": \"+\",\n\t      \"*\": \"*\"\n\t    };\n\t    this.plusProperties = {};\n\t    this.asteriskProperties = {};\n\t    this.specialCharText = function (char) {\n\t      return _this.specialCharMap[char] || char;\n\t    };\n\t\n\t    this.fontStyleDictionary = {\n\t      b: { \"font-weight\": \"bold\" },\n\t      i: { \"font-style\": \"italic\" },\n\t      u: { \"text-decoration\": \"underline\" },\n\t      ul: { \"text-decoration\": \"underline\" },\n\t      c: { fill: this.rubricColor, class: 'rubric' },\n\t      sc: { \"font-variant\": \"small-caps\" },\n\t      v: {},\n\t      e: { \"font-style\": \"italic\", \"font-size\": \"90%\" }\n\t    };\n\t\n\t    this.markupSymbolDictionary = {\n\t      \"*\": \"b\",\n\t      \"_\": \"i\",\n\t      \"^\": \"c\",\n\t      \"%\": \"sc\"\n\t    };\n\t\n\t    this.textStyles.al.prefix = \"<i>\";\n\t\n\t    this.textStyles.translation.prefix = \"<i>\";\n\t\n\t    this.textStyles.dropCap.padding = 1; // minimum padding on either side of drop cap in staffIntervals\n\t\n\t    this.textStyles.annotation.padding = 1; // minimum padding on either side of annotation in staffIntervals\n\t\n\t    this.minLedgerSeparation = 2; // multiple of staffInterval\n\t    this.minSpaceAboveStaff = 2; // multiple of staffInterval\n\t    this.minSpaceBelowStaff = 1; // multiple of staffInterval\n\t    this.spaceBetweenSystems = 1.5; // multiple of staffInterval\n\t\n\t    // everything depends on the scale of the punctum\n\t    this.glyphPunctumWidth = _ExsurgeGlyphs.Glyphs.PunctumQuadratum.bounds.width;\n\t    this.glyphPunctumHeight = _ExsurgeGlyphs.Glyphs.PunctumQuadratum.bounds.height;\n\t\n\t    // max space to add between notations when justifying, in multiples of this.staffInterval\n\t    this.maxExtraSpaceInStaffIntervals = 0.5;\n\t\n\t    // for keeping track of the clef\n\t    this.activeClef = null;\n\t\n\t    this.neumeLineColor = \"#000\";\n\t    this.staffLineColor = \"#000\";\n\t    this.dividerLineColor = \"#000\";\n\t\n\t    this.defaultLanguage = _ExsurgeText.language.latin;\n\t\n\t    // calculate the pixel ratio for drawing to a canvas\n\t    this.pixelRatio = typeof window === 'undefined' ? 1.0 : window.devicePixelRatio || 1.0;\n\t\n\t    //this.canvasCtxt.scale(this.pixelRatio, this.pixelRatio);\n\t\n\t    if (textMeasuringStrategy === TextMeasuringStrategy.Svg) {\n\t      this.svgTextMeasurer = QuickSvg.svg(0, 0);\n\t      this.svgTextMeasurer.setAttribute(\"id\", \"TextMeasurer\");\n\t      this.svgTextMeasurer.setAttribute(\"style\", \"position:absolute\");\n\t      document.body.insertBefore(this.svgTextMeasurer, document.body.firstChild);\n\t    } else if (textMeasuringStrategy === TextMeasuringStrategy.Canvas) {\n\t      this.makeCanvasIfNeeded();\n\t    }\n\t\n\t    // for connecting neume syllables...\n\t    this.syllableConnector = \"-\";\n\t\n\t    // set whether to scale the def tags (scaleDefs = true) or the use tags.\n\t    this.scaleDefs = true;\n\t\n\t    // fixme: for now, we just set these using the glyph scales as noted above, presuming a\n\t    // staff line size of 0.5 in. Really what we should do is scale the punctum size based\n\t    // on the text metrics, right? 1 punctum ~ x height size?\n\t    this.setGlyphScaling(1.0 / 16.0);\n\t\n\t    // minimum space between puncta of different syllables, in multiples of this.intraNeumeSpacing\n\t    this.interSyllabicMultiplier = 2.5;\n\t\n\t    // space between an accidental and the following note, in multiples of this.intraNeumeSpacing\n\t    this.accidentalSpaceMultiplier = 2;\n\t\n\t    // space added between puncta of different words, in multiples of this.intraNeumeSpacing\n\t    this.interVerbalMultiplier = 1;\n\t\n\t    this.drawGuides = false;\n\t    this.drawDebuggingBounds = true;\n\t\n\t    // we keep track of where we are in processing notations, so that\n\t    // we can maintain the context for notations to know about.\n\t    //\n\t    // these are only gauranteed to be valid during the performLayout phase!\n\t    this.activeNotations = null;\n\t    this.currNotationIndex = -1;\n\t\n\t    this.minSyllablesLastLine = 0;\n\t    this.minNotesLastLine = 0;\n\t\n\t    // chant notation elements are normally separated by a minimum fixed amount of space\n\t    // on the staff line. It can happen, however, that two text elements are almost close\n\t    // enough to merge, only to be separated much more by the required hyphen (or other\n\t    // connecting string).\n\t    //\n\t    // This tolerance value allows a little bit of flexibility to merge two close lyrical\n\t    // elements, thus bringing the chant notation elements a bit closer than otherwise\n\t    // would be normally allowed.\n\t    //\n\t    // condensing tolerance is a percentage value (0.0-1.0, inclusive) that indicates\n\t    // how much the default spacing can shrink. E.g., a value of 0.20 allows the layout\n\t    // engine to separate two glyphs by only 80% of the normal inter-neume spacing value.\n\t    this.condensingTolerance = 0.3;\n\t\n\t    // if auto color is true, then exsurge tries to automatically colorize\n\t    // some elements of the chant (directives become rubric color, etc.)\n\t    this.autoColor = true;\n\t\n\t    this.useExtraTextOnly = true;\n\t\n\t    this.noteIdPrefix = 'note-';\n\t\n\t    this.insertFontsInDoc();\n\t    this.setMergeAnnotationWithTextLeft(true);\n\t  }\n\t\n\t  /**\n\t   * convert a staff position counting from the first space below the staff (gabc notation \"c\")\n\t   * into a position counting from the middle space (variable based on how many staff lines there are)\n\t   * @param {number} staffPosition \n\t   * @returns {number}\n\t   */\n\t\n\t\n\t  _createClass(ChantContext, [{\n\t    key: \"convertStaffPositionToSymmetric\",\n\t    value: function convertStaffPositionToSymmetric(staffPosition) {\n\t      return staffPosition - this.staffLineCount;\n\t    }\n\t  }, {\n\t    key: \"convertSymmetricStaffPosition\",\n\t    value: function convertSymmetricStaffPosition(staffPositionSymmetric) {\n\t      return staffPositionSymmetric + this.staffLineCount;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @param {*} properties \n\t     * @param {string} fontFamily \n\t     * @returns {import('opentype.js').Font | undefined}\n\t     */\n\t\n\t  }, {\n\t    key: \"getFontForProperties\",\n\t    value: function getFontForProperties() {\n\t      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t      var fontFamily = arguments[1];\n\t\n\t      var key = this.getFontFilenameForProperties(properties),\n\t          keyWithFontFamily = this.getFontFilenameForProperties(properties, fontFamily);\n\t      return this.fontDictionary && (this.fontDictionary[keyWithFontFamily] || this.fontDictionary[fontFamily] || this.fontDictionary.Regular);\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @param {string} font : ;\n\t     * @param {number} size \n\t     * @param {any} baseStyle \n\t     * @param {{ [key: string]: import('opentype.js').Font }} fontDictionary \n\t     */\n\t\n\t  }, {\n\t    key: \"setFont\",\n\t    value: function setFont(font) {\n\t      var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;\n\t      var baseStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\t      var fontDictionary = arguments[3];\n\t      var _iteratorNormalCompletion2 = true;\n\t      var _didIteratorError2 = false;\n\t      var _iteratorError2 = undefined;\n\t\n\t      try {\n\t        for (var _iterator2 = Object.entries(TextTypes)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t          var _step2$value = _slicedToArray(_step2.value, 2),\n\t              key = _step2$value[0],\n\t              textType = _step2$value[1];\n\t\n\t          var textStyle = this.textStyles[key] = this.textStyles[key] || {};\n\t          textStyle.size = textType.defaultSize ? textType.defaultSize(size, this) : textType.size(this);\n\t          textStyle.font = font;\n\t          textStyle.color = this.textColor || \"#000\";\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError2 = true;\n\t        _iteratorError2 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t            _iterator2.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError2) {\n\t            throw _iteratorError2;\n\t          }\n\t        }\n\t      }\n\t\n\t      this.baseTextStyle = baseStyle;\n\t\n\t      if (fontDictionary) {\n\t        this.textMeasuringStrategy = TextMeasuringStrategy.OpenTypeJS;\n\t        this.fontDictionary = fontDictionary;\n\t      }\n\t    }\n\t  }, {\n\t    key: \"setRubricColor\",\n\t    value: function setRubricColor(color) {\n\t      this.rubricColor = color;\n\t      this.specialCharProperties.fill = color;\n\t      this.fontStyleDictionary.c.fill = color;\n\t    }\n\t  }, {\n\t    key: \"setMergeAnnotationWithTextLeft\",\n\t    value: function setMergeAnnotationWithTextLeft(merge) {\n\t      this.mergeAnnotationWithTextLeft = merge ? __mergeAnnotationWithTextLeft : undefined;\n\t    }\n\t  }, {\n\t    key: \"setScaleDefs\",\n\t    value: function setScaleDefs(scaleDefs) {\n\t      scaleDefs = !!scaleDefs;\n\t      if (this.scaleDefs !== scaleDefs) {\n\t        this.scaleDefs = scaleDefs;\n\t        this.setGlyphScaling(this.glyphScaling);\n\t      }\n\t    }\n\t  }, {\n\t    key: \"createStyleCss\",\n\t    value: function createStyleCss() {\n\t      var style = \"\";\n\t      var _iteratorNormalCompletion3 = true;\n\t      var _didIteratorError3 = false;\n\t      var _iteratorError3 = undefined;\n\t\n\t      try {\n\t        for (var _iterator3 = Object.entries(TextTypes)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t          var _step3$value = _slicedToArray(_step3.value, 2),\n\t              key = _step3$value[0],\n\t              textType = _step3$value[1];\n\t\n\t          var cssClass = textType.cssClass,\n\t              _textStyles$key = this.textStyles[key],\n\t              color = _textStyles$key.color,\n\t              font = _textStyles$key.font,\n\t              size = _textStyles$key.size;\n\t\n\t          style += \"svg.Exsurge .\" + cssClass + \"{fill:\" + color + \";font-family:\" + font + \";font-size:\" + size + \"px;font-kerning:normal}\";\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError3 = true;\n\t        _iteratorError3 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t            _iterator3.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError3) {\n\t            throw _iteratorError3;\n\t          }\n\t        }\n\t      }\n\t\n\t      return style;\n\t    }\n\t  }, {\n\t    key: \"createStyleNode\",\n\t    value: function createStyleNode() {\n\t      var node = QuickSvg.createNode(\"style\", {});\n\t      node.textContent = this.createStyleCss();\n\t      return node;\n\t    }\n\t  }, {\n\t    key: \"createStyleTree\",\n\t    value: function createStyleTree() {\n\t      return { name: \"style\", props: {}, children: [this.createStyleCss()] };\n\t    }\n\t  }, {\n\t    key: \"createStyle\",\n\t    value: function createStyle() {\n\t      return \"<style>\" + this.createStyleCss() + \"</style>\";\n\t    }\n\t  }, {\n\t    key: \"updateHyphenWidth\",\n\t    value: function updateHyphenWidth() {\n\t      // measure the size of a hyphen for the lyrics\n\t      var hyphen = new Lyric(this, this.syllableConnector, LyricType.SingleSyllable);\n\t      var multiplier = this.minLyricWordSpacing / (this.hyphenWidth || this.minLyricWordSpacing) || 1;\n\t      this.hyphenWidth = hyphen.bounds.width;\n\t\n\t      this.minLyricWordSpacing = multiplier * this.hyphenWidth;\n\t    }\n\t  }, {\n\t    key: \"setStaffHeight\",\n\t    value: function setStaffHeight(staffHeight) {\n\t      this.setGlyphScaling(staffHeight / 600);\n\t    }\n\t  }, {\n\t    key: \"setGlyphScaling\",\n\t    value: function setGlyphScaling(glyphScaling) {\n\t      this.glyphScaling = glyphScaling;\n\t\n\t      this.staffInterval = this.glyphPunctumWidth * this.glyphScaling;\n\t\n\t      // setup the line weights for the various elements.\n\t      this.staffLineWeight = Math.ceil(5 * this.staffInterval / 8) / 5;\n\t      this.neumeLineWeight = this.staffLineWeight; // the weight of connecting lines in the glyphs.\n\t      this.dividerLineWeight = this.neumeLineWeight; // of quarter bar, half bar, etc.\n\t      this.episemaLineWeight = this.neumeLineWeight * 1.25; // of horizontal episemata\n\t\n\t      this.intraNeumeSpacing = this.staffInterval / 2.0;\n\t\n\t      while (this.defsNode && this.defsNode.firstChild) {\n\t        this.defsNode.removeChild(this.defsNode.firstChild);\n\t      }for (var i = 0; i < this.makeDefs.length; ++i) {\n\t        this.makeDefs[i]();\n\t      }\n\t\n\t      this.updateHyphenWidth();\n\t    }\n\t  }, {\n\t    key: \"calculateHeightFromStaffPosition\",\n\t    value: function calculateHeightFromStaffPosition(staffPosition) {\n\t      return -staffPosition * this.staffInterval;\n\t    }\n\t  }, {\n\t    key: \"insertFontsInDoc\",\n\t    value: function insertFontsInDoc() {\n\t      if (!canAccessDOM) return;\n\t\n\t      var styleElement = document.getElementById(\"exsurge-fonts\");\n\t\n\t      if (styleElement === null) {\n\t        // create it since it doesn't exist yet.\n\t        styleElement = document.createElement(\"style\");\n\t        styleElement.id = \"exsurge-fonts\";\n\t\n\t        // styleElement.appendChild(document.createTextNode(\"@font-face{font-family: 'Exsurge Characters';font-weight: normal;font-style: normal;src: url(\" + __exsurgeCharactersFont + \") format('opentype');}\"));\n\t\n\t        document.head.appendChild(styleElement);\n\t      }\n\t    }\n\t\n\t    // returns the next neume starting at this.currNotationIndex, or null\n\t    // if there isn't a neume after this one...\n\t\n\t  }, {\n\t    key: \"findNextNeume\",\n\t    value: function findNextNeume() {\n\t      if (typeof this.currNotationIndex === \"undefined\") throw \"findNextNeume() called without a valid currNotationIndex set\";\n\t\n\t      for (var i = this.currNotationIndex + 1; i < this.notations.length; i++) {\n\t        var notation = this.notations[i];\n\t\n\t        if (notation.isNeume && !notation.hasNoWidth) return notation;\n\t      }\n\t\n\t      return null;\n\t    }\n\t  }, {\n\t    key: \"makeCanvasIfNeeded\",\n\t    value: function makeCanvasIfNeeded() {\n\t      if (!this.canvas) {\n\t        this.canvas = document.createElement(\"canvas\");\n\t        this.canvasCtxt = this.canvas.getContext(\"2d\");\n\t      }\n\t    }\n\t  }, {\n\t    key: \"setCanvasSize\",\n\t    value: function setCanvasSize(width, height) {\n\t      var scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\t\n\t      this.makeCanvasIfNeeded();\n\t\n\t      this.canvas.style.width = width * scale + \"px\";\n\t      this.canvas.style.height = height * scale + \"px\";\n\t      scale *= this.pixelRatio;\n\t      this.canvas.width = width * scale;\n\t      this.canvas.height = height * scale;\n\t\n\t      this.canvasCtxt.setTransform(scale, 0, 0, scale, 0, 0);\n\t    }\n\t  }]);\n\t\n\t  return ChantContext;\n\t}();\n\t\n\t/*\n\t * ChantLayoutElement\n\t */\n\t\n\t\n\tvar ChantLayoutElement = exports.ChantLayoutElement = function () {\n\t  function ChantLayoutElement() {\n\t    _classCallCheck(this, ChantLayoutElement);\n\t\n\t    this.bounds = new _ExsurgeCore.Rect();\n\t    this.origin = new _ExsurgeCore.Point(0, 0);\n\t\n\t    this.selected = false;\n\t    this.highlighted = false;\n\t  }\n\t\n\t  // draws the element on an html5 canvas\n\t\n\t\n\t  _createClass(ChantLayoutElement, [{\n\t    key: \"draw\",\n\t    value: function draw(ctxt) {\n\t      throw \"ChantLayout Elements must implement draw(ctxt)\";\n\t    }\n\t\n\t    // returns svg element\n\t\n\t  }, {\n\t    key: \"createSvgNode\",\n\t    value: function createSvgNode(ctxt) {\n\t      throw \"ChantLayout Elements must implement createSvgNode(ctxt)\";\n\t    }\n\t\n\t    // returns svg code for the element, used for printing support\n\t\n\t  }, {\n\t    key: \"createSvgFragment\",\n\t    value: function createSvgFragment(ctxt) {\n\t      throw \"ChantLayout Elements must implement createSvgFragment(ctxt)\";\n\t    }\n\t  }]);\n\t\n\t  return ChantLayoutElement;\n\t}();\n\t\n\tvar DividerLineVisualizer = exports.DividerLineVisualizer = function (_ChantLayoutElement) {\n\t  _inherits(DividerLineVisualizer, _ChantLayoutElement);\n\t\n\t  function DividerLineVisualizer(ctxt, staffPosition0, staffPosition1, divider) {\n\t    _classCallCheck(this, DividerLineVisualizer);\n\t\n\t    var _this2 = _possibleConstructorReturn(this, (DividerLineVisualizer.__proto__ || Object.getPrototypeOf(DividerLineVisualizer)).call(this));\n\t\n\t    _this2.divider = divider;\n\t\n\t    var y0 = ctxt.calculateHeightFromStaffPosition(staffPosition0);\n\t    var y1 = ctxt.calculateHeightFromStaffPosition(staffPosition1);\n\t\n\t    if (y0 > y1) {\n\t      var temp = y0;\n\t      y0 = y1;\n\t      y1 = temp;\n\t    }\n\t\n\t    _this2.bounds.x = 0;\n\t    _this2.bounds.y = y0;\n\t    _this2.bounds.width = ctxt.dividerLineWeight;\n\t    _this2.bounds.height = y1 - y0;\n\t\n\t    _this2.origin.x = _this2.bounds.width / 2;\n\t    _this2.origin.y = y0;\n\t    return _this2;\n\t  }\n\t\n\t  _createClass(DividerLineVisualizer, [{\n\t    key: \"draw\",\n\t    value: function draw(ctxt) {\n\t      var canvasCtxt = ctxt.canvasCtxt;\n\t\n\t      canvasCtxt.fillStyle = ctxt.dividerLineColor;\n\t\n\t      canvasCtxt.fillRect(this.bounds.x, this.bounds.y, ctxt.dividerLineWeight, this.bounds.height);\n\t    }\n\t  }, {\n\t    key: \"getSvgProps\",\n\t    value: function getSvgProps(ctxt) {\n\t      var props = {\n\t        x: this.bounds.x,\n\t        y: this.bounds.y,\n\t        width: ctxt.dividerLineWeight,\n\t        height: this.bounds.height,\n\t        fill: ctxt.dividerLineColor,\n\t        class: \"dividerLine\"\n\t      };\n\t      if (this.divider) {\n\t        if (this.divider.selected) props.class += \" selected\";\n\t        props[\"source-index\"] = this.divider.sourceIndex;\n\t        props[\"element-index\"] = this.divider.elementIndex;\n\t        props.source = this.divider;\n\t      }\n\t      return props;\n\t    }\n\t  }, {\n\t    key: \"createSvgNode\",\n\t    value: function createSvgNode(ctxt) {\n\t      return QuickSvg.createNode(\"rect\", this.getSvgProps(ctxt));\n\t    }\n\t  }, {\n\t    key: \"createSvgTree\",\n\t    value: function createSvgTree(ctxt) {\n\t      return QuickSvg.createSvgTree(\"rect\", this.getSvgProps(ctxt));\n\t    }\n\t  }, {\n\t    key: \"createSvgFragment\",\n\t    value: function createSvgFragment(ctxt) {\n\t      return QuickSvg.createFragment(\"rect\", this.getSvgProps(ctxt));\n\t    }\n\t  }]);\n\t\n\t  return DividerLineVisualizer;\n\t}(ChantLayoutElement);\n\t\n\tvar NeumeLineVisualizer = exports.NeumeLineVisualizer = function (_ChantLayoutElement2) {\n\t  _inherits(NeumeLineVisualizer, _ChantLayoutElement2);\n\t\n\t  function NeumeLineVisualizer(ctxt, note0, note1, hanging) {\n\t    _classCallCheck(this, NeumeLineVisualizer);\n\t\n\t    var _this3 = _possibleConstructorReturn(this, (NeumeLineVisualizer.__proto__ || Object.getPrototypeOf(NeumeLineVisualizer)).call(this));\n\t\n\t    var staffPosition0 = note0.staffPosition;\n\t    var staffPosition1 = note1.staffPosition;\n\t\n\t    // note0 should be the upper one for our calculations here\n\t    if (staffPosition0 < staffPosition1) {\n\t      var temp = staffPosition0;\n\t      staffPosition0 = staffPosition1;\n\t      staffPosition1 = temp;\n\t    }\n\t\n\t    if (hanging && staffPosition0 - staffPosition1 > 4) {\n\t      staffPosition1 = staffPosition0 - 4;\n\t    }\n\t\n\t    var y0 = ctxt.calculateHeightFromStaffPosition(staffPosition0);\n\t    var y1 = 0;\n\t\n\t    if (hanging) {\n\t      // if the difference between the notes is only one, and the upper\n\t      // note is on a line, and the lower note is within the four staff lines,\n\t      // then our hanging line goes past the lower note by a whole\n\t      // staff interval\n\t      if (staffPosition0 - staffPosition1 === 1 && Math.abs(staffPosition0) % 2 === 1 && staffPosition1 > -3) staffPosition1--;\n\t\n\t      y1 += ctxt.glyphPunctumHeight * ctxt.glyphScaling / 2.2;\n\t    }\n\t\n\t    y1 += ctxt.calculateHeightFromStaffPosition(staffPosition1);\n\t\n\t    _this3.bounds.x = 0;\n\t    _this3.bounds.y = y0;\n\t    _this3.bounds.width = ctxt.neumeLineWeight;\n\t    _this3.bounds.height = y1 - y0;\n\t\n\t    _this3.origin.x = 0;\n\t    _this3.origin.y = 0;\n\t    return _this3;\n\t  }\n\t\n\t  _createClass(NeumeLineVisualizer, [{\n\t    key: \"draw\",\n\t    value: function draw(ctxt) {\n\t      var canvasCtxt = ctxt.canvasCtxt;\n\t\n\t      canvasCtxt.fillStyle = ctxt.neumeLineColor;\n\t\n\t      canvasCtxt.fillRect(this.bounds.x, this.bounds.y, ctxt.neumeLineWeight, this.bounds.height);\n\t    }\n\t  }, {\n\t    key: \"getSvgProps\",\n\t    value: function getSvgProps(ctxt) {\n\t      return {\n\t        x: this.bounds.x,\n\t        y: this.bounds.y,\n\t        width: ctxt.neumeLineWeight,\n\t        height: this.bounds.height,\n\t        fill: ctxt.neumeLineColor,\n\t        class: \"neumeLine\"\n\t      };\n\t    }\n\t  }, {\n\t    key: \"createSvgNode\",\n\t    value: function createSvgNode(ctxt) {\n\t      return QuickSvg.createNode(\"rect\", this.getSvgProps(ctxt));\n\t    }\n\t  }, {\n\t    key: \"createSvgTree\",\n\t    value: function createSvgTree(ctxt) {\n\t      return QuickSvg.createSvgTree(\"rect\", this.getSvgProps(ctxt));\n\t    }\n\t  }, {\n\t    key: \"createSvgFragment\",\n\t    value: function createSvgFragment(ctxt) {\n\t      return QuickSvg.createFragment(\"rect\", this.getSvgProps(ctxt));\n\t    }\n\t  }]);\n\t\n\t  return NeumeLineVisualizer;\n\t}(ChantLayoutElement);\n\t\n\tvar VirgaLineVisualizer = exports.VirgaLineVisualizer = function (_ChantLayoutElement3) {\n\t  _inherits(VirgaLineVisualizer, _ChantLayoutElement3);\n\t\n\t  function VirgaLineVisualizer(ctxt, note) {\n\t    _classCallCheck(this, VirgaLineVisualizer);\n\t\n\t    var _this4 = _possibleConstructorReturn(this, (VirgaLineVisualizer.__proto__ || Object.getPrototypeOf(VirgaLineVisualizer)).call(this));\n\t\n\t    var staffPosition = note.staffPosition;\n\t\n\t    var y0 = ctxt.calculateHeightFromStaffPosition(staffPosition);\n\t    var y1;\n\t\n\t    if (Math.abs(staffPosition % 2) === 0) y1 = y0 + ctxt.staffInterval * 1.8;else y1 = y0 + ctxt.staffInterval * 2.7;\n\t\n\t    _this4.bounds.x = 0;\n\t    _this4.bounds.y = y0;\n\t    _this4.bounds.width = ctxt.neumeLineWeight;\n\t    _this4.bounds.height = y1 - y0;\n\t\n\t    _this4.origin.x = 0;\n\t    _this4.origin.y = 0;\n\t    return _this4;\n\t  }\n\t\n\t  _createClass(VirgaLineVisualizer, [{\n\t    key: \"draw\",\n\t    value: function draw(ctxt) {\n\t      var canvasCtxt = ctxt.canvasCtxt;\n\t\n\t      canvasCtxt.fillStyle = ctxt.neumeLineColor;\n\t      canvasCtxt.fillRect(this.bounds.x, this.bounds.y, ctxt.neumeLineWeight, this.bounds.height);\n\t    }\n\t  }, {\n\t    key: \"getSvgProps\",\n\t    value: function getSvgProps(ctxt) {\n\t      return {\n\t        x: this.bounds.x,\n\t        y: this.bounds.y,\n\t        width: ctxt.neumeLineWeight,\n\t        height: this.bounds.height,\n\t        fill: ctxt.neumeLineColor,\n\t        class: \"neumeLine\"\n\t      };\n\t    }\n\t  }, {\n\t    key: \"createSvgNode\",\n\t    value: function createSvgNode(ctxt) {\n\t      return QuickSvg.createNode(\"rect\", this.getSvgProps(ctxt));\n\t    }\n\t  }, {\n\t    key: \"createSvgTree\",\n\t    value: function createSvgTree(ctxt) {\n\t      return QuickSvg.createSvgTree(\"rect\", this.getSvgProps(ctxt));\n\t    }\n\t  }, {\n\t    key: \"createSvgFragment\",\n\t    value: function createSvgFragment(ctxt) {\n\t      return QuickSvg.createFragment(\"rect\", this.getSvgProps(ctxt));\n\t    }\n\t  }]);\n\t\n\t  return VirgaLineVisualizer;\n\t}(ChantLayoutElement);\n\t\n\tvar LineaVisualizer = exports.LineaVisualizer = function (_ChantLayoutElement4) {\n\t  _inherits(LineaVisualizer, _ChantLayoutElement4);\n\t\n\t  function LineaVisualizer(ctxt, note) {\n\t    _classCallCheck(this, LineaVisualizer);\n\t\n\t    var _this5 = _possibleConstructorReturn(this, (LineaVisualizer.__proto__ || Object.getPrototypeOf(LineaVisualizer)).call(this));\n\t\n\t    var staffPosition = note.staffPosition;\n\t\n\t    var y0 = ctxt.calculateHeightFromStaffPosition(staffPosition) - note.origin.y;\n\t    var y1 = y0 + note.bounds.height;\n\t\n\t    _this5.bounds.x = 0;\n\t    _this5.bounds.y = y0;\n\t    _this5.bounds.width = ctxt.neumeLineWeight * 5 + note.bounds.width;\n\t    _this5.bounds.height = y1 - y0;\n\t\n\t    _this5.origin.x = ctxt.neumeLineWeight * 2.5;\n\t    _this5.origin.y = 0;\n\t    return _this5;\n\t  }\n\t\n\t  _createClass(LineaVisualizer, [{\n\t    key: \"draw\",\n\t    value: function draw(ctxt) {\n\t      var canvasCtxt = ctxt.canvasCtxt;\n\t\n\t      canvasCtxt.fillStyle = ctxt.neumeLineColor;\n\t      canvasCtxt.fillRect(this.bounds.x, this.bounds.y, ctxt.neumeLineWeight, this.bounds.height);\n\t      canvasCtxt.fillRect(this.bounds.x + this.bounds.width - ctxt.neumeLineWeight, this.bounds.y, ctxt.neumeLineWeight, this.bounds.height);\n\t    }\n\t  }, {\n\t    key: \"getSvgProps\",\n\t    value: function getSvgProps(ctxt, x) {\n\t      return {\n\t        x: x,\n\t        y: this.bounds.y,\n\t        width: ctxt.neumeLineWeight,\n\t        height: this.bounds.height,\n\t        fill: ctxt.neumeLineColor,\n\t        class: \"neumeLine\"\n\t      };\n\t    }\n\t  }, {\n\t    key: \"createSvgNode\",\n\t    value: function createSvgNode(ctxt) {\n\t      var _this6 = this;\n\t\n\t      return QuickSvg.createNode(\"g\", null, [this.bounds.x, this.bounds.x + this.bounds.width - ctxt.neumeLineWeight].map(function (x) {\n\t        return QuickSvg.createNode(\"rect\", _this6.getSvgProps(ctxt, x));\n\t      }));\n\t    }\n\t  }, {\n\t    key: \"createSvgTree\",\n\t    value: function createSvgTree(ctxt) {\n\t      var _this7 = this;\n\t\n\t      return QuickSvg.createSvgTree.apply(QuickSvg, [\"g\", {}].concat(_toConsumableArray([this.bounds.x, this.bounds.x + this.bounds.width - ctxt.neumeLineWeight].map(function (x) {\n\t        return QuickSvg.createSvgTree(\"rect\", _this7.getSvgProps(ctxt, x));\n\t      }))));\n\t    }\n\t  }, {\n\t    key: \"createSvgFragment\",\n\t    value: function createSvgFragment(ctxt) {\n\t      var _this8 = this;\n\t\n\t      return QuickSvg.createFragment(\"g\", null, [this.bounds.x, this.bounds.x + this.bounds.width - ctxt.neumeLineWeight].map(function (x) {\n\t        return QuickSvg.createFragment(\"rect\", _this8.getSvgProps(ctxt, x));\n\t      }).join(''));\n\t    }\n\t  }]);\n\t\n\t  return LineaVisualizer;\n\t}(ChantLayoutElement);\n\t\n\tvar GlyphVisualizer = exports.GlyphVisualizer = function (_ChantLayoutElement5) {\n\t  _inherits(GlyphVisualizer, _ChantLayoutElement5);\n\t\n\t  function GlyphVisualizer(ctxt, glyphCode) {\n\t    _classCallCheck(this, GlyphVisualizer);\n\t\n\t    var _this9 = _possibleConstructorReturn(this, (GlyphVisualizer.__proto__ || Object.getPrototypeOf(GlyphVisualizer)).call(this));\n\t\n\t    _this9.glyph = null;\n\t\n\t    _this9.setGlyph(ctxt, glyphCode);\n\t    return _this9;\n\t  }\n\t\n\t  _createClass(GlyphVisualizer, [{\n\t    key: \"setGlyph\",\n\t    value: function setGlyph(ctxt, glyphCode) {\n\t      if (this.glyphCode !== glyphCode) {\n\t        if (typeof glyphCode === \"undefined\" || glyphCode === null || glyphCode === \"\") glyphCode = this.glyphCode = GlyphCode.None;else this.glyphCode = glyphCode;\n\t\n\t        var glyph = this.glyph = _ExsurgeGlyphs.Glyphs[glyphCode];\n\t\n\t        // if this glyph hasn't been used yet, then load it up in the defs section for sharing\n\t        if (!ctxt.defs.hasOwnProperty(glyphCode)) {\n\t          var getDefProps = function getDefProps() {\n\t            var options = {\n\t              id: glyphCode,\n\t              class: \"glyph\"\n\t            };\n\t            if (ctxt.scaleDefs === true) {\n\t              options.transform = \"scale(\" + ctxt.glyphScaling + \")\";\n\t            }\n\t            return options;\n\t          };\n\t          var makeDef = function makeDef() {\n\t            var options = getDefProps();\n\t            // create the ref\n\t            ctxt.defs[glyphCode] = QuickSvg.createFragment(\"g\", options, QuickSvg.svgFragmentForGlyph(glyph, ctxt.neumeLineColor)); //ctxt.neumeLineColor\n\t\n\t            if (ctxt.defsNode) ctxt.defsNode.appendChild(QuickSvg.createNode(\"g\", options, QuickSvg.nodesForGlyph(glyph)));\n\t          };\n\t          makeDef.makeSvgTree = function () {\n\t            return QuickSvg.createSvgTree.apply(QuickSvg, [\"g\", getDefProps()].concat(_toConsumableArray(QuickSvg.nodesForGlyph(glyph, \"createSvgTree\"))));\n\t          };\n\t          makeDef.glyphCode = glyphCode;\n\t          makeDef();\n\t          ctxt.makeDefs.push(makeDef);\n\t        }\n\t\n\t        this.align = this.glyph.align;\n\t      }\n\t\n\t      this.origin.x = this.glyph.origin.x * ctxt.glyphScaling;\n\t      this.origin.y = this.glyph.origin.y * ctxt.glyphScaling;\n\t\n\t      this.bounds.x = 0;\n\t      this.bounds.y = -this.origin.y;\n\t      this.bounds.width = this.glyph.bounds.width * ctxt.glyphScaling;\n\t      this.bounds.height = this.glyph.bounds.height * ctxt.glyphScaling;\n\t    }\n\t  }, {\n\t    key: \"setStaffPosition\",\n\t    value: function setStaffPosition(ctxt, staffPosition) {\n\t      this.bounds.y = ctxt.calculateHeightFromStaffPosition(staffPosition) - this.origin.y;\n\t    }\n\t  }, {\n\t    key: \"draw\",\n\t    value: function draw(ctxt) {\n\t      var canvasCtxt = ctxt.canvasCtxt;\n\t\n\t      var x = this.bounds.x + this.origin.x;\n\t      var y = this.bounds.y + this.origin.y;\n\t      canvasCtxt.translate(x, y);\n\t      canvasCtxt.scale(ctxt.glyphScaling, ctxt.glyphScaling);\n\t      for (var i = 0; i < this.glyph.paths.length; i++) {\n\t        var path = this.glyph.paths[i];\n\t        canvasCtxt.fillStyle = path.type === \"negative\" ? \"#fff\" : ctxt.neumeLineColor;\n\t        canvasCtxt.fill(new Path2D(path.data));\n\t      }\n\t\n\t      canvasCtxt.scale(1.0 / ctxt.glyphScaling, 1.0 / ctxt.glyphScaling);\n\t      canvasCtxt.translate(-x, -y);\n\t    }\n\t  }, {\n\t    key: \"getSvgAttributes\",\n\t    value: function getSvgAttributes(ctxt, source) {\n\t      var className = \"\";\n\t      if (/^Porrectus\\d$/.test(this.glyphCode)) {\n\t        var notes = source.neume.notes,\n\t            noteIndex = notes.indexOf(source),\n\t            nextNote = notes[noteIndex + 1];\n\t        className = source.selected ? nextNote.selected ? \"selected\" : \"selectedA\" : nextNote.selected ? \"selectedB\" : \"\";\n\t      } else {\n\t        var isSelected = source && (source.selected || source.model && source.model.selected);\n\t        className = isSelected ? \"selected\" : \"\";\n\t      }\n\t      var result = {\n\t        \"xlink:href\": \"#\" + this.glyphCode,\n\t        class: className\n\t      };\n\t      if (source) {\n\t        result[\"source-index\"] = source.sourceIndex;\n\t        result[\"element-index\"] = source.elementIndex;\n\t        if ('noteIndex' in source) {\n\t          result.class += ' note';\n\t          result.id = ctxt.noteIdPrefix + (source.noteIndex + 1);\n\t          if (source.neume) {\n\t            var glyphCode = source.glyphVisualizer.glyphCode;\n\t            if (/^Porrectus/.test(glyphCode)) {\n\t              result.class += ' porrectus porrectus-start';\n\t            } else if (glyphCode === 'None') {\n\t              result.class += ' porrectus porrectus-end';\n\t            }\n\t          }\n\t        }\n\t      }\n\t      if (ctxt.scaleDefs === true) {\n\t        result.x = this.bounds.x + this.origin.x;\n\t        result.y = this.bounds.y + this.origin.y;\n\t      } else {\n\t        result.x = (this.bounds.x + this.origin.x) / ctxt.glyphScaling;\n\t        result.y = (this.bounds.y + this.origin.y) / ctxt.glyphScaling;\n\t        result.transform = \"scale(\" + ctxt.glyphScaling + \")\";\n\t      }\n\t      return result;\n\t    }\n\t  }, {\n\t    key: \"createSvgNode\",\n\t    value: function createSvgNode(ctxt, source) {\n\t      var attributes = this.getSvgAttributes(ctxt, source);\n\t      attributes.source = source;\n\t      return QuickSvg.createNode(\"use\", attributes);\n\t    }\n\t  }, {\n\t    key: \"createSvgTree\",\n\t    value: function createSvgTree(ctxt, source) {\n\t      var attributes = this.getSvgAttributes(ctxt, source);\n\t      if (source) attributes.source = source;\n\t      return QuickSvg.createSvgTree(\"use\", attributes);\n\t    }\n\t  }, {\n\t    key: \"createSvgFragment\",\n\t    value: function createSvgFragment(ctxt, source) {\n\t      return QuickSvg.createFragment(\"use\", this.getSvgAttributes(ctxt, source));\n\t    }\n\t  }]);\n\t\n\t  return GlyphVisualizer;\n\t}(ChantLayoutElement);\n\t\n\tvar RoundBraceVisualizer = exports.RoundBraceVisualizer = function (_ChantLayoutElement6) {\n\t  _inherits(RoundBraceVisualizer, _ChantLayoutElement6);\n\t\n\t  function RoundBraceVisualizer(ctxt, x1, x2, y, isAbove) {\n\t    _classCallCheck(this, RoundBraceVisualizer);\n\t\n\t    var _this10 = _possibleConstructorReturn(this, (RoundBraceVisualizer.__proto__ || Object.getPrototypeOf(RoundBraceVisualizer)).call(this));\n\t\n\t    _this10.ignoreBounds = true;\n\t\n\t    if (x1 > x2) {\n\t      // swap the xs\n\t      var temp = x1;\n\t      x1 = x2;\n\t      x2 = temp;\n\t    }\n\t\n\t    _this10.isAbove = isAbove;\n\t    _this10.braceHeight = 3 * ctxt.staffInterval / 2;\n\t\n\t    _this10.bounds = new _ExsurgeCore.Rect(x1, isAbove ? y - _this10.braceHeight : y, x2 - x1, _this10.braceHeight);\n\t\n\t    _this10.origin.x = 0;\n\t    _this10.origin.y = 0;\n\t    return _this10;\n\t  }\n\t\n\t  _createClass(RoundBraceVisualizer, [{\n\t    key: \"draw\",\n\t    value: function draw(ctxt) {\n\t      /**\n\t       * @type CanvasRenderingContext2D\n\t       */\n\t      var d = ctxt.canvasCtxt;\n\t\n\t      var _getPathPoints = this.getPathPoints(),\n\t          x1 = _getPathPoints.x1,\n\t          x2 = _getPathPoints.x2,\n\t          y = _getPathPoints.y,\n\t          cx1 = _getPathPoints.cx1,\n\t          cx2 = _getPathPoints.cx2,\n\t          cy = _getPathPoints.cy;\n\t\n\t      d.beginPath();\n\t      d.moveTo(x1, y);\n\t      d.bezierCurveTo(cx1, cy, cx2, cy, x2, y);\n\t      d.stroke();\n\t    }\n\t  }, {\n\t    key: \"getSvgPathProps\",\n\t    value: function getSvgPathProps(ctxt) {\n\t      return {\n\t        d: this.generatePathString(),\n\t        stroke: ctxt.neumeLineColor,\n\t        \"stroke-width\": ctxt.staffLineWeight + \"px\",\n\t        fill: \"none\",\n\t        class: \"brace\"\n\t      };\n\t    }\n\t  }, {\n\t    key: \"createSvgNode\",\n\t    value: function createSvgNode(ctxt) {\n\t      var node = QuickSvg.createNode(\"path\", this.getSvgPathProps(ctxt));\n\t      if (this.accent) {\n\t        return QuickSvg.createNode(\"g\", {\n\t          class: \"accentedBrace\"\n\t        }, [node, this.accent.createSvgNode(ctxt)]);\n\t      } else return node;\n\t    }\n\t  }, {\n\t    key: \"createSvgTree\",\n\t    value: function createSvgTree(ctxt) {\n\t      var node = QuickSvg.createSvgTree(\"path\", this.getSvgPathProps(ctxt));\n\t      if (this.accent) {\n\t        return QuickSvg.createSvgTree(\"g\", {\n\t          class: \"accentedBrace\"\n\t        }, node, this.accent.createSvgTree(ctxt));\n\t      } else return node;\n\t    }\n\t  }, {\n\t    key: \"createSvgFragment\",\n\t    value: function createSvgFragment(ctxt) {\n\t      var fragment = QuickSvg.createFragment(\"path\", this.getSvgPathProps(ctxt));\n\t\n\t      if (this.accent) {\n\t        fragment += this.accent.createSvgFragment(ctxt);\n\t\n\t        return QuickSvg.createFragment(\"g\", {\n\t          class: \"accentedBrace\"\n\t        }, fragment);\n\t      } else return fragment;\n\t    }\n\t  }, {\n\t    key: \"getPathPoints\",\n\t    value: function getPathPoints() {\n\t      var x1 = this.bounds.x;\n\t      var x2 = this.bounds.right();\n\t      var width = this.bounds.width;\n\t      var y, dx, dy;\n\t\n\t      dx = width / 6;\n\t      dy = this.bounds.height;\n\t      if (this.isAbove) {\n\t        y = this.bounds.bottom();\n\t        dy = -dy;\n\t      } else {\n\t        y = this.bounds.y;\n\t      }\n\t\n\t      //Calculate Control Points of path,\n\t      var cx1 = x1 + dx;\n\t      var cy = y + dy;\n\t      var cx2 = x2 - dx;\n\t\n\t      return { x1: x1, x2: x2, y: y, cx1: cx1, cx2: cx2, cy: cy };\n\t    }\n\t\n\t    // returns svg path d string\n\t\n\t  }, {\n\t    key: \"generatePathString\",\n\t    value: function generatePathString() {\n\t      var _getPathPoints2 = this.getPathPoints(),\n\t          x1 = _getPathPoints2.x1,\n\t          x2 = _getPathPoints2.x2,\n\t          y = _getPathPoints2.y,\n\t          cx1 = _getPathPoints2.cx1,\n\t          cx2 = _getPathPoints2.cx2,\n\t          cy = _getPathPoints2.cy;\n\t\n\t      // two decimal points should be enough, but if we need more precision, we can\n\t      // up it here.\n\t\n\t\n\t      var dp = 2;\n\t      return \"M \" + x1.toFixed(dp) + \" \" + y.toFixed(dp) + \" C \" + cx1.toFixed(dp) + \" \" + cy.toFixed(dp) + \" \" + cx2.toFixed(dp) + \" \" + cy.toFixed(dp) + \" \" + x2.toFixed(dp) + \" \" + y.toFixed(dp);\n\t    }\n\t  }]);\n\t\n\t  return RoundBraceVisualizer;\n\t}(ChantLayoutElement);\n\t\n\tvar CurlyBraceVisualizer = exports.CurlyBraceVisualizer = function (_ChantLayoutElement7) {\n\t  _inherits(CurlyBraceVisualizer, _ChantLayoutElement7);\n\t\n\t  function CurlyBraceVisualizer(ctxt, x1, x2, y) {\n\t    var isAbove = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n\t    var addAcuteAccent = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\t\n\t    _classCallCheck(this, CurlyBraceVisualizer);\n\t\n\t    var _this11 = _possibleConstructorReturn(this, (CurlyBraceVisualizer.__proto__ || Object.getPrototypeOf(CurlyBraceVisualizer)).call(this));\n\t\n\t    if (x1 > x2) {\n\t      // swap the xs\n\t      var temp = x1;\n\t      x1 = x2;\n\t      x2 = temp;\n\t    }\n\t\n\t    _this11.isAbove = isAbove;\n\t    _this11.braceHeight = ctxt.staffInterval / 2;\n\t\n\t    // y is the actual vertical start of the brace (left hand side)\n\t    // thus for a brace over notes, bounds.y is the bottom of brace,\n\t    // but for a brace under the notes, y is simply the y passed in.\n\t    if (isAbove) y -= _this11.braceHeight;\n\t\n\t    var bounds = new _ExsurgeCore.Rect(x1, y, x2 - x1, _this11.braceHeight);\n\t\n\t    if (addAcuteAccent && isAbove) {\n\t      _this11.accent = new GlyphVisualizer(ctxt, GlyphCode.AcuteAccent);\n\t      _this11.accent.bounds.x += bounds.x + (x2 - x1) / 2;\n\t      _this11.accent.bounds.y += bounds.y - ctxt.staffInterval / 4;\n\t\n\t      bounds.union(_this11.accent.bounds);\n\t    }\n\t\n\t    _this11.bounds = bounds;\n\t\n\t    _this11.origin.x = 0;\n\t    _this11.origin.y = 0;\n\t    return _this11;\n\t  }\n\t\n\t  _createClass(CurlyBraceVisualizer, [{\n\t    key: \"getSvgPathProps\",\n\t    value: function getSvgPathProps(ctxt) {\n\t      return {\n\t        d: this.generatePathString(),\n\t        stroke: ctxt.neumeLineColor,\n\t        \"stroke-width\": ctxt.staffLineWeight + \"px\",\n\t        fill: \"none\",\n\t        class: \"brace\"\n\t      };\n\t    }\n\t  }, {\n\t    key: \"createSvgNode\",\n\t    value: function createSvgNode(ctxt) {\n\t      var node = QuickSvg.createNode(\"path\", this.getSvgPathProps(ctxt));\n\t\n\t      if (this.accent) {\n\t        return QuickSvg.createNode(\"g\", {\n\t          class: \"accentedBrace\"\n\t        }, [node, this.accent.createSvgNode(ctxt)]);\n\t      } else return node;\n\t    }\n\t  }, {\n\t    key: \"createSvgTree\",\n\t    value: function createSvgTree(ctxt) {\n\t      var node = QuickSvg.createSvgTree(\"path\", this.getSvgPathProps(ctxt));\n\t      if (this.accent) {\n\t        return QuickSvg.createSvgTree(\"g\", {\n\t          class: \"accentedBrace\"\n\t        }, node, this.accent.createSvgTree(ctxt));\n\t      } else return node;\n\t    }\n\t  }, {\n\t    key: \"createSvgFragment\",\n\t    value: function createSvgFragment(ctxt) {\n\t      var fragment = QuickSvg.createFragment(\"path\", this.getSvgPathProps(ctxt));\n\t\n\t      if (this.accent) {\n\t        fragment += this.accent.createSvgFragment(ctxt);\n\t\n\t        return QuickSvg.createFragment(\"g\", {\n\t          class: \"accentedBrace\"\n\t        }, fragment);\n\t      } else return fragment;\n\t    }\n\t\n\t    // code below inspired by: https://gist.github.com/alexhornbake\n\t    // optimized for braces that are only drawn horizontally.\n\t    // returns svg path d string\n\t\n\t  }, {\n\t    key: \"generatePathString\",\n\t    value: function generatePathString() {\n\t      var q = 0.6; // .5 is normal, higher q = more expressive bracket\n\t\n\t      var x1 = this.bounds.x;\n\t      var x2 = this.bounds.right();\n\t      var width = this.bounds.width;\n\t      var y, h;\n\t\n\t      if (this.isAbove) {\n\t        y = this.bounds.bottom();\n\t        h = -this.braceHeight;\n\t      } else {\n\t        y = this.bounds.y;\n\t        h = this.braceHeight;\n\t      }\n\t\n\t      // calculate Control Points of path\n\t      var qy1 = y + q * h;\n\t      var qx2 = x1 + 0.25 * width;\n\t      var qy2 = y + (1 - q) * h;\n\t      var tx1 = x1 + 0.5 * width;\n\t      var ty1 = y + h;\n\t      var qy3 = y + q * h;\n\t      var qx4 = x1 + 0.75 * width;\n\t      var qy4 = y + (1 - q) * h;\n\t\n\t      // two decimal points should be enough, but if we need more precision, we can\n\t      // up it here.\n\t      var dp = 2;\n\t      return \"M \" + x1.toFixed(dp) + \" \" + y.toFixed(dp) + \" Q \" + x1.toFixed(dp) + \" \" + qy1.toFixed(dp) + \" \" + qx2.toFixed(dp) + \" \" + qy2.toFixed(dp) + \" T \" + tx1.toFixed(dp) + \" \" + ty1.toFixed(dp) + \" M \" + x2.toFixed(dp) + \" \" + y.toFixed(dp) + \" Q \" + x2.toFixed(dp) + \" \" + qy3.toFixed(dp) + \" \" + qx4.toFixed(dp) + \" \" + qy4.toFixed(dp) + \" T \" + tx1.toFixed(dp) + \" \" + ty1.toFixed(dp);\n\t    }\n\t  }]);\n\t\n\t  return CurlyBraceVisualizer;\n\t}(ChantLayoutElement);\n\t\n\tvar TextSpan = exports.TextSpan = function () {\n\t  function TextSpan(text, propertyArray, activeTags) {\n\t    var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\t    var extraProps = arguments[4];\n\t\n\t    _classCallCheck(this, TextSpan);\n\t\n\t    if (typeof propertyArray === \"undefined\" || propertyArray === null) propertyArray = [];\n\t\n\t    this.text = text;\n\t    this.propertyArray = propertyArray;\n\t    this.activeTags = activeTags || [];\n\t    this.index = index;\n\t    if (extraProps) {\n\t      if ('xOffset' in extraProps) this.xOffset = extraProps.xOffset;\n\t      if ('newLine' in extraProps) this.newLine = extraProps.newLine;\n\t    }\n\t  }\n\t\n\t  _createClass(TextSpan, [{\n\t    key: \"clone\",\n\t    value: function clone() {\n\t      var result = new TextSpan(this.text, this.propertyArray, this.activeTags, this.index);\n\t      if ('xOffset' in this) result.xOffset = this.xOffset;\n\t      if ('newLine' in this) result.newLine = this.newLine;\n\t      return result;\n\t    }\n\t  }, {\n\t    key: \"properties\",\n\t    get: function get() {\n\t      var result = Object.assign.apply(null, [{}].concat(this.propertyArray).concat());\n\t      if ('xOffset' in this) result.xOffset = this.xOffset;\n\t      if ('newLine' in this) result.newLine = this.newLine;\n\t      return result;\n\t    }\n\t  }]);\n\t\n\t  return TextSpan;\n\t}();\n\t\n\tvar MarkupStackFrame = function () {\n\t  function MarkupStackFrame(tagName, startIndex) {\n\t    var propertyArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\t    var symbol = arguments[3];\n\t\n\t    _classCallCheck(this, MarkupStackFrame);\n\t\n\t    this.tagName = tagName;\n\t    this.startIndex = startIndex;\n\t    this.propertyArray = propertyArray;\n\t    if (symbol) this.symbol = symbol;\n\t  }\n\t\n\t  _createClass(MarkupStackFrame, [{\n\t    key: \"properties\",\n\t    get: function get() {\n\t      return Object.assign.apply(null, [{}].concat(this.propertyArray));\n\t    }\n\t  }], [{\n\t    key: \"createStackFrame\",\n\t    value: function createStackFrame(ctxt, tagName, startIndex) {\n\t      var extraProperties = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\t      var symbol = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';\n\t\n\t      return new MarkupStackFrame(tagName, startIndex, [ctxt.fontStyleDictionary[tagName], extraProperties], symbol);\n\t    }\n\t  }]);\n\t\n\t  return MarkupStackFrame;\n\t}();\n\t\n\t// for escaping html strings before they go into the svgs\n\t// adapted from http://stackoverflow.com/a/12034334/5720160\n\t\n\t\n\tvar __subsForTspans = {\n\t  \"&\": \"&amp;\",\n\t  \"<\": \"&lt;\",\n\t  \">\": \"&gt;\"\n\t};\n\t\n\tvar TextElement = exports.TextElement = function (_ChantLayoutElement8) {\n\t  _inherits(TextElement, _ChantLayoutElement8);\n\t\n\t  function TextElement(ctxt, text, fontFamily, fontSize, textAnchor, sourceIndex, sourceGabc) {\n\t    _classCallCheck(this, TextElement);\n\t\n\t    // set these to some sane values for now...\n\t    var _this12 = _possibleConstructorReturn(this, (TextElement.__proto__ || Object.getPrototypeOf(TextElement)).call(this));\n\t\n\t    _this12.bounds.x = 0;\n\t    _this12.bounds.y = 0;\n\t    _this12.bounds.width = 0;\n\t    _this12.bounds.height = 0;\n\t    _this12.origin.x = 0;\n\t    _this12.origin.y = 0;\n\t\n\t    _this12.fontFamily = fontFamily;\n\t    _this12.fontSize = fontSize;\n\t    _this12.textAnchor = textAnchor;\n\t    _this12.sourceIndex = sourceIndex;\n\t    _this12.sourceGabc = sourceGabc;\n\t    _this12.dominantBaseline = \"baseline\"; // default placement\n\t\n\t    _this12.generateSpansFromText(ctxt, text);\n\t\n\t    _this12.recalculateMetrics(ctxt);\n\t    return _this12;\n\t  }\n\t\n\t  _createClass(TextElement, [{\n\t    key: \"getFromScore\",\n\t    value: function getFromScore(score) {\n\t      return this.textType.getFromScore(score, this);\n\t    }\n\t  }, {\n\t    key: \"generateSpansFromText\",\n\t    value: function generateSpansFromText(ctxt, text) {\n\t      var _this13 = this;\n\t\n\t      text = text.replace(/\\s+/g, \" \");\n\t      this.text = \"\";\n\t      this.spans = [];\n\t\n\t      // save ourselves a lot of grief for a very common text:\n\t      if (text === \"*\" || text === \"+\" || text === \"†\") {\n\t        var properties = text === \"*\" ? [ctxt.asteriskProperties] : text === \"+\" ? [ctxt.plusProperties] : null;\n\t        text = ctxt.specialCharText(text) || text;\n\t        this.spans.push(new TextSpan(text, properties));\n\t        return;\n\t      }\n\t\n\t      var markupStack = [];\n\t      var spanStartIndex = 0;\n\t      var newLineInNextSpan = 0;\n\t\n\t      var filterFrames = function filterFrames(frame, symbol) {\n\t        return frame.Symbol === symbol;\n\t      };\n\t\n\t      var closeSpan = function closeSpan(spanText, index, extraProperties) {\n\t        if (spanText === \"\" && !_this13.dropCap) return;\n\t\n\t        _this13.text += spanText;\n\t\n\t        var properties = [];\n\t        for (var i = 0; i < markupStack.length; i++) {\n\t          properties.push.apply(properties, markupStack[i].propertyArray);\n\t        }\n\t\n\t        if (extraProperties) properties.push(extraProperties);\n\t        var span = new TextSpan(spanText, properties, markupStack.map(function (frame) {\n\t          return frame.tagName;\n\t        }), index);\n\t        _this13.spans.push(span);\n\t        if (newLineInNextSpan) {\n\t          span.newLine = newLineInNextSpan;\n\t          newLineInNextSpan = 0;\n\t        }\n\t      };\n\t\n\t      var markupRegex = /(<br\\/?>)|<v>([\\s\\S]*?)(?:<\\/v>|$)|(\\*)(?=\\s*\\*|[^*]*(?:$|<v>))|(\\+)|<sp>(?:(~)|(')?([ao]e|[æœaeiouy])|([arv])\\/)<\\/sp>|([arv])\\/\\.|([℣℟])\\.?|(?:([*_^%])|<(\\/)?([bceiuv]|ul|sc|font)(?:\\s+(?:family=\"([^\"]+)\"|fill=\"([^\"]+)\"|class=\"([^\"]+)\"))*>)(?=(?:(.+?)(?:\\11|<\\/\\13>))?)/gi;\n\t      var vTagRegex = /(\\\\grecross)|\\{greextra\\}\\{([^}]*)\\}|\\{?(\\\\?')?(?:\\\\([ao]e|æœaeiouy))\\}?/gi;\n\t      var match = null;\n\t      var openedAsterisk = false;\n\t      var closeCurrentSpan = function closeCurrentSpan() {\n\t        return closeSpan(text.substring(spanStartIndex, match.index), spanStartIndex);\n\t      };\n\t      while (match = markupRegex.exec(text)) {\n\t        var _match = match,\n\t            _match2 = _slicedToArray(_match, 18),\n\t            newLine = _match2[1],\n\t            vTag = _match2[2],\n\t            asterisk = _match2[3],\n\t            plus = _match2[4],\n\t            tilde = _match2[5],\n\t            accent = _match2[6],\n\t            vowelLigature = _match2[7],\n\t            specialChar = _match2[8],\n\t            specialChar2 = _match2[9],\n\t            specialChar3 = _match2[10],\n\t            markupSymbol = _match2[11],\n\t            closingTag = _match2[12],\n\t            tagName = _match2[13],\n\t            family = _match2[14],\n\t            fill = _match2[15],\n\t            cssClass = _match2[16],\n\t            enclosedText = _match2[17];\n\t\n\t        specialChar = specialChar || specialChar2 || specialChar3;\n\t        // non-matching symbols first\n\t        if (newLine) {\n\t          // close the current span, if any:\n\t          if (match.index > spanStartIndex) {\n\t            closeCurrentSpan();\n\t          }\n\t          // add the newline span:\n\t          newLineInNextSpan++;\n\t        } else if (vTag) {\n\t          closeCurrentSpan();\n\t          var vMatch = void 0;\n\t          var lastIndex = 0;\n\t          var iOffset = 0;\n\t          while (vMatch = vTagRegex.exec(vTag)) {\n\t            if (lastIndex < vMatch.index) {\n\t              closeSpan(vTag.slice(lastIndex, vMatch.index), match.index + lastIndex + iOffset);\n\t              iOffset = 3; // length of '<v>'\n\t            }\n\t\n\t            var _vMatch = vMatch,\n\t                _vMatch2 = _slicedToArray(_vMatch, 5),\n\t                grecross = _vMatch2[1],\n\t                greextra = _vMatch2[2],\n\t                _accent = _vMatch2[3],\n\t                diphthong = _vMatch2[4];\n\t\n\t            var char = '';\n\t            if (diphthong) {\n\t              char = (0, _makeLigature.makeLigature)(diphthong);\n\t              if (_accent) char = (0, _addAccent.addAccent)(char);\n\t              closeSpan(char, match.index + vMatch.index + iOffset);\n\t            } else {\n\t              if (grecross) {\n\t                // grecross is just the command for the Cross:\n\t                // set up greextra so it will get handled with it below:\n\t                greextra = 'Cross';\n\t              }\n\t              char = _greextraGlyphs.greextraGlyphs[greextra];\n\t              if (char) {\n\t                closeSpan(char, match.index + vMatch.index + iOffset, { 'font-family': 'greextra' });\n\t              }\n\t            }\n\t            lastIndex = vTagRegex.lastIndex;\n\t            iOffset = 3; // length of '<v>'\n\t          }\n\t          if (lastIndex < vTag.length) {\n\t            closeSpan(vTag.slice(lastIndex), match.index + lastIndex + iOffset);\n\t          }\n\t        } else if (asterisk) {\n\t          closeCurrentSpan();\n\t          // first check if it is just a symbol to close:\n\t          if (markupStack.length > 0 && markupStack[markupStack.length - 1].symbol === asterisk) {\n\t            // close asterisk tag\n\t            markupStack.pop();\n\t          } else {\n\t            // add special asterisk:\n\t            closeSpan(ctxt.specialCharText(asterisk) || '*', match.index, ctxt.asteriskProperties);\n\t          }\n\t        } else if (plus) {\n\t          closeCurrentSpan();\n\t          closeSpan(ctxt.specialCharText(plus) || '+', match.index, ctxt.plusProperties);\n\t        } else if (tilde) {\n\t          closeCurrentSpan();\n\t          closeSpan('∼', match.index);\n\t        } else if (vowelLigature) {\n\t          var vowel = (0, _makeLigature.makeLigature)(vowelLigature);\n\t          if (accent) vowel = (0, _addAccent.addAccent)(vowel);\n\t          closeCurrentSpan();\n\t          closeSpan(vowel, match.index);\n\t        } else if (specialChar) {\n\t          closeCurrentSpan();\n\t          closeSpan(ctxt.textBeforeSpecialChar + ctxt.specialCharText(specialChar) + ctxt.textAfterSpecialChar, match.index, ctxt.specialCharProperties);\n\t        } else {\n\t          // otherwise we're dealing with matching markup delimeters\n\t          if (markupSymbol === \"*\") {\n\t            // we are only strict with the asterisk, because there are cases when it needs to be displayed rather than count as a markup symbol\n\t            if (enclosedText && /[^\\s*]/.test(enclosedText)) {\n\t              openedAsterisk = true;\n\t            } else if (openedAsterisk) {\n\t              openedAsterisk = false;\n\t            } else {\n\t              // actually use the asterisk, since it doesn't have a matching closing asterisk\n\t              continue;\n\t            }\n\t          }\n\t          if (markupSymbol) {\n\t            tagName = ctxt.markupSymbolDictionary[markupSymbol];\n\t            if (markupStack.length > 0 && markupStack[markupStack.length - 1].tagName === tagName && markupStack[markupStack.length - 1].symbol === markupSymbol) {\n\t              closingTag = true;\n\t            }\n\t          }\n\t          if (markupStack.length > 0 && markupStack[markupStack.length - 1].tagName === tagName) {\n\t            if (closingTag) {\n\t              // group close\n\t              closeCurrentSpan();\n\t              markupStack.pop();\n\t            }\n\t          } else if (markupStack.filter(filterFrames).length > 0) {\n\t            // trying to open a recursive group (or forgot to close a previous group)\n\t            // in either case, we just unwind to the previous stack frame\n\t            spanStartIndex = markupStack[markupStack.length - 1].startIndex;\n\t            markupStack.pop();\n\t            continue;\n\t          } else {\n\t            closeCurrentSpan();\n\t            if (closingTag) {\n\t              // out of order group close:\n\t              var index = markupStack.findIndex(function (frame) {\n\t                return frame.tagName === tagName;\n\t              });\n\t              if (index >= 0) {\n\t                markupStack.splice(index, 1);\n\t              }\n\t            } else {\n\t              // group open\n\t              var extraProperties = {};\n\t              if (family) extraProperties['font-family'] = family;\n\t              if (fill) extraProperties.fill = fill;\n\t              if (cssClass) extraProperties.class = cssClass;\n\t              markupStack.push(MarkupStackFrame.createStackFrame(ctxt, tagName, match.index, extraProperties, markupSymbol));\n\t            }\n\t          }\n\t        }\n\t\n\t        // advance the start index past the current markup\n\t        spanStartIndex = match.index + match[0].length;\n\t      }\n\t\n\t      // if we finished matches, and there is still some text left,\n\t      // or if we haven't generated any spans yet, create one final run\n\t      if (spanStartIndex < text.length || this.spans.length === 0) closeSpan(text.slice(spanStartIndex), spanStartIndex);\n\t    }\n\t  }, {\n\t    key: \"getCanvasFontForProperties\",\n\t    value: function getCanvasFontForProperties(ctxt) {\n\t      var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t      var font = \"\";\n\t      if (properties[\"font-style\"] === \"italic\") font += \"italic \";\n\t      if (properties[\"font-variant\"] === \"small-caps\") font += \"small-caps \";\n\t      if (properties[\"font-weight\"] === \"bold\") font += \"bold \";\n\t      var fontSize = parseFloat(properties[\"font-size\"]) || this.fontSize(ctxt);\n\t      if (/%$/.test(properties[\"font-size\"])) {\n\t        fontSize *= this.fontSize(ctxt) / 100;\n\t      }\n\t      font += fontSize * (this.resize || 1) + \"px \";\n\t      font += properties[\"font-family\"] || this.fontFamily(ctxt);\n\t      return font;\n\t    }\n\t  }, {\n\t    key: \"measureSubstringBBox\",\n\t    value: function measureSubstringBBox(ctxt, length) {\n\t      return this.measureSubstring(ctxt, length, true);\n\t    }\n\t\n\t    /**\n\t     * if length is undefined and this.rightAligned === true, then offsets will be marked for each newLine span\n\t     * \n\t     * @param {ChantContext} ctxt \n\t     * @param {number} length \n\t     * @param {boolean} returnBBox \n\t     * @returns measured substring, as a simple width unless returnBBox == true\n\t     */\n\t\n\t  }, {\n\t    key: \"measureSubstring\",\n\t    value: function measureSubstring(ctxt, length) {\n\t      var returnBBox = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t      if (length === 0) return 0;\n\t      if (!length) length = Infinity;\n\t      if (length < 0) {\n\t        var lines = -length;\n\t        length = Infinity;\n\t      }\n\t      var canvasCtxt = ctxt.canvasCtxt;\n\t      var width = 0;\n\t      var widths = [];\n\t      var newLineSpans = [this.spans[0]];\n\t      var subStringLength = 0;\n\t      var numLines = 1;\n\t      var fontSize = this.fontSize(ctxt) * (this.resize || 1);\n\t      var bbox = new _ExsurgeCore.Rect(0, 0, 0, 0);\n\t      for (var i = 0; i < this.spans.length; i++) {\n\t        var span = this.spans[i],\n\t            myText = span.text.slice(0, length - subStringLength);\n\t        if (span.newLine) {\n\t          numLines += parseInt(span.newLine) || 1;\n\t          if (!lines && this.rightAligned === true && length === Infinity) {\n\t            newLineSpans[newLineSpans.length - 1].xOffset = this.firstLineMaxWidth - width;\n\t            newLineSpans.push(span);\n\t          } else if (--lines === 0) break;\n\t          widths.push(width);\n\t          width = 0;\n\t        }\n\t        if (ctxt.textMeasuringStrategy === TextMeasuringStrategy.Canvas) {\n\t          canvasCtxt.font = this.getCanvasFontForProperties(ctxt, span.properties);\n\t          var metrics = canvasCtxt.measureText(myText, width, fontSize * (numLines - 1));\n\t          if (\"actualBoundingBoxAscent\" in metrics) {\n\t            var left = metrics.actualBoundingBoxLeft;\n\t            bbox.union(new _ExsurgeCore.Rect(width - left, fontSize * (numLines - 1) - metrics.actualBoundingBoxAscent, metrics.width + left, metrics.actualBoundingBoxDescent + metrics.actualBoundingBoxAscent));\n\t            if (this instanceof DropCap) {\n\t              width += Math.max(0, left);\n\t            }\n\t          } else {\n\t            bbox.union(new _ExsurgeCore.Rect(width, fontSize * (numLines - 2), metrics.width, fontSize));\n\t          }\n\t          width += metrics.width;\n\t        } else if (ctxt.textMeasuringStrategy === TextMeasuringStrategy.OpenTypeJS && ctxt.fontDictionary) {\n\t          // get the bounding box for the substring, placing it at x = width, y = fontSize * (numLines - 1)\n\t          var font = ctxt.getFontForProperties(span.properties, span.properties[\"font-family\"] || this.fontFamily(ctxt));\n\t          /**\n\t           * @type {{ features: { liga: boolean; smcp?: boolean; } }}\n\t           */\n\t          var options = { features: { liga: true } };\n\t          if (span.properties[\"font-variant\"] === \"small-caps\") {\n\t            options.features.smcp = true;\n\t          }\n\t          var spanFontSize = parseFloat(span.properties[\"font-size\"]) || fontSize;\n\t          if (/%$/.test(span.properties[\"font-size\"])) {\n\t            spanFontSize *= fontSize / 100;\n\t          }\n\t          var subBbox = font.getPath(myText, width, fontSize * (numLines - 1), spanFontSize, options).getBoundingBox();\n\t          var subWidth = font.getAdvanceWidth(myText, spanFontSize, options);\n\t\n\t          bbox.union(new _ExsurgeCore.Rect(width + subBbox.x1, subBbox.y1, subWidth - subBbox.x1, subBbox.y2 - subBbox.y1));\n\t          width += subWidth;\n\t          if (this instanceof DropCap) {\n\t            width -= subBbox.x1;\n\t          }\n\t        }\n\t        subStringLength += myText.length;\n\t        if (subStringLength === length) break;\n\t      }\n\t      if (!lines && width && newLineSpans.length && this.rightAligned === true && length === Infinity) {\n\t        newLineSpans[newLineSpans.length - 1].xOffset = this.firstLineMaxWidth - width;\n\t      }\n\t      width = Math.max.apply(Math, [width].concat(widths));\n\t      if (returnBBox === true) {\n\t        var height = bbox.height;\n\t        var y = bbox.y,\n\t            x = bbox.x;\n\t        return { width: width, height: height, x: x, y: y };\n\t      } else {\n\t        return width;\n\t      }\n\t    }\n\t  }, {\n\t    key: \"recalculateMetrics\",\n\t    value: function recalculateMetrics(ctxt) {\n\t      var resetNewLines = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t\n\t      if (resetNewLines) {\n\t        delete this.maxWidth;\n\t        delete this.firstLineMaxWidth;\n\t        delete this.rightAligned;\n\t        delete this.resize;\n\t        delete this.numLines;\n\t        // replace newlines with spaces\n\t        this.spans.forEach(function (span) {\n\t          delete span.xOffset;\n\t          if (span.newLine === true) {\n\t            delete span.newLine;\n\t            span.text = \" \" + span.text;\n\t          }\n\t        });\n\t      }\n\t\n\t      this.bounds.x = 0;\n\t      this.bounds.y = 0;\n\t\n\t      this.origin.x = 0;\n\t\n\t      if (ctxt.textMeasuringStrategy === TextMeasuringStrategy.Svg) {\n\t        while (ctxt.svgTextMeasurer.firstChild) {\n\t          ctxt.svgTextMeasurer.removeChild(ctxt.svgTextMeasurer.firstChild);\n\t        }ctxt.svgTextMeasurer.appendChild(this.createSvgNode(ctxt));\n\t        ctxt.svgTextMeasurer.appendChild(ctxt.createStyleNode());\n\t\n\t        var bbox = ctxt.svgTextMeasurer.firstChild.getBBox();\n\t        this.bounds.width = bbox.width;\n\t        this.bounds.height = bbox.height;\n\t        this.origin.y = -bbox.y; // offset to baseline from top\n\t        this.origin.x = -bbox.x;\n\t      } else {\n\t        var _bbox = this.measureSubstringBBox(ctxt);\n\t        this.bounds.width = _bbox.width;\n\t        this.bounds.height = _bbox.height;\n\t        this.origin.y = -_bbox.y;\n\t        this.origin.x = -_bbox.x;\n\t      }\n\t      this.numLines = this.spans.reduce(function (result, span) {\n\t        return result + (span.newLine ? parseInt(span.newLine) || 1 : 0);\n\t      }, 1);\n\t    }\n\t  }, {\n\t    key: \"setMaxWidth\",\n\t    value: function setMaxWidth(ctxt, maxWidth) {\n\t      var firstLineMaxWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : maxWidth;\n\t\n\t      if (this.spans.filter(function (s) {\n\t        return s.newLine === true;\n\t      }).length) {\n\t        // first get rid of any new lines set from a previous maxWidth\n\t        this.recalculateMetrics(ctxt);\n\t      }\n\t      if (this.bounds.width > maxWidth) {\n\t        this.maxWidth = maxWidth;\n\t        var percentage = maxWidth / this.bounds.width;\n\t        if (this instanceof Lyric && percentage >= 0.85) {\n\t          this.resize = percentage;\n\t        } else {\n\t          if (firstLineMaxWidth < 0) firstLineMaxWidth = maxWidth;\n\t          this.firstLineMaxWidth = firstLineMaxWidth;\n\t          var lastWidth = 0,\n\t              lastMatch = null,\n\t              regex = /\\s+|$/g,\n\t              max = firstLineMaxWidth,\n\t              match;\n\t          while ((match = regex.exec(this.text)) && (!lastMatch || match.index > lastMatch.index)) {\n\t            var width = this.measureSubstring(ctxt, match.index);\n\t            if (width > max && lastMatch) {\n\t              var _spans;\n\t\n\t              var spanIndex = 0,\n\t                  length = 0;\n\t              while (length < lastMatch.index && spanIndex < this.spans.length) {\n\t                var span = this.spans[spanIndex++];\n\t                length += span.text.length + (span.newLine ? 1 : 0);\n\t              }\n\t              if (length > lastMatch.index || spanIndex >= this.spans.length) {\n\t                var _span = this.spans[--spanIndex];\n\t                length -= _span.text.length;\n\t              }\n\t              var splitSpan = this.spans[spanIndex],\n\t                  textLeft = splitSpan.text.slice(0, lastMatch.index - length),\n\t                  textRight = splitSpan.text.slice(lastMatch.index + lastMatch[0].length - length),\n\t                  newSpans = [];\n\t              this.rightAligned = max === firstLineMaxWidth && firstLineMaxWidth !== maxWidth;\n\t              if (textLeft) newSpans.push(new TextSpan(textLeft, splitSpan.propertyArray, splitSpan.activeTags));\n\t              if (textRight) {\n\t                newSpans.push(new TextSpan(textRight, splitSpan.propertyArray, splitSpan.activeTags, undefined, { newLine: true }));\n\t              } else if (this.spans[spanIndex + 1]) {\n\t                this.spans[spanIndex + 1].newLine = true;\n\t              }\n\t              (_spans = this.spans).splice.apply(_spans, [spanIndex, 1].concat(newSpans));\n\t              this.needsLayout = true;\n\t              max = maxWidth;\n\t              if (match.index === this.text.length || this.measureSubstring(ctxt) <= maxWidth) break;\n\t              width = 0;\n\t              match = lastMatch = null;\n\t            }\n\t            lastWidth = width;\n\t            lastMatch = match;\n\t          }\n\t        }\n\t        this.recalculateMetrics(ctxt, false);\n\t      }\n\t    }\n\t  }, {\n\t    key: \"getCssClasses\",\n\t    value: function getCssClasses() {\n\t      return this.textType && this.textType.cssClass || \"\";\n\t    }\n\t  }, {\n\t    key: \"getExtraStyleProperties\",\n\t    value: function getExtraStyleProperties(ctxt) {\n\t      return ctxt.baseTextStyle || {};\n\t    }\n\t  }, {\n\t    key: \"draw\",\n\t    value: function draw(ctxt) {\n\t      var canvasCtxt = ctxt.canvasCtxt;\n\t\n\t      if (this.textAnchor === \"middle\") canvasCtxt.textAlign = \"center\";else canvasCtxt.textAlign = \"start\";\n\t\n\t      var translateWidth = 0,\n\t          translateHeight = 0;\n\t      for (var i = 0; i < this.spans.length; i++) {\n\t        var span = this.spans[i];\n\t        var xOffset = span.xOffset || 0;\n\t        if (span.newLine) {\n\t          var count = parseInt(span.newLine) || 1;\n\t          canvasCtxt.translate(translateWidth + xOffset, this.fontSize(ctxt) * count);\n\t          translateWidth = -xOffset;\n\t          translateHeight -= this.fontSize(ctxt);\n\t        } else if (xOffset) {\n\t          canvasCtxt.translate(translateWidth + xOffset, 0);\n\t          translateWidth = -xOffset;\n\t        }\n\t        var properties = Object.assign({}, this.getExtraStyleProperties(ctxt), span.properties);\n\t        canvasCtxt.font = this.getCanvasFontForProperties(ctxt, properties);\n\t        canvasCtxt.fillStyle = properties.fill || \"#000\";\n\t        canvasCtxt.fillText(span.text, this.bounds.x, this.bounds.y, span.textLength || undefined);\n\t        var metrics = canvasCtxt.measureText(span.text, this.bounds.x, this.bounds.y);\n\t        translateWidth -= metrics.width;\n\t        canvasCtxt.translate(metrics.width, 0);\n\t      }\n\t      canvasCtxt.translate(translateWidth, translateHeight);\n\t    }\n\t  }, {\n\t    key: \"getSvgProps\",\n\t    value: function getSvgProps() {\n\t      return {\n\t        \"source-index\": this.sourceIndex,\n\t        x: this.bounds.x,\n\t        y: this.bounds.y,\n\t        class: this.getCssClasses().trim(),\n\t        \"text-anchor\": this.textAnchor\n\t        //'dominant-baseline': this.dominantBaseline, // hanging baseline doesn't work in Safari\n\t      };\n\t    }\n\t  }, {\n\t    key: \"getSpanOptions\",\n\t    value: function getSpanOptions(span, ctxt) {\n\t      var useStyleObject = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t      var options = {\n\t        \"source-index\": span.index,\n\t        class: span.properties.class,\n\t        style: useStyleObject ? Object.assign({}, span.properties) : (0, _ExsurgeCore.getCssForProperties)(span.properties)\n\t      };\n\t\n\t      if (span.newLine) {\n\t        var xOffset = span.xOffset || 0;\n\t        options.dy = 1.1 * (parseInt(span.newLine) || 1) + \"em\";\n\t        options.x = this.bounds.x + xOffset;\n\t      } else if (span.xOffset) {\n\t        options.x = this.bounds.x + span.xOffset;\n\t      }\n\t      if (span.textLength) {\n\t        options.textLength = span.textLength;\n\t        options.lengthAdjust = \"spacingAndGlyphs\";\n\t        options.y = this.bounds.y;\n\t      }\n\t      if (this.resize) {\n\t        options[\"font-size\"] = span.properties[\"font-size\"] || this.fontSize(ctxt) * this.resize;\n\t      }\n\t      // if (ctxt.setFontFamilyAttributes) {\n\t      //   options[\"font-family\"] =\n\t      //     span.properties[\"font-family\"] ||\n\t      //     getFontFilenameForProperties(span.properties, this.fontFamily(ctxt));\n\t      //   let properties = Object.assign({}, span.properties);\n\t      //   delete properties[\"font-weight\"];\n\t      //   delete properties[\"font-style\"];\n\t      //   options[\"style\"] = getCssForProperties(properties);\n\t      // } else {\n\t      //   options[\"style\"] = getCssForProperties(span.properties);\n\t      // }\n\t\n\t      return options;\n\t    }\n\t  }, {\n\t    key: \"createSvgNode\",\n\t    value: function createSvgNode(ctxt) {\n\t      var spans = [];\n\t\n\t      for (var i = 0; i < this.spans.length; i++) {\n\t        var span = this.spans[i];\n\t        var _options = this.getSpanOptions(span, ctxt);\n\t\n\t        spans.push(QuickSvg.createNode(\"tspan\", _options, span.text));\n\t      }\n\t\n\t      var options = this.getSvgProps();\n\t      var extraStyleProperties = this.getExtraStyleProperties(ctxt);\n\t      options.style = (0, _ExsurgeCore.getCssForProperties)(extraStyleProperties);\n\t      if (extraStyleProperties.class) {\n\t        options.class = extraStyleProperties.class + ' ' + options.class;\n\t      }\n\t      options.source = this;\n\t\n\t      return this.svgNode = QuickSvg.createNode(\"text\", options, spans);\n\t    }\n\t  }, {\n\t    key: \"createSvgTree\",\n\t    value: function createSvgTree(ctxt) {\n\t      var spans = [];\n\t\n\t      for (var i = 0; i < this.spans.length; i++) {\n\t        var span = this.spans[i];\n\t        var _options2 = this.getSpanOptions(span, ctxt, true);\n\t\n\t        spans.push(QuickSvg.createSvgTree(\"tspan\", _options2, span.text));\n\t      }\n\t\n\t      var options = this.getSvgProps();\n\t      options.style = this.getExtraStyleProperties(ctxt);\n\t      if (options.style.class) {\n\t        options.class = options.style.class + ' ' + options.class;\n\t      }\n\t      options.source = this;\n\t\n\t      return QuickSvg.createSvgTree.apply(QuickSvg, [\"text\", options].concat(spans));\n\t    }\n\t  }, {\n\t    key: \"createSvgFragment\",\n\t    value: function createSvgFragment(ctxt) {\n\t      var spans = \"\";\n\t\n\t      for (var i = 0; i < this.spans.length; i++) {\n\t        var span = this.spans[i];\n\t        var _options3 = this.getSpanOptions(span, ctxt);\n\t\n\t        spans += QuickSvg.createFragment(\"tspan\", _options3, TextElement.escapeForTspan(span.text));\n\t      }\n\t\n\t      var options = this.getSvgProps();\n\t      var extraStyleProperties = this.getExtraStyleProperties(ctxt);\n\t      options.style = (0, _ExsurgeCore.getCssForProperties)(extraStyleProperties);\n\t      if (extraStyleProperties.class) {\n\t        options.class = extraStyleProperties.class + ' ' + options.class;\n\t      }\n\t      if (ctxt.setFontFamilyAttributes) {\n\t        options[\"font-size\"] = this.fontSize(ctxt);\n\t      }\n\t\n\t      return QuickSvg.createFragment(\"text\", options, spans);\n\t    }\n\t  }], [{\n\t    key: \"escapeForTspan\",\n\t    value: function escapeForTspan(string) {\n\t      return String(string).replace(/[&<>]/g, function (s) {\n\t        return __subsForTspans[s];\n\t      });\n\t    }\n\t  }]);\n\t\n\t  return TextElement;\n\t}(ChantLayoutElement);\n\t\n\tvar LyricType = exports.LyricType = {\n\t  SingleSyllable: 0,\n\t  BeginningSyllable: 1,\n\t  MiddleSyllable: 2,\n\t  EndingSyllable: 3,\n\t\n\t  Directive: 4 // for asterisks, \"ij.\" elements, or other performance notes.\n\t};\n\t\n\tvar LyricArray = exports.LyricArray = {\n\t  getLeft: function getLeft(lyricArray) {\n\t    if (lyricArray.length === 0) return NaN;\n\t\n\t    var x = Number.MAX_VALUE;\n\t    for (var i = 0; i < lyricArray.length; i++) {\n\t      if (lyricArray[i]) x = Math.min(x, lyricArray[i].notation.bounds.x + lyricArray[i].bounds.x);\n\t    }\n\t\n\t    return x;\n\t  },\n\t\n\t  getRight: function getRight(lyricArray, presumeConnectorNeeded) {\n\t    if (lyricArray.length === 0) return NaN;\n\t\n\t    var x = Number.MIN_VALUE;\n\t    for (var i = 0; i < lyricArray.length; i++) {\n\t      var l = lyricArray[i];\n\t      if (l) x = Math.max(x, l.notation.bounds.x + l.bounds.x + l.bounds.width + (presumeConnectorNeeded && l.allowsConnector() && !l.needsConnector ? l.getConnectorWidth() : 0));\n\t    }\n\t\n\t    return x;\n\t  },\n\t\n\t  hasOnlyOneLyric: function hasOnlyOneLyric(lyricArray) {\n\t    return lyricArray.filter(function (l) {\n\t      return l.originalText;\n\t    }).length === 1;\n\t  },\n\t\n\t  indexOfLyric: function indexOfLyric(lyricArray) {\n\t    return lyricArray.indexOf(lyricArray.filter(function (l) {\n\t      return l.originalText;\n\t    })[0]);\n\t  },\n\t\n\t  mergeIn: function mergeIn(lyricArray, newLyrics) {\n\t    for (var i = 0; i < newLyrics.length; ++i) {\n\t      if (newLyrics[i].originalText || !lyricArray[i]) lyricArray[i] = newLyrics[i];\n\t    }\n\t  },\n\t\n\t  mergeInArray: function mergeInArray(lyricArray, notations) {\n\t    for (var i = 0; i < notations.length; ++i) {\n\t      this.mergeIn(lyricArray, notations[i].lyrics);\n\t    }\n\t  },\n\t\n\t  setNotation: function setNotation(lyricArray, notation) {\n\t    notation.lyrics = lyricArray;\n\t    for (var i = 0; i < lyricArray.length; ++i) {\n\t      lyricArray[i].notation = notation;\n\t    }\n\t  }\n\t};\n\t\n\tvar Lyric = exports.Lyric = function (_TextElement) {\n\t  _inherits(Lyric, _TextElement);\n\t\n\t  function Lyric(ctxt, text, lyricType, notation, notations, sourceIndex) {\n\t    _classCallCheck(this, Lyric);\n\t\n\t    var _this14 = _possibleConstructorReturn(this, (Lyric.__proto__ || Object.getPrototypeOf(Lyric)).call(this, ctxt, (ctxt.textStyles.lyric.prefix || \"\") + text, function (ctxt) {\n\t      return ctxt.textStyles.lyric.font;\n\t    }, function (ctxt) {\n\t      return ctxt.textStyles.lyric.size;\n\t    }, \"start\", sourceIndex, text));\n\t\n\t    _this14.textType = TextTypes.lyric;\n\t\n\t    // save the original text in case we need to later use the lyric\n\t    // in a dropcap...\n\t    _this14.originalText = text;\n\t\n\t    _this14.notation = notation;\n\t    _this14.notations = notations;\n\t\n\t    if (typeof lyricType === \"undefined\" || lyricType === null || lyricType === \"\") _this14.lyricType = LyricType.SingleSyllable;else _this14.lyricType = lyricType;\n\t\n\t    // Lyrics keep track of how to center them on notation elements.\n\t    // centerTextIndex is the index in this.text where the centering starts,\n\t    // centerLength is how many characters comprise the center point.\n\t    // performLayout will do the processing\n\t    _this14.centerStartIndex = -1;\n\t    _this14.centerLength = text.length;\n\t\n\t    _this14.needsConnector = false;\n\t\n\t    // Lyrics can have their own language defined, which affects the alignment\n\t    // of the text with the notation element\n\t    _this14.language = null;\n\t\n\t    if (_this14.allowsConnector) _this14.connectorSpan = new TextSpan(ctxt.syllableConnector);\n\t    return _this14;\n\t  }\n\t\n\t  _createClass(Lyric, [{\n\t    key: \"allowsConnector\",\n\t    value: function allowsConnector() {\n\t      return this.lyricType === LyricType.BeginningSyllable || this.lyricType === LyricType.MiddleSyllable;\n\t    }\n\t  }, {\n\t    key: \"setForceConnector\",\n\t    value: function setForceConnector(force) {\n\t      this.forceConnector = force && this.allowsConnector();\n\t    }\n\t  }, {\n\t    key: \"setNeedsConnector\",\n\t    value: function setNeedsConnector(needs, width) {\n\t      if (needs === true || this.forceConnector) {\n\t        this.needsConnector = true;\n\t        if (typeof width !== \"undefined\") {\n\t          this.setConnectorWidth(width);\n\t        } else {\n\t          this.bounds.width = this.widthWithoutConnector + this.getConnectorWidth();\n\t        }\n\t\n\t        if (this.spans.length > 0 && this.spans[this.spans.length - 1] !== this.connectorSpan) this.spans.push(this.connectorSpan);\n\t      } else {\n\t        this.connectorWidth = 0;\n\t        this.needsConnector = false;\n\t        this.bounds.width = this.widthWithoutConnector;\n\t\n\t        var span = this.spans.pop();\n\t        if (span && span !== this.connectorSpan) this.spans.push(span);\n\t      }\n\t    }\n\t  }, {\n\t    key: \"setConnectorWidth\",\n\t    value: function setConnectorWidth(width) {\n\t      this.connectorWidth = width;\n\t      this.connectorSpan.textLength = width;\n\t      if (this.needsConnector) this.bounds.width = this.widthWithoutConnector + this.getConnectorWidth();\n\t    }\n\t  }, {\n\t    key: \"getConnectorWidth\",\n\t    value: function getConnectorWidth() {\n\t      return this.connectorWidth || this.defaultConnectorWidth;\n\t    }\n\t  }, {\n\t    key: \"getLeft\",\n\t    value: function getLeft() {\n\t      return this.notation.bounds.x + this.bounds.x;\n\t    }\n\t  }, {\n\t    key: \"getRight\",\n\t    value: function getRight() {\n\t      return this.notation.bounds.x + this.bounds.x + this.bounds.width;\n\t    }\n\t  }, {\n\t    key: \"recalculateMetrics\",\n\t    value: function recalculateMetrics(ctxt) {\n\t      var resetNewLines = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t\n\t      this.setNeedsConnector();\n\t\n\t      _get(Lyric.prototype.__proto__ || Object.getPrototypeOf(Lyric.prototype), \"recalculateMetrics\", this).call(this, ctxt, resetNewLines);\n\t\n\t      this.widthWithoutConnector = this.bounds.width;\n\t\n\t      this.connectorWidth = 0;\n\t      this.defaultConnectorWidth = ctxt.hyphenWidth;\n\t\n\t      var activeLanguage = this.language || ctxt.defaultLanguage;\n\t\n\t      // calculate the point where the text lines up to the staff notation\n\t      // and offset the rect that much. By default we just center the text,\n\t      // but the logic below allows for smarter lyric alignment based\n\t      // on manual override or language control.\n\t      var offset = this.widthWithoutConnector / 2,\n\t          x1,\n\t          x2,\n\t          vowelSegmentWidth = this.widthWithoutConnector;\n\t\n\t      // some simple checks for sanity, and disable manual centering if the numbers are bad\n\t      if (this.centerStartIndex >= 0 && (this.centerStartIndex >= this.text.length || this.centerLength < 0 || this.centerStartIndex + this.centerLength > this.text.length)) this.centerStartIndex = -1;\n\t\n\t      if (this.text.length === 0) {\n\t        // if we have no text to work with, then there's nothing to do!\n\t        // Unless it's a drop cap, in which case we center the connector:\n\t        if (this.dropCap && this.originalText) {\n\t          offset = ctxt.hyphenWidth / 2;\n\t          vowelSegmentWidth = ctxt.hyphenWidth;\n\t        }\n\t      } else if (this.centerStartIndex >= 0) {\n\t        // if we have manually overriden the centering logic for this lyric,\n\t        // then always use that.\n\t        if (ctxt.textMeasuringStrategy === TextMeasuringStrategy.Svg) {\n\t          // svgTextMeasurer still has the current lyric in it...\n\t          x1 = ctxt.svgTextMeasurer.firstChild.getSubStringLength(0, this.centerStartIndex);\n\t          x2 = ctxt.svgTextMeasurer.firstChild.getSubStringLength(0, this.centerStartIndex + this.centerLength);\n\t        } else {\n\t          x1 = this.measureSubstring(ctxt, this.centerStartIndex);\n\t          x2 = this.measureSubstring(ctxt, this.centerStartIndex + this.centerLength);\n\t        }\n\t        offset = (x1 + x2) / 2;\n\t        vowelSegmentWidth = x2 - x1;\n\t      } else {\n\t        // if it's a directive with no manual centering override, then\n\t        // just center the text.\n\t        if (this.lyricType !== LyricType.Directive) {\n\t          // only consider text content after the last space (if any)\n\t          var startIndex = this.text.lastIndexOf(\" \") + 1;\n\t\n\t          // unless there are no text characters following the space:\n\t          if (startIndex > 0 && !this.text.slice(startIndex).match(/[a-záéíóúýäëïöüÿàèìòùỳāēīōūȳăĕĭŏŭ]/i)) {\n\t            startIndex = 0;\n\t          }\n\t\n\t          // find indices of e tags to ignore when finding vowel segment:\n\t          var ignore = [];\n\t          var index = 0;\n\t          var indexOffset = startIndex;\n\t          var _iteratorNormalCompletion4 = true;\n\t          var _didIteratorError4 = false;\n\t          var _iteratorError4 = undefined;\n\t\n\t          try {\n\t            for (var _iterator4 = this.spans[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n\t              var span = _step4.value;\n\t\n\t              var endIndex = index + span.text.length;\n\t              if (span.activeTags.includes('e')) {\n\t                if (index <= startIndex) {\n\t                  startIndex = endIndex;\n\t                } else {\n\t                  ignore.push({ index: index - indexOffset, endIndex: endIndex - indexOffset });\n\t                }\n\t              }\n\t              index = endIndex;\n\t            }\n\t            // Non-directive elements are lined up to the chant notation based on vowel segments,\n\t          } catch (err) {\n\t            _didIteratorError4 = true;\n\t            _iteratorError4 = err;\n\t          } finally {\n\t            try {\n\t              if (!_iteratorNormalCompletion4 && _iterator4.return) {\n\t                _iterator4.return();\n\t              }\n\t            } finally {\n\t              if (_didIteratorError4) {\n\t                throw _iteratorError4;\n\t              }\n\t            }\n\t          }\n\t\n\t          var result = activeLanguage.findVowelSegment(this.text, startIndex, ignore);\n\t\n\t          if (result.found !== true) {\n\t            var match = this.text.slice(startIndex).match(/[a-z]+/i);\n\t            if (match) {\n\t              result.startIndex = startIndex + match.index;\n\t              result.length = match[0].length;\n\t            } else {\n\t              result.startIndex = startIndex;\n\t              result.length = this.text.length - startIndex;\n\t            }\n\t          }\n\t          if (ctxt.textMeasuringStrategy === TextMeasuringStrategy.Svg) {\n\t            // svgTextMeasurer still has the current lyric in it...\n\t            x1 = ctxt.svgTextMeasurer.firstChild.getSubStringLength(0, result.startIndex);\n\t            x2 = ctxt.svgTextMeasurer.firstChild.getSubStringLength(0, result.startIndex + result.length);\n\t          } else {\n\t            x1 = this.measureSubstring(ctxt, result.startIndex);\n\t            x2 = this.measureSubstring(ctxt, result.startIndex + result.length);\n\t          }\n\t          offset = (x1 + x2) / 2;\n\t          vowelSegmentWidth = x2 - x1;\n\t        }\n\t      }\n\t\n\t      this.vowelSegmentWidth = vowelSegmentWidth;\n\t\n\t      this.bounds.x = -offset;\n\t      this.bounds.y = 0;\n\t\n\t      this.origin.x = offset;\n\t    }\n\t  }, {\n\t    key: \"generateDropCap\",\n\t    value: function generateDropCap(ctxt) {\n\t      if (this.dropCap) return this.dropCap;\n\t      // disallow special characters:\n\t      if (this.spans[0].properties['font-family'] === ctxt.specialCharProperties['font-family']) {\n\t        return null;\n\t      }\n\t      var dropCapSpan = this.spans[0].clone();\n\t      dropCapSpan.text = dropCapSpan.text.slice(0, 1).toUpperCase();\n\t      var dropCapLowerCase = dropCapSpan.text.toLowerCase();\n\t      // disallow any characters that do not change from .toUpperCase():\n\t      if (dropCapSpan.text === dropCapLowerCase) return null;\n\t\n\t      if (dropCapSpan.activeTags.indexOf(\"sc\") >= 0) dropCapSpan.text = dropCapLowerCase;\n\t\n\t      var dropCap = this.dropCap = new DropCap(ctxt, \"\", this.sourceIndex);\n\t      dropCap.spans = [dropCapSpan];\n\t      var dropCapSourceGabcLength = this.sourceGabc.match(/^(?:<\\/?[^>]+>)*.?(?:<\\/[^>]+>)*/)[0].length;\n\t      dropCap.sourceGabc = this.sourceGabc.slice(0, dropCapSourceGabcLength);\n\t      this.sourceIndex += dropCap.sourceGabc.length;\n\t      this.sourceGabc = this.sourceGabc.slice(dropCapSourceGabcLength);\n\t\n\t      this.spans[0].text = this.spans[0].text.slice(1);\n\t      this.text = this.text.slice(1);\n\t      this.centerStartIndex--; // lost a letter, so adjust centering accordingly\n\t\n\t      return dropCap;\n\t    }\n\t  }, {\n\t    key: \"getCssClasses\",\n\t    value: function getCssClasses() {\n\t      var classes = this.lyricType === LyricType.Directive ? \"directive \" : \"\";\n\t\n\t      return classes + _get(Lyric.prototype.__proto__ || Object.getPrototypeOf(Lyric.prototype), \"getCssClasses\", this).call(this);\n\t    }\n\t  }, {\n\t    key: \"getExtraStyleProperties\",\n\t    value: function getExtraStyleProperties(ctxt) {\n\t      var props = _get(Lyric.prototype.__proto__ || Object.getPrototypeOf(Lyric.prototype), \"getExtraStyleProperties\", this).call(this, ctxt);\n\t\n\t      if (this.lyricType === LyricType.Directive && ctxt.autoColor === true) props = Object.assign({}, props, { fill: ctxt.rubricColor });\n\t\n\t      return props;\n\t    }\n\t  }]);\n\t\n\t  return Lyric;\n\t}(TextElement);\n\t\n\tvar ChoralSign = exports.ChoralSign = function (_TextElement2) {\n\t  _inherits(ChoralSign, _TextElement2);\n\t\n\t  function ChoralSign(ctxt, text, note, sourceIndex) {\n\t    _classCallCheck(this, ChoralSign);\n\t\n\t    var _this15 = _possibleConstructorReturn(this, (ChoralSign.__proto__ || Object.getPrototypeOf(ChoralSign)).call(this, ctxt, (ctxt.textStyles.choralSign.prefix || \"\") + text, function (ctxt) {\n\t      return ctxt.textStyles.choralSign.font;\n\t    }, TextTypes.choralSign.size, \"start\", sourceIndex, text));\n\t\n\t    _this15.positionHint = MarkingPositionHint.Default;\n\t    _this15.note = note;\n\t    _this15.textType = TextTypes.choralSign;\n\t    return _this15;\n\t  }\n\t\n\t  _createClass(ChoralSign, [{\n\t    key: \"recalculateMetrics\",\n\t    value: function recalculateMetrics(ctxt) {\n\t      _get(ChoralSign.prototype.__proto__ || Object.getPrototypeOf(ChoralSign.prototype), \"recalculateMetrics\", this).call(this, ctxt);\n\t    }\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      this.recalculateMetrics(ctxt);\n\t      this.bounds.x = this.note.bounds.x + Math.max(0, (ctxt.staffInterval - this.bounds.width) / 2); // center on the note itself\n\t\n\t      var offset = void 0,\n\t          staffPosition = void 0;\n\t      if (this.positionHint === MarkingPositionHint.Below) {\n\t        offset = -1;\n\t        staffPosition = this.note.staffPosition + 2 * offset;\n\t        staffPosition += staffPosition % 2 === 0 ? 0.3 : 1;\n\t      } else {\n\t        offset = 1;\n\t        staffPosition = this.note.staffPosition + 2 * offset;\n\t        staffPosition += staffPosition % 2 === 0 ? 0.3 : -0.4;\n\t      }\n\t      // if (staffPosition % 2 === 0) staffPosition += offset;\n\t      this.bounds.y = ctxt.calculateHeightFromStaffPosition(staffPosition) + this.origin.y;\n\t    }\n\t  }]);\n\t\n\t  return ChoralSign;\n\t}(TextElement);\n\t\n\tvar AboveLinesText = exports.AboveLinesText = function (_TextElement3) {\n\t  _inherits(AboveLinesText, _TextElement3);\n\t\n\t  /**\n\t   * @param {String} text\n\t   */\n\t  function AboveLinesText(ctxt, text, notation, sourceIndex) {\n\t    _classCallCheck(this, AboveLinesText);\n\t\n\t    var _this16 = _possibleConstructorReturn(this, (AboveLinesText.__proto__ || Object.getPrototypeOf(AboveLinesText)).call(this, ctxt, (ctxt.textStyles.al.prefix || \"\") + text, function (ctxt) {\n\t      return ctxt.textStyles.al.font;\n\t    }, function (ctxt) {\n\t      return ctxt.textStyles.al.size;\n\t    }, \"start\", sourceIndex, text));\n\t\n\t    _this16.notation = notation;\n\t    _this16.textType = TextTypes.al;\n\t\n\t    _this16.padding = ctxt.staffInterval / 2;\n\t    return _this16;\n\t  }\n\t\n\t  return AboveLinesText;\n\t}(TextElement);\n\t\n\tvar TranslationText = exports.TranslationText = function (_TextElement4) {\n\t  _inherits(TranslationText, _TextElement4);\n\t\n\t  /**\n\t   * @param {String} text\n\t   */\n\t  function TranslationText(ctxt, text, notation, sourceIndex) {\n\t    _classCallCheck(this, TranslationText);\n\t\n\t    var gabcSource = text;\n\t    var anchor = \"start\";\n\t    if (text === \"/\") {\n\t      text = \"\";\n\t      anchor = \"end\";\n\t    } else {\n\t      text = (ctxt.textStyles.translation.prefix || \"\") + text;\n\t    }\n\t\n\t    var _this17 = _possibleConstructorReturn(this, (TranslationText.__proto__ || Object.getPrototypeOf(TranslationText)).call(this, ctxt, text, function (ctxt) {\n\t      return ctxt.textStyles.translation.font;\n\t    }, function (ctxt) {\n\t      return ctxt.textStyles.translation.size;\n\t    }, anchor, sourceIndex, gabcSource));\n\t\n\t    _this17.notation = notation;\n\t    _this17.textType = TextTypes.translation;\n\t\n\t    _this17.padding = ctxt.staffInterval / 2;\n\t    return _this17;\n\t  }\n\t\n\t  return TranslationText;\n\t}(TextElement);\n\t\n\tvar DropCap = exports.DropCap = function (_TextElement5) {\n\t  _inherits(DropCap, _TextElement5);\n\t\n\t  /**\n\t   * @param {String} text\n\t   */\n\t  function DropCap(ctxt, text, sourceIndex) {\n\t    _classCallCheck(this, DropCap);\n\t\n\t    var _this18 = _possibleConstructorReturn(this, (DropCap.__proto__ || Object.getPrototypeOf(DropCap)).call(this, ctxt, (ctxt.textStyles.dropCap.prefix || \"\") + text, function (ctxt) {\n\t      return ctxt.textStyles.dropCap.font;\n\t    }, function (ctxt) {\n\t      return ctxt.textStyles.dropCap.size;\n\t    }, \"middle\", sourceIndex, text));\n\t\n\t    _this18.textType = TextTypes.dropCap;\n\t\n\t    _this18.padding = ctxt.staffInterval * ctxt.textStyles.dropCap.padding;\n\t    return _this18;\n\t  }\n\t\n\t  return DropCap;\n\t}(TextElement);\n\t\n\tvar TitleTextElement = exports.TitleTextElement = function (_TextElement6) {\n\t  _inherits(TitleTextElement, _TextElement6);\n\t\n\t  function TitleTextElement(ctxt, text, fontFamily, fontSize, textAnchor, sourceIndex, sourceGabc) {\n\t    _classCallCheck(this, TitleTextElement);\n\t\n\t    return _possibleConstructorReturn(this, (TitleTextElement.__proto__ || Object.getPrototypeOf(TitleTextElement)).call(this, ctxt, text, fontFamily, fontSize, textAnchor, sourceIndex, sourceGabc));\n\t  }\n\t\n\t  return TitleTextElement;\n\t}(TextElement);\n\t\n\tvar Supertitle = exports.Supertitle = function (_TitleTextElement) {\n\t  _inherits(Supertitle, _TitleTextElement);\n\t\n\t  function Supertitle(ctxt, text, sourceIndex) {\n\t    _classCallCheck(this, Supertitle);\n\t\n\t    var _this20 = _possibleConstructorReturn(this, (Supertitle.__proto__ || Object.getPrototypeOf(Supertitle)).call(this, ctxt, (ctxt.textStyles.supertitle.prefix || \"\") + text, function (ctxt) {\n\t      return ctxt.textStyles.supertitle.font;\n\t    }, function (ctxt) {\n\t      return ctxt.textStyles.supertitle.size;\n\t    }, \"middle\", sourceIndex, text));\n\t\n\t    _this20.textType = TextTypes.supertitle;\n\t\n\t    _this20.padding = function (ctxt) {\n\t      return (Number(ctxt.textStyles.supertitle.padding) || 1) * ctxt.textStyles.supertitle.size / 3;\n\t    };\n\t    return _this20;\n\t  }\n\t\n\t  return Supertitle;\n\t}(TitleTextElement);\n\t\n\tvar Title = exports.Title = function (_TitleTextElement2) {\n\t  _inherits(Title, _TitleTextElement2);\n\t\n\t  function Title(ctxt, text, sourceIndex) {\n\t    _classCallCheck(this, Title);\n\t\n\t    var _this21 = _possibleConstructorReturn(this, (Title.__proto__ || Object.getPrototypeOf(Title)).call(this, ctxt, (ctxt.textStyles.title.prefix || \"\") + text, function (ctxt) {\n\t      return ctxt.textStyles.title.font;\n\t    }, function (ctxt) {\n\t      return ctxt.textStyles.title.size;\n\t    }, \"middle\", sourceIndex, text));\n\t\n\t    _this21.textType = TextTypes.title;\n\t\n\t    _this21.padding = function (ctxt) {\n\t      return (Number(ctxt.textStyles.title.padding) || 1) * ctxt.textStyles.title.size / 3;\n\t    };\n\t    return _this21;\n\t  }\n\t\n\t  return Title;\n\t}(TitleTextElement);\n\t\n\tvar Subtitle = exports.Subtitle = function (_TitleTextElement3) {\n\t  _inherits(Subtitle, _TitleTextElement3);\n\t\n\t  function Subtitle(ctxt, text, sourceIndex) {\n\t    _classCallCheck(this, Subtitle);\n\t\n\t    var _this22 = _possibleConstructorReturn(this, (Subtitle.__proto__ || Object.getPrototypeOf(Subtitle)).call(this, ctxt, (ctxt.textStyles.subtitle.prefix || \"\") + text, function (ctxt) {\n\t      return ctxt.textStyles.subtitle.font;\n\t    }, function (ctxt) {\n\t      return ctxt.textStyles.subtitle.size;\n\t    }, \"middle\", sourceIndex, text));\n\t\n\t    _this22.textType = TextTypes.subtitle;\n\t\n\t    _this22.padding = function (ctxt) {\n\t      return (Number(ctxt.textStyles.subtitle.padding) || 1) * ctxt.textStyles.subtitle.size / 3;\n\t    };\n\t    return _this22;\n\t  }\n\t\n\t  return Subtitle;\n\t}(TitleTextElement);\n\t\n\tvar TextLeftRight = exports.TextLeftRight = function (_TitleTextElement4) {\n\t  _inherits(TextLeftRight, _TitleTextElement4);\n\t\n\t  function TextLeftRight(ctxt, text, type, sourceIndex) {\n\t    _classCallCheck(this, TextLeftRight);\n\t\n\t    var _this23 = _possibleConstructorReturn(this, (TextLeftRight.__proto__ || Object.getPrototypeOf(TextLeftRight)).call(this, ctxt, (ctxt.textStyles.leftRight.prefix || \"\") + text, function (ctxt) {\n\t      return ctxt.textStyles.leftRight.font;\n\t    }, function (ctxt) {\n\t      return ctxt.textStyles.leftRight.size;\n\t    }, type === \"textLeft\" ? \"start\" : \"end\", sourceIndex, text));\n\t\n\t    _this23.textType = TextTypes.leftRight;\n\t    _this23.extraClass = type === \"textLeft\" ? \"textLeft\" : \"textRight\";\n\t    _this23.headerKey = type === \"textLeft\" ? \"text-left\" : \"text-right\";\n\t    _this23.padding = function (ctxt) {\n\t      return (Number(ctxt.textStyles.leftRight.padding) || 1) * ctxt.textStyles.leftRight.size / 5;\n\t    };\n\t    return _this23;\n\t  }\n\t\n\t  _createClass(TextLeftRight, [{\n\t    key: \"getCssClasses\",\n\t    value: function getCssClasses() {\n\t      return this.extraClass + \" \" + _get(TextLeftRight.prototype.__proto__ || Object.getPrototypeOf(TextLeftRight.prototype), \"getCssClasses\", this).call(this);\n\t    }\n\t  }]);\n\t\n\t  return TextLeftRight;\n\t}(TitleTextElement);\n\t\n\tvar Annotation = exports.Annotation = function (_TextElement7) {\n\t  _inherits(Annotation, _TextElement7);\n\t\n\t  /**\n\t   * @param {String} text\n\t   */\n\t  function Annotation(ctxt, text, elementIndex) {\n\t    _classCallCheck(this, Annotation);\n\t\n\t    var _this24 = _possibleConstructorReturn(this, (Annotation.__proto__ || Object.getPrototypeOf(Annotation)).call(this, ctxt, (ctxt.textStyles.annotation.prefix || \"\") + text, function (ctxt) {\n\t      return ctxt.textStyles.annotation.font;\n\t    }, function (ctxt) {\n\t      return ctxt.textStyles.annotation.size;\n\t    }, \"middle\"));\n\t\n\t    _this24.sourceGabc = text;\n\t    if (typeof elementIndex === 'number') _this24.elementIndex = elementIndex;\n\t    _this24.textType = TextTypes.annotation;\n\t    _this24.padding = ctxt.staffInterval * ctxt.textStyles.annotation.padding;\n\t    _this24.dominantBaseline = \"hanging\"; // so that annotations can be aligned at the top.\n\t    return _this24;\n\t  }\n\t\n\t  return Annotation;\n\t}(TextElement);\n\t\n\tvar Annotations = exports.Annotations = function (_ChantLayoutElement9) {\n\t  _inherits(Annotations, _ChantLayoutElement9);\n\t\n\t  /**\n\t   * @param {String} text\n\t   */\n\t  function Annotations(ctxt) {\n\t    _classCallCheck(this, Annotations);\n\t\n\t    var _this25 = _possibleConstructorReturn(this, (Annotations.__proto__ || Object.getPrototypeOf(Annotations)).call(this));\n\t\n\t    _this25.lineHeight = 1.1;\n\t\n\t    for (var _len2 = arguments.length, texts = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n\t      texts[_key2 - 1] = arguments[_key2];\n\t    }\n\t\n\t    _this25.annotations = texts.map(function (text, i) {\n\t      return new Annotation(ctxt, text, i);\n\t    });\n\t    _this25.padding = Math.max.apply(null, _this25.annotations.map(function (annotation) {\n\t      return annotation.padding;\n\t    }));\n\t    return _this25;\n\t  }\n\t\n\t  _createClass(Annotations, [{\n\t    key: \"updateBounds\",\n\t    value: function updateBounds(multiplier) {\n\t      if (!multiplier) multiplier = 1;\n\t      for (var i = 0; i < this.annotations.length; ++i) {\n\t        var annotation = this.annotations[i];\n\t        annotation.bounds.x += this.bounds.x * multiplier;\n\t        annotation.bounds.y += this.bounds.y * multiplier;\n\t      }\n\t    }\n\t  }, {\n\t    key: \"recalculateMetrics\",\n\t    value: function recalculateMetrics(ctxt) {\n\t      this.bounds.x = 0;\n\t      this.bounds.y = 0;\n\t\n\t      this.bounds.width = 0;\n\t      this.bounds.height = 0;\n\t\n\t      this.origin.x = 0;\n\t      this.origin.y = 0;\n\t\n\t      var y = 0;\n\t      for (var i = 0; i < this.annotations.length; ++i) {\n\t        var annotation = this.annotations[i];\n\t        annotation.recalculateMetrics(ctxt);\n\t        this.bounds.width = Math.max(this.bounds.width, annotation.bounds.width);\n\t        annotation.bounds.y += y;\n\t        this.bounds.height = annotation.bounds.bottom();\n\t        this.origin.y = this.origin.y || annotation.origin.y;\n\t        y += annotation.fontSize(ctxt) * (annotation.resize || 1) * this.lineHeight;\n\t      }\n\t    }\n\t  }, {\n\t    key: \"draw\",\n\t    value: function draw(ctxt) {\n\t      this.updateBounds();\n\t      this.annotations.forEach(function (annotation) {\n\t        annotation.draw(ctxt);\n\t      });\n\t      this.updateBounds(-1);\n\t    }\n\t  }, {\n\t    key: \"createSvgNode\",\n\t    value: function createSvgNode(ctxt) {\n\t      this.updateBounds();\n\t      var result = this.annotations.map(function (annotation) {\n\t        return annotation.createSvgNode(ctxt);\n\t      });\n\t      this.updateBounds(-1);\n\t      return result;\n\t    }\n\t  }, {\n\t    key: \"createSvgTree\",\n\t    value: function createSvgTree(ctxt) {\n\t      this.updateBounds();\n\t      var result = this.annotations.map(function (annotation) {\n\t        return annotation.createSvgTree(ctxt);\n\t      });\n\t      this.updateBounds(-1);\n\t      return { children: result };\n\t    }\n\t  }, {\n\t    key: \"createSvgFragment\",\n\t    value: function createSvgFragment(ctxt) {\n\t      this.updateBounds();\n\t      var result = this.annotations.map(function (annotation) {\n\t        return annotation.createSvgFragment(ctxt);\n\t      }).join(\"\");\n\t      this.updateBounds(-1);\n\t      return result;\n\t    }\n\t  }]);\n\t\n\t  return Annotations;\n\t}(ChantLayoutElement);\n\t\n\tvar ChantNotationElement = exports.ChantNotationElement = function (_ChantLayoutElement10) {\n\t  _inherits(ChantNotationElement, _ChantLayoutElement10);\n\t\n\t  function ChantNotationElement() {\n\t    _classCallCheck(this, ChantNotationElement);\n\t\n\t    //double\n\t    var _this26 = _possibleConstructorReturn(this, (ChantNotationElement.__proto__ || Object.getPrototypeOf(ChantNotationElement)).call(this));\n\t\n\t    _this26.leadingSpace = 0.0;\n\t    _this26.trailingSpace = DefaultTrailingSpace;\n\t    _this26.keepWithNext = false;\n\t    _this26.needsLayout = true;\n\t\n\t    _this26.lyrics = [];\n\t\n\t    /**\n\t     * @type {ChantScore}\n\t     */\n\t    _this26.score = null; // the ChantScore\n\t\n\t    /**\n\t     * @type {ChantLine}\n\t     */\n\t    _this26.line = null; // the ChantLine\n\t\n\t    _this26.visualizers = [];\n\t    return _this26;\n\t  }\n\t\n\t  _createClass(ChantNotationElement, [{\n\t    key: \"hasLyrics\",\n\t    value: function hasLyrics() {\n\t      return this.lyrics.length !== 0;\n\t    }\n\t  }, {\n\t    key: \"getAllLyricsLeft\",\n\t    value: function getAllLyricsLeft() {\n\t      if (this.lyrics.length === 0) return this.bounds.right();\n\t\n\t      var x = Number.MAX_VALUE;\n\t      for (var i = 0; i < this.lyrics.length; i++) {\n\t        if (this.lyrics[i]) x = Math.min(x, this.lyrics[i].bounds.x);\n\t      }\n\t\n\t      return this.bounds.x + x;\n\t    }\n\t  }, {\n\t    key: \"getAllLyricsRight\",\n\t    value: function getAllLyricsRight() {\n\t      if (this.lyrics.length === 0) return this.bounds.x;\n\t\n\t      var x = Number.MIN_VALUE;\n\t      for (var i = 0; i < this.lyrics.length; i++) {\n\t        if (this.lyrics[i]) x = Math.max(x, this.lyrics[i].bounds.x + this.lyrics[i].bounds.width);\n\t      }\n\t\n\t      return this.bounds.x + x;\n\t    }\n\t\n\t    // used by subclasses while building up the chant notations.\n\t\n\t  }, {\n\t    key: \"addVisualizer\",\n\t    value: function addVisualizer(chantLayoutElement) {\n\t      if (!chantLayoutElement.ignoreBounds) {\n\t        if (this.bounds.isEmpty()) this.bounds = chantLayoutElement.bounds.clone();else this.bounds.union(chantLayoutElement.bounds);\n\t      }\n\t\n\t      this.visualizers.push(chantLayoutElement);\n\t    }\n\t\n\t    // same as addVisualizer, except the element is unshifted to the front\n\t    // of the visualizer array rather than the end. This way, some\n\t    // visualizers can be placed behind the others...ledger lines for example.\n\t\n\t  }, {\n\t    key: \"prependVisualizer\",\n\t    value: function prependVisualizer(chantLayoutElement) {\n\t      if (this.bounds.isEmpty()) this.bounds = chantLayoutElement.bounds.clone();else this.bounds.union(chantLayoutElement.bounds);\n\t\n\t      this.visualizers.unshift(chantLayoutElement);\n\t    }\n\t\n\t    // chant notation elements are given an opportunity to perform their layout via this function.\n\t    // subclasses should call this function first in overrides of this function.\n\t    // on completion, exsurge presumes that the bounds, the origin, and the fragment objects are\n\t    // all valid and prepared for higher level layout.\n\t\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      if (typeof this.trailingSpace === \"function\") this.calculatedTrailingSpace = this.trailingSpace(ctxt);else this.calculatedTrailingSpace = this.trailingSpace;\n\t\n\t      // reset the bounds and the staff notations before doing a layout\n\t      this.visualizers = [];\n\t      this.bounds = new _ExsurgeCore.Rect(Infinity, Infinity, -Infinity, -Infinity);\n\t\n\t      for (var i = 0; i < this.lyrics.length; i++) {\n\t        this.lyrics[i].recalculateMetrics(ctxt);\n\t      }if (this.alText) for (i = 0; i < this.alText.length; i++) {\n\t        this.alText[i].recalculateMetrics(ctxt);\n\t      }if (this.translationText) for (i = 0; i < this.translationText.length; i++) {\n\t        this.translationText[i].recalculateMetrics(ctxt);\n\t      }\n\t    }\n\t\n\t    // some subclasses have internal dependencies on other notations (for example,\n\t    // a custos can depend on a later neume which it uses to set its height).\n\t    // subclasses can override this function so that when the notations are\n\t    // altered, the subclass can correctly invalidate (and later restore) its own\n\t    // depedencies\n\t\n\t  }, {\n\t    key: \"resetDependencies\",\n\t    value: function resetDependencies() {}\n\t\n\t    // a helper function for subclasses to call after they are done performing layout...\n\t\n\t  }, {\n\t    key: \"finishLayout\",\n\t    value: function finishLayout(ctxt) {\n\t      var _this27 = this;\n\t\n\t      this.bounds.x = 0;\n\t\n\t      var language = this.lyrics[0] && this.lyrics[0].language || ctxt.defaultLanguage;\n\t      // center the neume itself over the syllable, or just the first punctum\n\t      // if the neume is wider than the syllable + the width of a punctum, we always revert to centering just over the punctum\n\t      var calculateLyricX = language.centerNeume ? function (lyric) {\n\t        return lyric.bounds.x = _this27.bounds.width + ctxt.staffInterval < lyric.vowelSegmentWidth ? _this27.bounds.width / 2 - lyric.origin.x : _this27.origin.x - lyric.origin.x;\n\t      } : function (lyric) {\n\t        return lyric.bounds.x = _this27.origin.x - lyric.origin.x;\n\t      };\n\t      this.lyrics.forEach(calculateLyricX);\n\t\n\t      this.needsLayout = false;\n\t    }\n\t  }, {\n\t    key: \"draw\",\n\t    value: function draw(ctxt) {\n\t      var canvasCtxt = ctxt.canvasCtxt;\n\t      canvasCtxt.translate(this.bounds.x, 0);\n\t\n\t      for (var i = 0; i < this.visualizers.length; i++) {\n\t        this.visualizers[i].draw(ctxt);\n\t      }for (i = 0; i < this.lyrics.length; i++) {\n\t        this.lyrics[i].draw(ctxt);\n\t      }if (this.translationText) for (i = 0; i < this.translationText.length; i++) {\n\t        this.translationText[i].draw(ctxt);\n\t      }if (this.alText) for (i = 0; i < this.alText.length; i++) {\n\t        this.alText[i].draw(ctxt);\n\t      }canvasCtxt.translate(-this.bounds.x, 0);\n\t    }\n\t  }, {\n\t    key: \"getInnerSvgNodes\",\n\t    value: function getInnerSvgNodes(ctxt) {\n\t      var functionName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"createSvgNode\";\n\t\n\t      var inner = [];\n\t\n\t      for (i = 0; i < this.lyrics.length; i++) {\n\t        inner.push(this.lyrics[i][functionName](ctxt));\n\t      }if (this.translationText) for (i = 0; i < this.translationText.length; i++) {\n\t        inner.push(this.translationText[i][functionName](ctxt));\n\t      }if (this.alText) for (i = 0; i < this.alText.length; i++) {\n\t        inner.push(this.alText[i][functionName](ctxt));\n\t      }if (this.visualizers.length) {\n\t        var visualizers = [];\n\t        for (var i = 0; i < this.visualizers.length; i++) {\n\t          visualizers.push(this.visualizers[i][functionName](ctxt, this));\n\t        }if (functionName === \"createSvgTree\") {\n\t          inner.push(QuickSvg.createSvgTree.apply(QuickSvg, [\"g\", { class: \"Notations\" }].concat(visualizers)));\n\t        } else {\n\t          inner.push(QuickSvg.createNode(\"g\", { class: \"Notations\" }, visualizers));\n\t        }\n\t      }\n\t      return inner;\n\t    }\n\t  }, {\n\t    key: \"getSvgProps\",\n\t    value: function getSvgProps() {\n\t      return {\n\t        // this.constructor.name will not be the same after being mangled by UglifyJS\n\t        class: \"ChantNotationElement \" + (this.cssClass || this.constructor.name),\n\t        transform: \"translate(\" + this.bounds.x + \",\" + 0 + \")\"\n\t      };\n\t    }\n\t  }, {\n\t    key: \"createSvgNode\",\n\t    value: function createSvgNode(ctxt) {\n\t      var inner = this.getInnerSvgNodes(ctxt, \"createSvgNode\");\n\t      var svgProps = this.getSvgProps();\n\t      svgProps.source = this;\n\t      return QuickSvg.createNode(\"g\", svgProps, inner);\n\t    }\n\t  }, {\n\t    key: \"createSvgTree\",\n\t    value: function createSvgTree(ctxt) {\n\t      var inner = this.getInnerSvgNodes(ctxt, \"createSvgTree\");\n\t      var svgProps = this.getSvgProps();\n\t      svgProps.source = this;\n\t      return QuickSvg.createSvgTree.apply(QuickSvg, [\"g\", svgProps].concat(_toConsumableArray(inner)));\n\t    }\n\t  }, {\n\t    key: \"createSvgFragment\",\n\t    value: function createSvgFragment(ctxt) {\n\t      var inner = \"\";\n\t\n\t      for (i = 0; i < this.lyrics.length; i++) {\n\t        inner += this.lyrics[i].createSvgFragment(ctxt);\n\t      }if (this.translationText) for (i = 0; i < this.translationText.length; i++) {\n\t        inner += this.translationText[i].createSvgFragment(ctxt);\n\t      }if (this.alText) for (i = 0; i < this.alText.length; i++) {\n\t        inner += this.alText[i].createSvgFragment(ctxt);\n\t      }for (var i = 0; i < this.visualizers.length; i++) {\n\t        inner += this.visualizers[i].createSvgFragment(ctxt, this);\n\t      }return QuickSvg.createFragment(\"g\", this.getSvgProps(), inner);\n\t    }\n\t  }]);\n\t\n\t  return ChantNotationElement;\n\t}(ChantLayoutElement);\n\t\n\tvar __connectorSpan = new TextSpan(\" • \");\n\tvar __mergeAnnotationWithTextLeft = function __mergeAnnotationWithTextLeft() {\n\t  for (var _len3 = arguments.length, annotationSpans = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n\t    annotationSpans[_key3] = arguments[_key3];\n\t  }\n\t\n\t  return annotationSpans.reduce(function (result, spans) {\n\t    if (result && result.length) {\n\t      if (spans && spans.length) return result.concat(__connectorSpan, spans);else return result;\n\t    } else if (spans && spans.length) {\n\t      return spans;\n\t    }\n\t    return [];\n\t  });\n\t};\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar addAccent = exports.addAccent = function addAccent(vowel) {\n\t  return {\n\t    \"Æ\": \"Ǽ\",\n\t    \"Œ\": \"Œ́\",\n\t    \"A\": \"Á\",\n\t    \"E\": \"É\",\n\t    \"I\": \"Í\",\n\t    \"O\": \"Ó\",\n\t    \"U\": \"Ú\",\n\t    \"Y\": \"Ý\",\n\t    \"æ\": \"ǽ\",\n\t    \"œ\": \"œ́\",\n\t    \"a\": \"á\",\n\t    \"e\": \"é\",\n\t    \"i\": \"í\",\n\t    \"o\": \"ó\",\n\t    \"u\": \"ú\",\n\t    \"y\": \"ý\"\n\t  }[vowel] || vowel;\n\t};\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar makeLigature = exports.makeLigature = function makeLigature(vowels) {\n\t  return {\n\t    AE: \"Æ\",\n\t    Ae: \"Æ\",\n\t    ae: \"æ\",\n\t    OE: \"Œ\",\n\t    Oe: \"Œ\",\n\t    oe: \"œ\"\n\t  }[vowels] || vowels;\n\t};\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar greextraGlyphs = exports.greextraGlyphs = {\n\t  MedicaeaFlat: \"\",\n\t  HufnagelCustosUpShort: \"\",\n\t  HufnagelCustosUpLong: \"\",\n\t  HufnagelCustosUpMedium: \"\",\n\t  HufnagelCustosDownShort: \"\",\n\t  HufnagelCustosDownLong: \"\",\n\t  HufnagelCustosDownMedium: \"\",\n\t  MedicaeaCustosUpShort: \"\",\n\t  MedicaeaCustosUpLong: \"\",\n\t  MedicaeaCustosUpMedium: \"\",\n\t  MedicaeaCustosDownShort: \"\",\n\t  MedicaeaCustosDownLong: \"\",\n\t  MedicaeaCustosDownMedium: \"\",\n\t  MensuralCustosUpShort: \"\",\n\t  MensuralCustosUpLong: \"\",\n\t  MensuralCustosUpMedium: \"\",\n\t  MensuralCustosDownShort: \"\",\n\t  MensuralCustosDownLong: \"\",\n\t  MensuralCustosDownMedium: \"\",\n\t  MensuralFlat: \"\",\n\t  HufnagelFlat: \"\",\n\t  MedicaeaCClef: \"\",\n\t  MedicaeaCClefChange: \"\",\n\t  MedicaeaFClef: \"\",\n\t  MedicaeaFClefChange: \"\",\n\t  HufnagelCClef: \"\",\n\t  HufnagelCClefChange: \"\",\n\t  HufnagelFClef: \"\",\n\t  HufnagelFClefChange: \"\",\n\t  HugnagelCFClef: \"\",\n\t  HufnagelCFClefChange: \"\",\n\t  MensuralFlatHole: \"\",\n\t  HufnagelFlatHole: \"\",\n\t  MedicaeaFlatHole: \"\",\n\t  StarSix: \"\",\n\t  Dagger: \"\",\n\t  \"Bar.alt\": \"\",\n\t  StarHeight: \"\",\n\t  Cross: \"\",\n\t  \"RBar.alt\": \"\",\n\t  \"VBar.alt\": \"\",\n\t  Drawing1: \"\",\n\t  Drawing2: \"\",\n\t  RWithBarGoth: \"\",\n\t  VWithBarGoth: \"\",\n\t  Line1: \"\",\n\t  Line2: \"\",\n\t  Line3: \"\",\n\t  Line4: \"\",\n\t  Line5: \"\",\n\t  \"Cross.alt\": \"\",\n\t  ABarCaption: \"\",\n\t  RBarCaption: \"\",\n\t  VBarCaption: \"\",\n\t  ABarCaptionSC: \"\",\n\t  RBarCaptionSC: \"\",\n\t  VBarCaptionSC: \"\",\n\t  ABar: \"\",\n\t  RBar: \"\",\n\t  VBar: \"\",\n\t  ABarSC: \"\",\n\t  RBarSC: \"\",\n\t  VBarSC: \"\",\n\t  ABarSmall: \"\",\n\t  RBarSmall: \"\",\n\t  VBarSmall: \"\",\n\t  ABarSmallSC: \"\",\n\t  RBarSmallSC: \"\",\n\t  VBarSmallSC: \"\",\n\t  \"RBar.alt2\": \"\",\n\t  \"VBar.alt2\": \"\",\n\t  ABarCaptionSlant: \"\",\n\t  RBarCaptionSlant: \"\",\n\t  VBarCaptionSlant: \"\",\n\t  ABarSlant: \"\",\n\t  RBarSlant: \"\",\n\t  VBarSlant: \"\",\n\t  ABarSmallSlant: \"\",\n\t  RBarSmallSlant: \"\",\n\t  VBarSmallSlant: \"\"\n\t};\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.ChantDocument = exports.ChantScore = exports.ChantMapping = exports.ChantLineBreak = exports.TextOnly = exports.TrebleClef = exports.FaClef = exports.DoClef = exports.Clef = exports.Note = exports.NoteShapeModifiers = exports.NoteShape = exports.LiquescentType = undefined;\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _ExsurgeChantChantLine = __webpack_require__(9);\n\t\n\tvar _ExsurgeChantSigns = __webpack_require__(11);\n\t\n\tvar _ExsurgeCore = __webpack_require__(1);\n\t\n\tvar _ExsurgeDrawing = __webpack_require__(4);\n\t\n\tvar _ExsurgeGabc = __webpack_require__(12);\n\t\n\tvar _ExsurgeTitles = __webpack_require__(14);\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //\n\t// Author(s):\n\t// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>\n\t//\n\t// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a copy\n\t// of this software and associated documentation files (the \"Software\"), to deal\n\t// in the Software without restriction, including without limitation the rights\n\t// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\t// copies of the Software, and to permit persons to whom the Software is\n\t// furnished to do so, subject to the following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included in\n\t// all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\t// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\t// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\t// THE SOFTWARE.\n\t//\n\t\n\tvar LiquescentType = exports.LiquescentType = {\n\t  None: 0,\n\t\n\t  // flags that can be combined, though of course it\n\t  // it doesn't make sense to combine some!\n\t  Large: 1 << 0,\n\t  Small: 1 << 1,\n\t  Ascending: 1 << 2,\n\t  Descending: 1 << 3,\n\t  InitioDebilis: 1 << 4,\n\t\n\t  // handy liquescent types\n\t  LargeAscending: 1 << 0 | 1 << 2,\n\t  LargeDescending: 1 << 0 | 1 << 3,\n\t  SmallAscending: 1 << 1 | 1 << 2,\n\t  SmallDescending: 1 << 1 | 1 << 3\n\t};\n\t\n\tvar NoteShape = exports.NoteShape = {\n\t  // shapes\n\t  Default: 0,\n\t  Virga: 1,\n\t  Inclinatum: 2,\n\t  Quilisma: 3,\n\t  Stropha: 4,\n\t  Oriscus: 5\n\t};\n\t\n\tvar NoteShapeModifiers = exports.NoteShapeModifiers = {\n\t  // flags which modify the shape\n\t  // not all of them apply to every shape of course\n\t  None: 0,\n\t  Ascending: 1 << 0,\n\t  Descending: 1 << 1,\n\t  Cavum: 1 << 2,\n\t  Stemmed: 1 << 3,\n\t  Linea: 1 << 4,\n\t  Reverse: 1 << 5\n\t};\n\t\n\t/**\n\t * @class\n\t */\n\t\n\tvar Note = exports.Note = function (_ChantLayoutElement) {\n\t  _inherits(Note, _ChantLayoutElement);\n\t\n\t  /**\n\t   * @para {Pitch} pitch\n\t   */\n\t  function Note(pitch) {\n\t    _classCallCheck(this, Note);\n\t\n\t    var _this = _possibleConstructorReturn(this, (Note.__proto__ || Object.getPrototypeOf(Note)).call(this));\n\t\n\t    if (typeof pitch !== \"undefined\") _this.pitch = pitch;else _this.pitch = null;\n\t\n\t    _this.glyphVisualizer = null;\n\t\n\t    // The staffPosition on a note is an integer that indicates the vertical position on the staff.\n\t    // 0 is the space just below the lowest line on the staff (equivalent to gabc 'c'). Positive numbers go up\n\t    // the staff, and negative numbers go down, i.e., 1 is gabc 'd', 2 is gabc 'e', -1 is gabc 'b', etc.\n\t    _this.staffPosition = 4;\n\t    _this.liquescent = LiquescentType.None;\n\t    _this.shape = NoteShape.Default;\n\t    _this.shapeModifiers = NoteShapeModifiers.None;\n\t\n\t    // notes keep track of the neume they belong to in order to facilitate layout\n\t    // this.neume gets set when a note is added to a neume via Neume.addNote()\n\t    _this.neume = null;\n\t\n\t    // various markings that can exist on a note, organized by type\n\t    // for faster access and simpler code logic\n\t    _this.episemata = [];\n\t    _this.morae = []; // silly to have an array of these, but gabc allows multiple morae per note!\n\t\n\t    // these are set on the note when they are needed, otherwise, they're undefined\n\t    // this.ictus\n\t    // this.accuteAccent\n\t    // this.braceStart\n\t    // this.braceEnd\n\t    return _this;\n\t  }\n\t\n\t  _createClass(Note, [{\n\t    key: \"setGlyph\",\n\t    value: function setGlyph(ctxt, glyphCode) {\n\t      if (this.glyphVisualizer) this.glyphVisualizer.setGlyph(ctxt, glyphCode);else this.glyphVisualizer = new _ExsurgeDrawing.GlyphVisualizer(ctxt, glyphCode);\n\t\n\t      this.glyphVisualizer.setStaffPosition(ctxt, this.staffPosition);\n\t\n\t      // assign glyphvisualizer metrics to this note\n\t      this.bounds.x = this.glyphVisualizer.bounds.x;\n\t      this.bounds.y = this.glyphVisualizer.bounds.y;\n\t      this.bounds.width = this.glyphVisualizer.bounds.width;\n\t      this.bounds.height = this.glyphVisualizer.bounds.height;\n\t\n\t      this.origin.x = this.glyphVisualizer.origin.x;\n\t      this.origin.y = this.glyphVisualizer.origin.y;\n\t    }\n\t\n\t    // a utility function for modifiers\n\t\n\t  }, {\n\t    key: \"shapeModifierMatches\",\n\t    value: function shapeModifierMatches(shapeModifier) {\n\t      if (shapeModifier === NoteShapeModifiers.None) return this.shapeModifier === NoteShapeModifiers.None;else return this.shapeModifier & shapeModifier !== 0;\n\t    }\n\t  }, {\n\t    key: \"draw\",\n\t    value: function draw(ctxt) {\n\t      this.glyphVisualizer.bounds.x = this.bounds.x;\n\t      this.glyphVisualizer.bounds.y = this.bounds.y;\n\t\n\t      this.glyphVisualizer.draw(ctxt);\n\t    }\n\t  }, {\n\t    key: \"createSvgNode\",\n\t    value: function createSvgNode(ctxt) {\n\t      this.glyphVisualizer.bounds.x = this.bounds.x;\n\t      this.glyphVisualizer.bounds.y = this.bounds.y;\n\t      this.svgNode = this.glyphVisualizer.createSvgNode(ctxt, this);\n\t      return this.svgNode;\n\t    }\n\t  }, {\n\t    key: \"createSvgTree\",\n\t    value: function createSvgTree(ctxt) {\n\t      this.glyphVisualizer.bounds.x = this.bounds.x;\n\t      this.glyphVisualizer.bounds.y = this.bounds.y;\n\t      return this.glyphVisualizer.createSvgTree(ctxt, this);\n\t    }\n\t  }, {\n\t    key: \"createSvgFragment\",\n\t    value: function createSvgFragment(ctxt) {\n\t      this.glyphVisualizer.bounds.x = this.bounds.x;\n\t      this.glyphVisualizer.bounds.y = this.bounds.y;\n\t      return this.glyphVisualizer.createSvgFragment(ctxt, this);\n\t    }\n\t  }]);\n\t\n\t  return Note;\n\t}(_ExsurgeDrawing.ChantLayoutElement);\n\t\n\tvar Clef = exports.Clef = function (_ChantNotationElement) {\n\t  _inherits(Clef, _ChantNotationElement);\n\t\n\t  function Clef(staffPosition, octave) {\n\t    var defaultAccidental = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t\n\t    _classCallCheck(this, Clef);\n\t\n\t    var _this2 = _possibleConstructorReturn(this, (Clef.__proto__ || Object.getPrototypeOf(Clef)).call(this));\n\t\n\t    _this2.isClef = true;\n\t    _this2.staffPosition = staffPosition;\n\t    _this2.octave = octave;\n\t    _this2.defaultAccidental = defaultAccidental;\n\t    _this2.activeAccidental = defaultAccidental;\n\t    _this2.keepWithNext = true;\n\t    return _this2;\n\t  }\n\t\n\t  _createClass(Clef, [{\n\t    key: \"resetAccidentals\",\n\t    value: function resetAccidentals() {\n\t      this.activeAccidental = this.defaultAccidental;\n\t    }\n\t  }, {\n\t    key: \"pitchToStaffPosition\",\n\t    value: function pitchToStaffPosition(pitch) {}\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      ctxt.activeClef = this;\n\t\n\t      if (this.defaultAccidental) this.defaultAccidental.performLayout(ctxt);\n\t\n\t      _get(Clef.prototype.__proto__ || Object.getPrototypeOf(Clef.prototype), \"performLayout\", this).call(this, ctxt);\n\t    }\n\t  }, {\n\t    key: \"finishLayout\",\n\t    value: function finishLayout(ctxt) {\n\t      // if we have a default accidental, then add a glyph for it now\n\t      if (this.defaultAccidental) {\n\t        var accidentalGlyph = this.defaultAccidental.createGlyphVisualizer(ctxt);\n\t        accidentalGlyph.bounds.x += this.visualizers[0].bounds.right() + ctxt.intraNeumeSpacing;\n\t        this.addVisualizer(accidentalGlyph);\n\t      }\n\t\n\t      _get(Clef.prototype.__proto__ || Object.getPrototypeOf(Clef.prototype), \"finishLayout\", this).call(this, ctxt);\n\t    }\n\t  }, {\n\t    key: \"clone\",\n\t    value: function clone() {\n\t      if (this.model) return this.model.clone();\n\t      var clone = new this.constructor(this.staffPosition, this.octave, this.defaultAccidental);\n\t      clone.small = this.small;\n\t      clone.sourceGabc = this.sourceGabc;\n\t      clone.sourceIndex = this.sourceIndex;\n\t      clone.elementIndex = this.elementIndex;\n\t      clone.model = this;\n\t      return clone;\n\t    }\n\t  }], [{\n\t    key: \"default\",\n\t    value: function _default() {\n\t      return __defaultDoClef;\n\t    }\n\t  }]);\n\t\n\t  return Clef;\n\t}(_ExsurgeDrawing.ChantNotationElement);\n\t\n\tvar DoClef = exports.DoClef = function (_Clef) {\n\t  _inherits(DoClef, _Clef);\n\t\n\t  function DoClef(staffPosition, octave) {\n\t    var defaultAccidental = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t\n\t    _classCallCheck(this, DoClef);\n\t\n\t    var _this3 = _possibleConstructorReturn(this, (DoClef.__proto__ || Object.getPrototypeOf(DoClef)).call(this, staffPosition, octave, defaultAccidental));\n\t\n\t    _this3.leadingSpace = 0;\n\t    return _this3;\n\t  }\n\t\n\t  _createClass(DoClef, [{\n\t    key: \"pitchToStaffPosition\",\n\t    value: function pitchToStaffPosition(pitch) {\n\t      return (pitch.octave - this.octave) * 7 + this.staffPosition + _ExsurgeCore.Pitch.stepToStaffOffset(pitch.step) - _ExsurgeCore.Pitch.stepToStaffOffset(_ExsurgeCore.Step.Do);\n\t    }\n\t  }, {\n\t    key: \"staffPositionToPitch\",\n\t    value: function staffPositionToPitch(staffPosition) {\n\t      var offset = staffPosition - this.staffPosition;\n\t      var octaveOffset = Math.floor(offset / 7);\n\t\n\t      var step = _ExsurgeCore.Pitch.staffOffsetToStep(offset);\n\t\n\t      if (this.activeAccidental && this.activeAccidental.staffPosition === staffPosition) step += this.activeAccidental.accidentalType;\n\t\n\t      return new _ExsurgeCore.Pitch(step, this.octave + octaveOffset);\n\t    }\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(DoClef.prototype.__proto__ || Object.getPrototypeOf(DoClef.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      var glyph = new _ExsurgeDrawing.GlyphVisualizer(ctxt, _ExsurgeDrawing.GlyphCode.DoClef);\n\t      glyph.setStaffPosition(ctxt, this.staffPosition);\n\t      this.addVisualizer(glyph);\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return DoClef;\n\t}(Clef);\n\t\n\tvar __defaultDoClef = new DoClef(7, 2);\n\t\n\tvar FaClef = exports.FaClef = function (_Clef2) {\n\t  _inherits(FaClef, _Clef2);\n\t\n\t  function FaClef(staffPosition, octave) {\n\t    var defaultAccidental = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t\n\t    _classCallCheck(this, FaClef);\n\t\n\t    var _this4 = _possibleConstructorReturn(this, (FaClef.__proto__ || Object.getPrototypeOf(FaClef)).call(this, staffPosition, octave, defaultAccidental));\n\t\n\t    _this4.leadingSpace = 0;\n\t    return _this4;\n\t  }\n\t\n\t  _createClass(FaClef, [{\n\t    key: \"pitchToStaffPosition\",\n\t    value: function pitchToStaffPosition(pitch) {\n\t      return (pitch.octave - this.octave) * 7 + this.staffPosition + _ExsurgeCore.Pitch.stepToStaffOffset(pitch.step) - _ExsurgeCore.Pitch.stepToStaffOffset(_ExsurgeCore.Step.Fa);\n\t    }\n\t  }, {\n\t    key: \"staffPositionToPitch\",\n\t    value: function staffPositionToPitch(staffPosition) {\n\t      var offset = staffPosition - this.staffPosition + 3; // + 3 because it's a fa clef (3 == offset from Do)\n\t      var octaveOffset = Math.floor(offset / 7);\n\t\n\t      var step = _ExsurgeCore.Pitch.staffOffsetToStep(offset);\n\t\n\t      if (this.activeAccidental && this.activeAccidental.staffPosition === staffPosition) step += this.activeAccidental.accidentalType;\n\t\n\t      return new _ExsurgeCore.Pitch(step, this.octave + octaveOffset);\n\t    }\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(FaClef.prototype.__proto__ || Object.getPrototypeOf(FaClef.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      var glyph = new _ExsurgeDrawing.GlyphVisualizer(ctxt, _ExsurgeDrawing.GlyphCode.FaClef);\n\t      glyph.setStaffPosition(ctxt, this.staffPosition);\n\t      this.addVisualizer(glyph);\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return FaClef;\n\t}(Clef);\n\t\n\tvar TrebleClef = exports.TrebleClef = function (_Clef3) {\n\t  _inherits(TrebleClef, _Clef3);\n\t\n\t  function TrebleClef(staffPosition, octave) {\n\t    var defaultAccidental = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t    var small = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\t\n\t    _classCallCheck(this, TrebleClef);\n\t\n\t    var _this5 = _possibleConstructorReturn(this, (TrebleClef.__proto__ || Object.getPrototypeOf(TrebleClef)).call(this, staffPosition, octave, defaultAccidental));\n\t\n\t    _this5.leadingSpace = 0;\n\t    _this5.small = small;\n\t    return _this5;\n\t  }\n\t\n\t  _createClass(TrebleClef, [{\n\t    key: \"pitchToStaffPosition\",\n\t    value: function pitchToStaffPosition(pitch) {\n\t      return (pitch.octave - this.octave) * 7 + this.staffPosition + _ExsurgeCore.Pitch.stepToStaffOffset(pitch.step) - _ExsurgeCore.Pitch.stepToStaffOffset(_ExsurgeCore.Step.So);\n\t    }\n\t  }, {\n\t    key: \"staffPositionToPitch\",\n\t    value: function staffPositionToPitch(staffPosition) {\n\t      var offset = staffPosition - this.staffPosition + 4; // + 4 because it's a sol clef (4 == offset from Do)\n\t      var octaveOffset = Math.floor(offset / 7);\n\t\n\t      var step = _ExsurgeCore.Pitch.staffOffsetToStep(offset);\n\t\n\t      if (this.activeAccidental && this.activeAccidental.staffPosition === staffPosition) step += this.activeAccidental.accidentalType;\n\t\n\t      return new _ExsurgeCore.Pitch(step, this.octave + octaveOffset);\n\t    }\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(TrebleClef.prototype.__proto__ || Object.getPrototypeOf(TrebleClef.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      var glyph = new _ExsurgeDrawing.GlyphVisualizer(ctxt, this.small ? _ExsurgeDrawing.GlyphCode.TrebleClefSmall : _ExsurgeDrawing.GlyphCode.TrebleClef);\n\t      glyph.setStaffPosition(ctxt, this.staffPosition);\n\t      this.addVisualizer(glyph);\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return TrebleClef;\n\t}(Clef);\n\t\n\t/*\n\t * TextOnly\n\t */\n\t\n\t\n\tvar TextOnly = exports.TextOnly = function (_ChantNotationElement2) {\n\t  _inherits(TextOnly, _ChantNotationElement2);\n\t\n\t  function TextOnly(sourceIndex, sourceLength) {\n\t    _classCallCheck(this, TextOnly);\n\t\n\t    var _this6 = _possibleConstructorReturn(this, (TextOnly.__proto__ || Object.getPrototypeOf(TextOnly)).call(this));\n\t\n\t    _this6.sourceIndex = sourceIndex;\n\t    _this6.sourceLength = sourceLength;\n\t    _this6.sourceGabc = \"\";\n\t    _this6.trailingSpace = 0;\n\t    return _this6;\n\t  }\n\t\n\t  _createClass(TextOnly, [{\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(TextOnly.prototype.__proto__ || Object.getPrototypeOf(TextOnly.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      // add an empty glyph as a placeholder\n\t      this.addVisualizer(new _ExsurgeDrawing.GlyphVisualizer(ctxt, _ExsurgeDrawing.GlyphCode.None));\n\t\n\t      this.origin.x = 0;\n\t      this.origin.y = -ctxt.staffInterval;\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return TextOnly;\n\t}(_ExsurgeDrawing.ChantNotationElement);\n\t\n\tvar ChantLineBreak = exports.ChantLineBreak = function (_ChantNotationElement3) {\n\t  _inherits(ChantLineBreak, _ChantNotationElement3);\n\t\n\t  function ChantLineBreak(justify) {\n\t    _classCallCheck(this, ChantLineBreak);\n\t\n\t    var _this7 = _possibleConstructorReturn(this, (ChantLineBreak.__proto__ || Object.getPrototypeOf(ChantLineBreak)).call(this));\n\t\n\t    _this7.calculatedTrailingSpace = _this7.trailingSpace = 0;\n\t    _this7.justify = justify;\n\t    return _this7;\n\t  }\n\t\n\t  _createClass(ChantLineBreak, [{\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      // reset the bounds before doing a layout\n\t      this.bounds = new _ExsurgeCore.Rect(0, 0, 0, 0);\n\t    }\n\t  }, {\n\t    key: \"clone\",\n\t    value: function clone() {\n\t      var lb = new ChantLineBreak();\n\t      lb.justify = this.justify;\n\t\n\t      return lb;\n\t    }\n\t  }]);\n\t\n\t  return ChantLineBreak;\n\t}(_ExsurgeDrawing.ChantNotationElement);\n\t\n\t// a chant mapping is a lightweight format independent way of\n\t// tracking how a chant language (e.g., gabc) has been\n\t// mapped to exsurge notations.\n\t\n\t\n\tvar ChantMapping =\n\t// source can be any object type. in the case of gabc, source is a text\n\t// string that maps to a gabc word (e.g.: \"no(g)bis(fg)\").\n\t// notations is an array of ChantNotationElements\n\texports.ChantMapping = function ChantMapping(source, notations, sourceIndex) {\n\t  _classCallCheck(this, ChantMapping);\n\t\n\t  this.source = source;\n\t  this.notations = notations;\n\t  this.sourceIndex = sourceIndex;\n\t};\n\t\n\t/*\n\t * Score, document\n\t */\n\t\n\t\n\tvar ChantScore = exports.ChantScore = function () {\n\t  // mappings is an array of ChantMappings.\n\t  function ChantScore(ctxt) {\n\t    var mappings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\t    var useDropCap = arguments[2];\n\t\n\t    _classCallCheck(this, ChantScore);\n\t\n\t    this.mappings = mappings;\n\t\n\t    this.lines = [];\n\t    this.notes = [];\n\t    this.staffLineCount = 4;\n\t    if (ctxt) this.titles = new _ExsurgeTitles.Titles(ctxt, this);\n\t\n\t    this.startingClef = null;\n\t\n\t    this.useDropCap = useDropCap;\n\t    this.dropCap = null;\n\t\n\t    this.annotation = null;\n\t\n\t    this.compiled = false;\n\t\n\t    this.autoColoring = true;\n\t    this.needsLayout = true;\n\t    this.extendLastSystemStaffLines = true;\n\t\n\t    // valid after chant lines are created...\n\t    this.bounds = new _ExsurgeCore.Rect();\n\t\n\t    if (ctxt) this.updateNotations(ctxt);\n\t  }\n\t\n\t  /**\n\t   * Make a copy of the score, only including the specified lines\n\t   * @param  {number} startLine starting index\n\t   * @param  {number} endLine   ending index\n\t   * @return {ChantScore}           the partial score\n\t   */\n\t\n\t\n\t  _createClass(ChantScore, [{\n\t    key: \"copyLines\",\n\t    value: function copyLines(startLine, endLine) {\n\t      var result = new ChantScore();\n\t      result.lines = this.lines.slice(startLine, endLine);\n\t      result.bounds = this.bounds.clone();\n\t      var lastLine = result.lines.slice(-1)[0];\n\t      result.bounds.height = lastLine.bounds.bottom() - lastLine.origin.y;\n\t      if (startLine === 0) {\n\t        result.titles = this.titles;\n\t        result.dropCap = this.dropCap;\n\t        result.annotation = this.annotation;\n\t      }\n\t      return result;\n\t    }\n\t  }, {\n\t    key: \"updateSelection\",\n\t    value: function updateSelection(selection) {\n\t      this.selection = selection;\n\t      var elementSelection = selection && selection.element || {\n\t        indices: []\n\t      };\n\t      var selectedIndices = elementSelection.indices;\n\t      var insertion = elementSelection.insertion;\n\t      if (!insertion && selectedIndices.length === 1 && this.notes[selectedIndices[0]] instanceof TextOnly) {\n\t        // if there is only one selection, and its a text only, it should display as an insertion cursor:\n\t        insertion = { afterElementIndex: selectedIndices[0] };\n\t      }\n\t      // update the selected elements so that they can be given a .selected class when rendered\n\t      for (var i = 0; i < this.notes.length; ++i) {\n\t        var element = this.notes[i];\n\t        element.selected = selectedIndices.includes(i);\n\t      }\n\t      (this.startingClef.model || this.startingClef).selected = selectedIndices.includes(-1);\n\t      for (var _i = 0; _i < this.lines.length; ++_i) {\n\t        this.lines[_i].insertionCursor = null;\n\t      }\n\t      // update the insertion cursor, so it can be drawn on the correct system\n\t      this.insertionElement = null;\n\t      var insertionLine = null;\n\t      if (insertion) {\n\t        if (typeof insertion.chantLine === \"number\") {\n\t          insertionLine = this.lines[insertion.chantLine];\n\t          this.insertionElement = insertionLine.startingClef;\n\t          insertionLine.insertionCursor = new _ExsurgeChantSigns.InsertionCursor();\n\t        } else if (typeof insertion.afterElementIndex === \"number\") {\n\t          this.insertionElement = this.notes[insertion.afterElementIndex];\n\t          if (!this.insertionElement) {\n\t            insertionLine = this.lines[0];\n\t            this.insertionElement = insertionLine.startingClef;\n\t          } else if (this.insertionElement.neume) {\n\t            this.insertionElement = this.insertionElement.neume;\n\t          }\n\t          if (!insertionLine) {\n\t            insertionLine = this.insertionElement.line || this.lines[this.lines.length - 1];\n\t          }\n\t          insertionLine.insertionCursor = new _ExsurgeChantSigns.InsertionCursor();\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: \"updateNotations\",\n\t    value: function updateNotations(ctxt) {\n\t      var i, j, mapping, notation;\n\t\n\t      // flatten all mappings into one array for N(0) access to notations\n\t      this.notations = [];\n\t      this.notes = [];\n\t      this.hasLyrics = false;\n\t      this.hasAboveLinesText = false;\n\t      this.hasTranslations = false;\n\t      var elementSelection = this.selection && this.selection.element || {\n\t        indices: []\n\t      };\n\t      var selectedIndices = elementSelection.indices;\n\t      var nonNoteElementCount = 0;\n\t\n\t      // find the starting clef...\n\t      // start with a default clef in case the notations don't provide one.\n\t      this.startingClef = null;\n\t\n\t      for (i = 0; i < this.mappings.length; i++) {\n\t        mapping = this.mappings[i];\n\t        for (j = 0; j < mapping.notations.length; j++) {\n\t          notation = mapping.notations[j];\n\t          notation.score = this;\n\t          notation.mapping = mapping;\n\t\n\t          if (!this.startingClef) {\n\t            if (notation.isNeume) {\n\t              this.startingClef = Clef.default();\n\t            } else if (notation.isClef) {\n\t              this.startingClef = notation;\n\t              continue;\n\t            }\n\t          }\n\t\n\t          notation.notationIndex = this.notations.push(notation) - 1;\n\t          if (!this.hasLyrics && notation.hasLyrics()) this.hasLyrics = true;\n\t          if (!this.hasAboveLinesText && notation.alText) this.hasAboveLinesText = true;\n\t          if (!this.hasTranslations && notation.translationText) this.hasTranslations = true;\n\t\n\t          // Update this.notes and find element indices:\n\t          var elements = notation.notes || [notation];\n\t          var _iteratorNormalCompletion = true;\n\t          var _didIteratorError = false;\n\t          var _iteratorError = undefined;\n\t\n\t          try {\n\t            for (var _iterator = elements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t              var element = _step.value;\n\t\n\t              var elementIndex = element.elementIndex = this.notes.push(element) - 1;\n\t              if (element instanceof Note) {\n\t                element.noteIndex = elementIndex - nonNoteElementCount;\n\t              } else {\n\t                ++nonNoteElementCount;\n\t              }\n\t\n\t              element.selected = selectedIndices.includes(elementIndex);\n\t            }\n\t          } catch (err) {\n\t            _didIteratorError = true;\n\t            _iteratorError = err;\n\t          } finally {\n\t            try {\n\t              if (!_iteratorNormalCompletion && _iterator.return) {\n\t                _iterator.return();\n\t              }\n\t            } finally {\n\t              if (_didIteratorError) {\n\t                throw _iteratorError;\n\t              }\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      // if we've reached this far and we *still* don't have a clef, then there aren't even\n\t      // any neumes in the score. still, set the default clef just for good measure\n\t      if (!this.startingClef) this.startingClef = Clef.default();\n\t      this.startingClef.elementIndex = -1;\n\t\n\t      // update drop cap\n\t      if (this.useDropCap) this.recreateDropCap(ctxt);else this.dropCap = null;\n\t\n\t      this.needsLayout = true;\n\t    }\n\t  }, {\n\t    key: \"recreateDropCap\",\n\t    value: function recreateDropCap(ctxt) {\n\t      this.dropCap = null;\n\t\n\t      // find the first notation with lyrics to use\n\t      for (var i = 0; i < this.notations.length; i++) {\n\t        if (this.notations[i].hasLyrics() && this.notations[i].lyrics[0] !== null && this.notations[i].lyrics[0].spans && this.notations[i].lyrics[0].spans.length) {\n\t          var notation = this.notations[i],\n\t              lyrics = notation.lyrics[0];\n\t          if (this.useDropCap) {\n\t            this.dropCap = lyrics.generateDropCap(ctxt);\n\t          } else {\n\t            lyrics.dropCap = null;\n\t            lyrics.generateSpansFromText(ctxt, lyrics.originalText);\n\t          }\n\t          notation.needsLayout = true;\n\t          return;\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Shared layout initialization method for performLayout() and performLayoutAsync()\n\t     * @param  {ChantContext} ctxt\n\t     */\n\t\n\t  }, {\n\t    key: \"initializeLayout\",\n\t    value: function initializeLayout(ctxt) {\n\t      // setup the context\n\t      ctxt.activeClef = this.startingClef;\n\t      ctxt.notations = this.notations;\n\t      ctxt.currNotationIndex = 0;\n\t      ctxt.staffLineCount = this.staffLineCount;\n\t\n\t      if (this.dropCap) this.dropCap.recalculateMetrics(ctxt);\n\t\n\t      if (this.annotation) this.annotation.recalculateMetrics(ctxt);\n\t    }\n\t\n\t    // this is the the synchronous version of performLayout that\n\t    // process everything without yielding to any other workers/threads.\n\t    // good for server side processing or very small chant pieces.\n\t\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt, force) {\n\t      if (!force && this.needsLayout === false) return; // nothing to do here!\n\t\n\t      ctxt.updateHyphenWidth();\n\t\n\t      this.initializeLayout(ctxt);\n\t\n\t      for (var i = 0; i < this.notations.length; i++) {\n\t        var notation = this.notations[i];\n\t        if (force || notation.needsLayout) {\n\t          ctxt.currNotationIndex = i;\n\t          notation.performLayout(ctxt);\n\t        }\n\t      }\n\t\n\t      this.needsLayout = false;\n\t    }\n\t\n\t    // for web applications, probably performLayoutAsync would be more\n\t    // apppropriate that the above performLayout, since it will process\n\t    // the notations without locking up the UI thread.\n\t\n\t  }, {\n\t    key: \"performLayoutAsync\",\n\t    value: function performLayoutAsync(ctxt, finishedCallback) {\n\t      var _this8 = this;\n\t\n\t      if (this.needsLayout === false) {\n\t        if (finishedCallback) setTimeout(function () {\n\t          return finishedCallback();\n\t        }, 0);\n\t\n\t        return; // nothing to do here!\n\t      }\n\t\n\t      if (ctxt.onFontLoaded) {\n\t        ctxt.onFontLoaded.push(function () {\n\t          return _this8.performLayoutAsync(ctxt, finishedCallback);\n\t        });\n\t        return;\n\t      }\n\t\n\t      // check for sane value of hyphen width:\n\t      ctxt.updateHyphenWidth();\n\t      if (!ctxt.hyphenWidth || ctxt.hyphenWidth / ctxt.textStyles.lyric.size > 0.6) {\n\t        setTimeout(function () {\n\t          _this8.performLayoutAsync(ctxt, finishedCallback);\n\t        }, 100);\n\t        return;\n\t      }\n\t\n\t      this.initializeLayout(ctxt);\n\t\n\t      setTimeout(function () {\n\t        return _this8.layoutElementsAsync(ctxt, 0, finishedCallback);\n\t      }, 0);\n\t    }\n\t  }, {\n\t    key: \"layoutElementsAsync\",\n\t    value: function layoutElementsAsync(ctxt, index, finishedCallback) {\n\t      var _this9 = this;\n\t\n\t      if (index >= this.notations.length) {\n\t        this.needsLayout = false;\n\t\n\t        if (finishedCallback) setTimeout(function () {\n\t          return finishedCallback();\n\t        }, 0);\n\t\n\t        return;\n\t      }\n\t\n\t      if (index === 0) ctxt.activeClef = this.startingClef;\n\t\n\t      var timeout = new Date().getTime() + 50; // process for fifty milliseconds\n\t      do {\n\t        var notation = this.notations[index];\n\t        if (notation.needsLayout) {\n\t          ctxt.currNotationIndex = index;\n\t          notation.performLayout(ctxt);\n\t        }\n\t\n\t        index++;\n\t      } while (index < this.notations.length && new Date().getTime() < timeout);\n\t\n\t      // schedule the next block of processing\n\t      setTimeout(function () {\n\t        return _this9.layoutElementsAsync(ctxt, index, finishedCallback);\n\t      }, 0);\n\t    }\n\t  }, {\n\t    key: \"layoutChantLines\",\n\t    value: function layoutChantLines(ctxt, width, finishedCallback) {\n\t      this.lines = [];\n\t\n\t      if (ctxt.mergeAnnotationWithTextLeft && this.annotation && !this.dropCap) {\n\t        var annotation = this.annotation,\n\t            annotationSpans = annotation.annotations ? annotation.annotations.map(function (annotation) {\n\t          return annotation.spans;\n\t        }) : [annotation.spans];\n\t        this.overrideTextLeft = new _ExsurgeDrawing.TextLeftRight(ctxt, \"\", \"textLeft\");\n\t        if (ctxt.mapAnnotationSpansToTextLeft) {\n\t          annotationSpans = annotationSpans.map(ctxt.mapAnnotationSpansToTextLeft);\n\t        }\n\t        this.overrideTextLeft.spans = ctxt.mergeAnnotationWithTextLeft.apply(ctxt, _toConsumableArray(annotationSpans).concat([this.titles.textLeft && this.titles.textLeft.spans]));\n\t      } else {\n\t        this.overrideTextLeft = null;\n\t      }\n\t\n\t      var y = width > 0 ? this.titles.layoutTitles(ctxt, width) : 0;\n\t      var currIndex = 0;\n\t\n\t      ctxt.activeClef = this.startingClef;\n\t\n\t      var spaceBetweenSystems = ctxt.staffInterval * ctxt.spaceBetweenSystems;\n\t\n\t      do {\n\t        var line = new _ExsurgeChantChantLine.ChantLine(this);\n\t\n\t        line.buildFromChantNotationIndex(ctxt, currIndex, width);\n\t        currIndex = line.notationsStartIndex + line.numNotationsOnLine;\n\t        line.performLayout(ctxt);\n\t        line.elementIndex = this.lines.length;\n\t        this.lines.push(line);\n\t\n\t        line.bounds.y = -line.bounds.y + y;\n\t        y += line.bounds.height + spaceBetweenSystems;\n\t      } while (currIndex < this.notations.length);\n\t\n\t      var firstLine = this.lines[0];\n\t\n\t      this.bounds.x = 0;\n\t      this.bounds.y = 0;\n\t      this.bounds.width = firstLine.bounds.width;\n\t      this.bounds.height = y - spaceBetweenSystems;\n\t\n\t      this.pages = [this];\n\t\n\t      if (this.selection) {\n\t        this.updateSelection(this.selection);\n\t      }\n\t\n\t      if (finishedCallback) finishedCallback(this);\n\t    }\n\t  }, {\n\t    key: \"paginate\",\n\t    value: function paginate(height) {\n\t      if (!height) return;\n\t      this.pages = [];\n\t      var pageHeightOffset = 0,\n\t          startLineIndex = 0;\n\t      for (var i = 1; i < this.lines.length; ++i) {\n\t        var line = this.lines[i];\n\t        var pageHeight = line.bounds.bottom() - pageHeightOffset - line.origin.y;\n\t\n\t        if (pageHeight > height) {\n\t          // this line will be the first on the new page\n\t          this.pages.push(this.copyLines(startLineIndex, i));\n\t          startLineIndex = i;\n\t          pageHeightOffset = line.bounds.y - line.origin.y;\n\t          line.bounds.y = line.origin.y;\n\t        } else {\n\t          // not a new page yet...update the bounds:\n\t          line.bounds.y -= pageHeightOffset;\n\t        }\n\t      }\n\t      this.pages.push(this.copyLines(startLineIndex, this.lines.length));\n\t    }\n\t  }, {\n\t    key: \"draw\",\n\t    value: function draw(ctxt) {\n\t      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\t\n\t      ctxt.setCanvasSize(this.bounds.width, this.bounds.height, scale);\n\t\n\t      var canvasCtxt = ctxt.canvasCtxt;\n\t\n\t      canvasCtxt.clearRect(0, 0, ctxt.canvas.width, ctxt.canvas.height);\n\t\n\t      canvasCtxt.translate(this.bounds.x, this.bounds.y);\n\t\n\t      if (this.titles) this.titles.draw(ctxt);\n\t\n\t      for (var i = 0; i < this.lines.length; i++) {\n\t        this.lines[i].draw(ctxt);\n\t      }canvasCtxt.translate(-this.bounds.x, -this.bounds.y);\n\t    }\n\t  }, {\n\t    key: \"getSvgProps\",\n\t    value: function getSvgProps(ctxt, zoom) {\n\t      var width = typeof zoom === \"number\" ? zoom * this.bounds.width : zoom ? undefined : this.bounds.width,\n\t          height = zoom ? undefined : this.bounds.height;\n\t\n\t      return {\n\t        xmlns: _ExsurgeDrawing.QuickSvg.ns,\n\t        \"xmlns:xlink\": _ExsurgeDrawing.QuickSvg.xlink,\n\t        version: \"1.1\",\n\t        class: \"Exsurge ChantScore\" + (ctxt.editable ? \" EditableChantScore\" : \"\"),\n\t        width: width,\n\t        height: height,\n\t        viewBox: [0, 0, this.bounds.width, this.bounds.height].join(\" \")\n\t      };\n\t    }\n\t  }, {\n\t    key: \"createSvgNode\",\n\t    value: function createSvgNode(ctxt) {\n\t      // create defs section\n\t      var node = [ctxt.defsNode.cloneNode(true)];\n\t      node[0].appendChild(ctxt.createStyleNode());\n\t\n\t      if (this.titles) node.push(this.titles.createSvgNode(ctxt));\n\t\n\t      for (var i = 0; i < this.lines.length; i++) {\n\t        node.push(this.lines[i].createSvgNode(ctxt));\n\t      }node = _ExsurgeDrawing.QuickSvg.createNode(\"g\", {}, node);\n\t\n\t      node = _ExsurgeDrawing.QuickSvg.createNode(\"svg\", this.getSvgProps(ctxt), node);\n\t\n\t      node.source = this;\n\t      this.svg = node;\n\t\n\t      return node;\n\t    }\n\t  }, {\n\t    key: \"createSvgTree\",\n\t    value: function createSvgTree(ctxt, zoom) {\n\t      // create defs section\n\t      var node = [_ExsurgeDrawing.QuickSvg.createSvgTree.apply(_ExsurgeDrawing.QuickSvg, [\"defs\", {}].concat(_toConsumableArray(ctxt.makeDefs.map(function (makeDef) {\n\t        return makeDef.makeSvgTree();\n\t      })), [ctxt.createStyleTree()]))];\n\t\n\t      if (this.titles) node.push(this.titles.createSvgTree(ctxt));\n\t\n\t      for (var i = 0; i < this.lines.length; i++) {\n\t        node.push(this.lines[i].createSvgTree(ctxt));\n\t      }node = _ExsurgeDrawing.QuickSvg.createSvgTree.apply(_ExsurgeDrawing.QuickSvg, [\"g\", {}].concat(_toConsumableArray(node)));\n\t      var svgProps = this.getSvgProps(ctxt, zoom);\n\t      svgProps.source = this;\n\t      node = _ExsurgeDrawing.QuickSvg.createSvgTree(\"svg\", svgProps, node);\n\t\n\t      return node;\n\t    }\n\t  }, {\n\t    key: \"createSvg\",\n\t    value: function createSvg(ctxt) {\n\t      var fragment = \"\";\n\t\n\t      // create defs section\n\t      for (var def in ctxt.defs) {\n\t        if (ctxt.defs.hasOwnProperty(def)) fragment += ctxt.defs[def];\n\t      }fragment += ctxt.createStyle();\n\t\n\t      fragment = _ExsurgeDrawing.QuickSvg.createFragment(\"defs\", {}, fragment);\n\t\n\t      if (this.titles) fragment += this.titles.createSvgFragment(ctxt);\n\t\n\t      for (var i = 0; i < this.lines.length; i++) {\n\t        fragment += this.lines[i].createSvgFragment(ctxt);\n\t      }fragment = _ExsurgeDrawing.QuickSvg.createFragment(\"g\", {}, fragment);\n\t\n\t      fragment = _ExsurgeDrawing.QuickSvg.createFragment(\"svg\", this.getSvgProps(ctxt), fragment);\n\t\n\t      return fragment;\n\t    }\n\t  }, {\n\t    key: \"createSvgNodeForEachLine\",\n\t    value: function createSvgNodeForEachLine(ctxt) {\n\t      var node = [];\n\t\n\t      var top = 0;\n\t      for (var i = 0; i < this.lines.length; i++) {\n\t        var lineFragment = [ctxt.defsNode.cloneNode(true), this.lines[i].createSvgNode(ctxt, top)];\n\t        lineFragment[0].appendChild(ctxt.createStyleNode());\n\t        var height = this.lines[i].bounds.height + ctxt.staffInterval * 1.5;\n\t        lineFragment = _ExsurgeDrawing.QuickSvg.createNode(\"g\", {}, lineFragment);\n\t        lineFragment = _ExsurgeDrawing.QuickSvg.createNode(\"svg\", {\n\t          xmlns: _ExsurgeDrawing.QuickSvg.ns,\n\t          version: \"1.1\",\n\t          class: \"Exsurge ChantScore\",\n\t          width: this.bounds.width,\n\t          height: height,\n\t          viewBox: [0, 0, this.bounds.width, height].join(\" \")\n\t        }, lineFragment);\n\t        node.push(lineFragment);\n\t        top += height;\n\t      }\n\t      return node;\n\t    }\n\t  }, {\n\t    key: \"createSvgForEachLine\",\n\t    value: function createSvgForEachLine(ctxt) {\n\t      var fragment = \"\",\n\t          fragmentDefs = \"\";\n\t\n\t      // create defs section\n\t      for (var def in ctxt.defs) {\n\t        if (ctxt.defs.hasOwnProperty(def)) fragmentDefs += ctxt.defs[def];\n\t      }fragmentDefs += ctxt.createStyle();\n\t\n\t      fragmentDefs = _ExsurgeDrawing.QuickSvg.createFragment(\"defs\", {}, fragmentDefs);\n\t      var top = 0;\n\t      for (var i = 0; i < this.lines.length; i++) {\n\t        var lineFragment = fragmentDefs + this.lines[i].createSvgFragment(ctxt, top);\n\t        var height = this.lines[i].bounds.height + ctxt.staffInterval * 1.5;\n\t        lineFragment = _ExsurgeDrawing.QuickSvg.createFragment(\"g\", {}, lineFragment);\n\t        lineFragment = _ExsurgeDrawing.QuickSvg.createFragment(\"svg\", {\n\t          xmlns: _ExsurgeDrawing.QuickSvg.ns,\n\t          version: \"1.1\",\n\t          \"xmlns:xlink\": _ExsurgeDrawing.QuickSvg.xlink,\n\t          class: \"Exsurge ChantScore\",\n\t          width: this.bounds.width,\n\t          height: height\n\t        }, lineFragment);\n\t        fragment += lineFragment;\n\t        top += height;\n\t      }\n\t      return fragment;\n\t    }\n\t  }, {\n\t    key: \"unserializeFromJson\",\n\t    value: function unserializeFromJson(data, ctxt) {\n\t      this.autoColoring = data[\"auto-coloring\"];\n\t\n\t      if (data.annotation !== null && data.annotation !== \"\") {\n\t        // create the annotation\n\t        this.annotation = new _ExsurgeDrawing.Annotation(ctxt, data.annotation);\n\t      } else this.annotation = null;\n\t\n\t      var createDropCap = data[\"drop-cap\"] === \"auto\" ? true : false;\n\t\n\t      _ExsurgeGabc.Gabc.parseChantNotations(data.notations, this, createDropCap);\n\t    }\n\t  }, {\n\t    key: \"serializeToJson\",\n\t    value: function serializeToJson() {\n\t      var data = {};\n\t\n\t      data[\"type\"] = \"score\";\n\t      data[\"auto-coloring\"] = true;\n\t\n\t      if (this.annotation !== null) data.annotation = this.annotation.unsanitizedText;else data.annotation = \"\";\n\t\n\t      return data;\n\t    }\n\t  }]);\n\t\n\t  return ChantScore;\n\t}();\n\t\n\tvar ChantDocument = exports.ChantDocument = function () {\n\t  function ChantDocument() {\n\t    _classCallCheck(this, ChantDocument);\n\t\n\t    var defaults = {\n\t      layout: {\n\t        units: \"mm\",\n\t        \"default-font\": {\n\t          \"font-family\": \"Crimson\",\n\t          \"font-size\": 14\n\t        },\n\t        page: {\n\t          width: 8.5,\n\t          height: 11,\n\t          \"margin-left\": 0,\n\t          \"margin-top\": 0,\n\t          \"margin-right\": 0,\n\t          \"margin-bottom\": 0\n\t        }\n\t      },\n\t      scores: []\n\t    };\n\t\n\t    // default layout\n\t    this.copyLayout(this, defaults);\n\t\n\t    this.scores = defaults.scores;\n\t  }\n\t\n\t  _createClass(ChantDocument, [{\n\t    key: \"copyLayout\",\n\t    value: function copyLayout(to, from) {\n\t      to.layout = {\n\t        units: from.layout.units,\n\t        \"default-font\": {\n\t          \"font-family\": from.layout[\"default-font\"][\"font-family\"],\n\t          \"font-size\": from.layout[\"default-font\"][\"font-size\"]\n\t        },\n\t        page: {\n\t          width: from.layout.page.width,\n\t          height: from.layout.page.height,\n\t          \"margin-left\": from.layout.page[\"margin-left\"],\n\t          \"margin-top\": from.layout.page[\"margin-top\"],\n\t          \"margin-right\": from.layout.page[\"margin-right\"],\n\t          \"margin-bottom\": from.layout.page[\"margin-bottom\"]\n\t        }\n\t      };\n\t    }\n\t  }, {\n\t    key: \"unserializeFromJson\",\n\t    value: function unserializeFromJson(data) {\n\t      this.copyLayout(this, data);\n\t\n\t      this.scores = [];\n\t\n\t      // read in the scores\n\t      for (var i = 0; i < data.scores.length; i++) {\n\t        var score = new ChantScore();\n\t\n\t        score.unserializeFromJson(data.scores[i]);\n\t        this.scores.push(score);\n\t      }\n\t    }\n\t  }, {\n\t    key: \"serializeToJson\",\n\t    value: function serializeToJson() {\n\t      var data = {};\n\t\n\t      this.copyLayout(data, this);\n\t\n\t      data.scores = [];\n\t\n\t      // save scores...\n\t      for (var i = 0; i < this.scores.length; i++) {\n\t        data.scores.push(this.scores[i].serializeToJson());\n\t      }return data;\n\t    }\n\t  }]);\n\n\t  return ChantDocument;\n\t}();\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.ChantLine = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _ExsurgeChant = __webpack_require__(8);\n\t\n\tvar _ExsurgeChantMarkings = __webpack_require__(10);\n\t\n\tvar _ExsurgeChantSigns = __webpack_require__(11);\n\t\n\tvar _ExsurgeCore = __webpack_require__(1);\n\t\n\tvar _ExsurgeDrawing = __webpack_require__(4);\n\t\n\tvar _ExsurgeGlyphs = __webpack_require__(3);\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //\n\t// Author(s):\n\t// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>\n\t//\n\t// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a copy\n\t// of this software and associated documentation files (the \"Software\"), to deal\n\t// in the Software without restriction, including without limitation the rights\n\t// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\t// copies of the Software, and to permit persons to whom the Software is\n\t// furnished to do so, subject to the following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included in\n\t// all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\t// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\t// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\t// THE SOFTWARE.\n\t//\n\t\n\t// a chant line represents one staff line on the page. ChantLines are created by the score\n\t// and laid out by the page\n\tvar ChantLine = exports.ChantLine = function (_ChantLayoutElement) {\n\t  _inherits(ChantLine, _ChantLayoutElement);\n\t\n\t  function ChantLine(score) {\n\t    _classCallCheck(this, ChantLine);\n\t\n\t    var _this = _possibleConstructorReturn(this, (ChantLine.__proto__ || Object.getPrototypeOf(ChantLine)).call(this));\n\t\n\t    _this.score = score;\n\t\n\t    _this.notationsStartIndex = 0;\n\t    _this.numNotationsOnLine = 0;\n\t    _this.notationBounds = null; // Rect\n\t\n\t    _this.staffLeft = 0;\n\t    _this.staffRight = 0;\n\t\n\t    _this.startingClef = null; // necessary for the layout process\n\t    _this.custos = null;\n\t\n\t    _this.justify = true;\n\t\n\t    // these are markings that exist at the chant line level rather than at the neume level.\n\t    _this.ledgerLines = [];\n\t    _this.braces = [];\n\t\n\t    _this.nextLine = null;\n\t    _this.previousLine = null; // for layout assistance\n\t\n\t    _this.lyricLineHeight = 0; // height of each text line\n\t    _this.lyricLineBaseline = 0; // offsets from the top of the text line to the baseline\n\t    _this.numLyricLines = 0; // maximum count of lyrics on the same syllable\n\t\n\t    // fixme: make these configurable values from the score\n\t    _this.spaceAfterNotations = 0; // the space between the notation bounds and the first text track\n\t    _this.spaceBetweenTextTracks = 0; // spacing between each text track\n\t\n\t    _this.lastLyrics = [];\n\t    return _this;\n\t  }\n\t\n\t  _createClass(ChantLine, [{\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      // start off with a rectangle that holds at least the four staff lines\n\t      var staffSpaces = this.staffSpaces;\n\t      var staffLineCount = this.score.staffLineCount;\n\t      this.notationBounds = new _ExsurgeCore.Rect(this.staffLeft, -(ctxt.staffLineWeight / 2 + staffLineCount * 2 - 1 + ctxt.minSpaceAboveStaff) * ctxt.staffInterval, this.staffRight - this.staffLeft, (ctxt.staffLineWeight + staffSpaces * 2 + ctxt.minSpaceAboveStaff) * ctxt.staffInterval);\n\t\n\t      // run through all the elements of the line and calculate the bounds of the notations,\n\t      // as well as the bounds of each text track we will use\n\t      var i;\n\t      var notations = this.score.notations;\n\t      var lastNeumeIndex = this.extraTextOnlyIndex === null ? this.notationsStartIndex + this.numNotationsOnLine : this.extraTextOnlyIndex;\n\t      var lastIndex = this.notationsStartIndex + this.numNotationsOnLine;\n\t      var notation = null;\n\t\n\t      this.notationBounds.union(this.startingClef.bounds);\n\t\n\t      // reset the lyric line offsets before we [re]calculate them now\n\t      this.lyricLineHeight = ctxt.textStyles.lyric.size * (ctxt.textStyles.lyric.lineHeight || 1.1);\n\t      this.lyricLineBaseline = 0;\n\t      this.numLyricLines = 0;\n\t\n\t      this.altLineHeight = 0;\n\t      this.altLineBaseline = 0;\n\t      this.numAltLines = 0;\n\t\n\t      this.translationLineHeight = ctxt.textStyles.translation.size * (ctxt.textStyles.translation.lineHeight || 1.1);\n\t      this.translationLineBaseline = 0;\n\t      this.numTranslationLines = 0;\n\t\n\t      var aboveLinesLineHeight = ctxt.textStyles.al.size * (ctxt.textStyles.al.lineHeight || 1.1);\n\t\n\t      for (i = this.notationsStartIndex; i < lastNeumeIndex; i++) {\n\t        notation = notations[i];\n\t\n\t        if (notation.bounds.height || notation.bounds.width) this.notationBounds.union(notation.bounds);\n\t\n\t        // keep track of lyric line offsets\n\t        if (notation.lyrics.length && notation.lyrics[0].text) {\n\t          // if (notation.lyrics[0].bounds.height > this.lyricLineHeight)\n\t          //   this.lyricLineHeight = notation.lyrics[0].bounds.height;\n\t          if (notation.lyrics[0].origin.y > this.lyricLineBaseline) this.lyricLineBaseline = notation.lyrics[0].origin.y;\n\t          if (notation.lyrics.length > this.numLyricLines) this.numLyricLines = notation.lyrics.length;\n\t        }\n\t\n\t        if (notation.alText && this.numAltLines < notation.alText.length) {\n\t          if (notation.alText[0].bounds.height > this.altLineHeight) this.altLineHeight = notation.alText[0].bounds.height;\n\t          if (notation.alText[0].origin.y > this.altLineBaseline) this.altLineBaseline = notation.alText[0].origin.y;\n\t          if (notation.alText.length > this.numAltLines) this.numAltLines = notation.alText.length;\n\t        }\n\t\n\t        if (notation.translationText && notation.translationText[0] && notation.translationText[0].text) {\n\t          // if (\n\t          //   notation.translationText[0].bounds.height > this.translationLineHeight\n\t          // )\n\t          //   this.translationLineHeight =\n\t          //     notation.translationText[0].bounds.height;\n\t          if (notation.translationText[0].origin.y > this.translationLineBaseline) this.translationLineBaseline = notation.translationText[0].origin.y;\n\t          if (notation.translationText.length > this.numTranslationLines) this.numTranslationLines = notation.translationText.length;\n\t        }\n\t      }\n\t\n\t      if (this.custos) this.notationBounds.union(this.custos.bounds);\n\t\n\t      // add any braces to the notationBounds as well\n\t      for (i = 0; i < this.braces.length; i++) {\n\t        this.notationBounds.union(this.braces[i].bounds);\n\t      } // finalize the lyrics placement\n\t      var notationBoundsOffset = this.notationBounds.bottom() + ctxt.minSpaceBelowStaff * ctxt.staffInterval;\n\t      this.lyricLineBaseline += notationBoundsOffset;\n\t      this.translationLineBaseline += notationBoundsOffset;\n\t      this.altLineBaseline += this.notationBounds.y - this.altLineHeight - ctxt.staffInterval * 0.5;\n\t\n\t      for (i = this.notationsStartIndex; i < lastNeumeIndex; i++) {\n\t        notation = notations[i];\n\t        var offset = 0;\n\t        for (var j = 0; j < notation.lyrics.length; j++) {\n\t          notation.lyrics[j].bounds.y = offset + this.lyricLineBaseline;\n\t          offset += this.lyricLineHeight;\n\t        }\n\t\n\t        if (notation.translationText) {\n\t          for (j = 0; j < notation.translationText.length; j++) {\n\t            notation.translationText[j].bounds.y = offset + this.translationLineBaseline;\n\t            offset += this.translationLineHeight;\n\t          }\n\t        }\n\t\n\t        if (notation.alText) {\n\t          offset = 0;\n\t          for (j = 0; j < notation.alText.length; j++) {\n\t            notation.alText[j].bounds.y = offset + this.altLineBaseline;\n\t            offset -= aboveLinesLineHeight;\n\t          }\n\t        }\n\t      }\n\t\n\t      this.extraTextOnlyHeight = 0;\n\t      // handle placement of extra TextOnly elements:\n\t      if (ctxt.useExtraTextOnly) {\n\t        var extraTextOnlyLyricIndex = this.extraTextOnlyLyricIndex;\n\t        if (this.extraTextOnlyIndex === null) {\n\t          // even if extraTextOnlyIndex is null, there might be extra lines on the last lyric if it is TextOnly:\n\t          var lastNotation = notations[lastNeumeIndex - 1] || {};\n\t          if (lastNotation.constructor === _ExsurgeChant.ChantLineBreak) lastNotation = notations[lastNeumeIndex - 2];\n\t          if (lastNotation.constructor === _ExsurgeChant.TextOnly && lastNotation.lyrics.length === 1 && lastNotation.lyrics[0].bounds.height > this.lyricLineHeight) {\n\t            this.extraTextOnlyHeight = this.lyricLineHeight;\n\t          }\n\t        } else {\n\t          var lastLyrics = null;\n\t          var xOffset = 0;\n\t          offset = (this.numLyricLines - 1) * this.lyricLineHeight;\n\t          offset += this.numTranslationLines * this.translationLineHeight;\n\t          var extraLines = 0;\n\t          for (i = this.extraTextOnlyIndex; i < lastIndex; i++) {\n\t            notation = notations[i];\n\t            if (!notation.lyrics[extraTextOnlyLyricIndex]) continue;\n\t            lastLyrics = notation.lyrics[extraTextOnlyLyricIndex];\n\t            if (lastLyrics.lineWidth) {\n\t              xOffset = this.staffRight - lastLyrics.lineWidth;\n\t              offset += this.lyricLineHeight;\n\t              extraLines++;\n\t            }\n\t            extraLines += lastLyrics.numLines - 1;\n\t            lastLyrics.bounds.y = offset + this.lyricLineBaseline;\n\t            notation.bounds.x += xOffset;\n\t          }\n\t          this.extraTextOnlyHeight = this.lyricLineHeight * extraLines;\n\t        }\n\t      }\n\t\n\t      if (this.startingClef.hasLyrics()) {\n\t        offset = 0;\n\t        for (j = 0; j < this.startingClef.lyrics.length; j++) {\n\t          this.startingClef.lyrics[j].bounds.y = offset + this.lyricLineBaseline;\n\t          offset += this.lyricLineHeight;\n\t        }\n\t      }\n\t\n\t      // dropCap and the annotations\n\t      if (this.notationsStartIndex === 0) {\n\t        if (this.score.annotation !== null) {\n\t          // annotations use dominant-baseline to align text to the top\n\t          this.score.annotation.bounds.x = this.staffLeft / 2;\n\t          this.score.annotation.bounds.y = -ctxt.staffInterval * (staffLineCount * 2 - 1);\n\t          if (this.score.dropCap !== null) {\n\t            var lowestPossibleAnnotationY = this.lyricLineBaseline - this.score.annotation.bounds.height - ctxt.staffInterval * ctxt.textStyles.annotation.padding - this.score.dropCap.origin.y;\n\t            // if the annotation would overlap with the drop cap, move the annotation higher.\n\t            // otherwise, center the annotation in the vertical space between the top of the drop cap and the top of the staff.\n\t            if (lowestPossibleAnnotationY < this.score.annotation.bounds.y) {\n\t              this.score.annotation.bounds.y = lowestPossibleAnnotationY;\n\t            } else {\n\t              this.score.annotation.bounds.y = (this.score.annotation.bounds.y + lowestPossibleAnnotationY) / 2;\n\t            }\n\t            if (this.score.annotation.bounds.y < this.notationBounds.y) {\n\t              this.notationBounds.y = this.score.annotation.bounds.y;\n\t              this.notationBounds.height += this.notationBounds.y - this.score.annotation.bounds.y;\n\t            }\n\t          }\n\t          this.score.annotation.bounds.y += this.score.annotation.origin.y;\n\t        }\n\t\n\t        if (this.score.dropCap !== null) {\n\t          // drop caps and annotations are drawn from their center, so aligning them\n\t          // horizontally is as easy as this.staffLeft / 2\n\t          this.score.dropCap.bounds.x = this.staffLeft / 2;\n\t          this.score.dropCap.bounds.y = this.lyricLineBaseline - this.score.dropCap.origin.y;\n\t          this.notationBounds.union(this.score.dropCap.bounds);\n\t          this.score.dropCap.bounds.y = this.lyricLineBaseline;\n\t        }\n\t      }\n\t\n\t      if (this.numLyricLines > 0) {\n\t        // add up the lyric line heights to get the total height of the chant line\n\t        var lyricAndTextRect = new _ExsurgeCore.Rect(0, notationBoundsOffset, 0, this.lyricLineHeight * this.numLyricLines + this.extraTextOnlyHeight + this.translationLineHeight * this.numTranslationLines);\n\t        this.notationBounds.union(lyricAndTextRect);\n\t      }\n\t      if (this.numAltLines > 0) {\n\t        var altLineTextRect = new _ExsurgeCore.Rect(0, this.notationBounds.y - this.altLineHeight - 0.5 * ctxt.staffInterval - aboveLinesLineHeight * (this.numAltLines - 1), 0, aboveLinesLineHeight * this.numAltLines);\n\t        this.notationBounds.union(altLineTextRect);\n\t      }\n\t      // Ensure that there is at least minSpaceBelowStaff below the lowest staff line:\n\t      this.notationBounds.union(new _ExsurgeCore.Rect(0, -ctxt.staffInterval, // lowest staff line\n\t      0, (ctxt.staffLineWeight / 2 + ctxt.minSpaceBelowStaff) * ctxt.staffInterval));\n\t      var totalHeight = this.notationBounds.height;\n\t\n\t      this.bounds.x = 0;\n\t      this.bounds.y = this.notationBounds.y;\n\t      this.bounds.width = this.notationBounds.right();\n\t      this.bounds.height = totalHeight;\n\t\n\t      // the origin of the chant line's coordinate space is at the center line of the left extremity of the staff\n\t      this.origin = new _ExsurgeCore.Point(this.staffLeft, -this.notationBounds.y);\n\t    }\n\t\n\t    // TODO: remove if not necsessary\n\t\n\t  }, {\n\t    key: \"layoutInsertionCursor\",\n\t    value: function layoutInsertionCursor(ctxt) {\n\t      if (this.insertionCursor) {\n\t        // we have either a Notation to draw the cursor after, or the ChantLine itself when the cursor is the first thing on the line\n\t        this.insertionCursor.performLayout(ctxt);\n\t        this.insertionCursor.bounds.x = this.score.insertionElement.bounds.right() + (this.score.insertionElement.trailingSpace && this.score.insertionElement.calculatedTrailingSpace || 0) / 2 - this.insertionCursor.origin.x;\n\t      }\n\t      return this.insertionCursor;\n\t    }\n\t  }, {\n\t    key: \"draw\",\n\t    value: function draw(ctxt) {\n\t      var canvasCtxt = ctxt.canvasCtxt;\n\t\n\t      canvasCtxt.translate(this.bounds.x, this.bounds.y);\n\t\n\t      // draw the staff lines\n\t      var i,\n\t          x1 = this.staffLeft,\n\t          x2 = this.staffRight,\n\t          y;\n\t      canvasCtxt.lineWidth = ctxt.staffLineWeight;\n\t      canvasCtxt.strokeStyle = ctxt.staffLineColor;\n\t\n\t      for (i = this.score.staffLineCount * -2 + 1; i < 0; i += 2) {\n\t        y = ctxt.staffInterval * i;\n\t\n\t        canvasCtxt.beginPath();\n\t        canvasCtxt.moveTo(x1, y);\n\t        canvasCtxt.lineTo(x2, y);\n\t        canvasCtxt.stroke();\n\t      }\n\t\n\t      if (this.layoutInsertionCursor(ctxt)) {\n\t        this.insertionCursor.draw(ctxt);\n\t      }\n\t\n\t      // draw the ledger lines\n\t      for (i = 0; i < this.ledgerLines.length; i++) {\n\t        var ledgerLine = this.ledgerLines[i];\n\t        y = ctxt.calculateHeightFromStaffPosition(ledgerLine.staffPosition);\n\t\n\t        canvasCtxt.beginPath();\n\t        canvasCtxt.moveTo(ledgerLine.x1, y);\n\t        canvasCtxt.lineTo(ledgerLine.x2, y);\n\t        canvasCtxt.stroke();\n\t      }\n\t\n\t      // fixme: draw the braces\n\t\n\t      // draw the dropCap and the annotations\n\t      if (this.notationsStartIndex === 0) {\n\t        if (this.score.dropCap !== null) this.score.dropCap.draw(ctxt);\n\t\n\t        if (this.score.annotation !== null && (!ctxt.mergeAnnotationWithTextLeft || this.score.dropCap))\n\t          // only draw it if there is a dropCap or there is no mergeAnnotationWithTextLeft\n\t          this.score.annotation.draw(ctxt);\n\t      }\n\t\n\t      // draw the notations\n\t      var notations = this.score.notations;\n\t      var lastIndex = this.notationsStartIndex + this.numNotationsOnLine;\n\t\n\t      for (i = this.notationsStartIndex; i < lastIndex; i++) {\n\t        notations[i].draw(ctxt);\n\t      }this.startingClef.draw(ctxt);\n\t\n\t      if (this.custos) this.custos.draw(ctxt);\n\t\n\t      canvasCtxt.translate(-this.bounds.x, -this.bounds.y);\n\t    }\n\t  }, {\n\t    key: \"getInnerNodes\",\n\t    value: function getInnerNodes(ctxt) {\n\t      var top = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t      var functionNames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { quickSvg: \"createNode\", elements: \"createSvgNode\" };\n\t\n\t      var inner = [];\n\t\n\t      // add the chant lines\n\t      var i,\n\t          x1 = this.staffLeft,\n\t          x2 = this.staffRight;\n\t      var staffSpaces = this.staffSpaces;\n\t      if (ctxt.editable) {\n\t        inner.push(_ExsurgeDrawing.QuickSvg[functionNames.quickSvg](\"rect\", {\n\t          key: \"insertion\",\n\t          x: x1,\n\t          y: ctxt.staffInterval * this.score.staffLineCount * -2 + 1,\n\t          width: x2 - x1,\n\t          height: ctxt.staffInterval * 2 * staffSpaces,\n\t          fill: \"none\"\n\t        }));\n\t      }\n\t\n\t      // create the staff lines\n\t      for (i = this.score.staffLineCount * -2 + 1; i < 0; i += 2) {\n\t        inner.push(_ExsurgeDrawing.QuickSvg[functionNames.quickSvg](\"line\", {\n\t          key: i,\n\t          x1: x1,\n\t          y1: ctxt.staffInterval * i,\n\t          x2: x2,\n\t          y2: ctxt.staffInterval * i,\n\t          stroke: ctxt.staffLineColor,\n\t          \"stroke-width\": ctxt.staffLineWeight,\n\t          class: \"staffLine\"\n\t        }));\n\t      }\n\t\n\t      inner = [_ExsurgeDrawing.QuickSvg[functionNames.quickSvg](\"g\", { class: \"staffLines\" }, inner)];\n\t\n\t      if (this.layoutInsertionCursor(ctxt)) {\n\t        inner.push(this.insertionCursor[functionNames.elements](ctxt));\n\t      }\n\t\n\t      // create the ledger lines\n\t      for (i = 0; i < this.ledgerLines.length; i++) {\n\t        var ledgerLine = this.ledgerLines[i];\n\t        var y = ctxt.calculateHeightFromStaffPosition(ledgerLine.staffPosition);\n\t\n\t        inner.push(_ExsurgeDrawing.QuickSvg[functionNames.quickSvg](\"line\", {\n\t          x1: ledgerLine.x1,\n\t          y1: y,\n\t          x2: ledgerLine.x2,\n\t          y2: y,\n\t          stroke: ctxt.staffLineColor,\n\t          \"stroke-width\": ctxt.staffLineWeight,\n\t          class: \"ledgerLine\"\n\t        }));\n\t      }\n\t\n\t      // add any braces\n\t      for (i = 0; i < this.braces.length; i++) {\n\t        inner.push(this.braces[i][functionNames.elements](ctxt));\n\t      } // dropCap and the annotations\n\t      if (this.notationsStartIndex === 0) {\n\t        if (this.score.dropCap !== null) inner.push(this.score.dropCap[functionNames.elements](ctxt));\n\t\n\t        if (this.score.annotation !== null && (!ctxt.mergeAnnotationWithTextLeft || this.score.dropCap))\n\t          // only draw it if there is a dropCap or there is no mergeAnnotationWithTextLeft\n\t          inner = inner.concat(this.score.annotation[functionNames.elements](ctxt));\n\t      }\n\t\n\t      inner.push(this.startingClef[functionNames.elements](ctxt));\n\t\n\t      var notations = this.score.notations;\n\t      var lastIndex = this.notationsStartIndex + this.numNotationsOnLine;\n\t\n\t      // add all of the notations\n\t      for (i = this.notationsStartIndex; i < lastIndex; i++) {\n\t        inner.push(notations[i][functionNames.elements](ctxt));\n\t      }if (this.custos) inner.push(this.custos[functionNames.elements](ctxt));\n\t      return inner;\n\t    }\n\t  }, {\n\t    key: \"createSvgNode\",\n\t    value: function createSvgNode(ctxt) {\n\t      var top = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t\n\t      var inner = this.getInnerNodes(ctxt, top, {\n\t        quickSvg: \"createNode\",\n\t        elements: \"createSvgNode\"\n\t      });\n\t\n\t      return _ExsurgeDrawing.QuickSvg.createNode(\"g\", {\n\t        class: \"chantLine\",\n\t        transform: \"translate(\" + this.bounds.x + \",\" + (this.bounds.y - top) + \")\",\n\t        \"element-index\": this.elementIndex,\n\t        source: this\n\t      }, inner);\n\t    }\n\t  }, {\n\t    key: \"createSvgTree\",\n\t    value: function createSvgTree(ctxt) {\n\t      var top = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t\n\t      var inner = this.getInnerNodes(ctxt, top, {\n\t        quickSvg: \"createSvgTree\",\n\t        elements: \"createSvgTree\"\n\t      });\n\t\n\t      return _ExsurgeDrawing.QuickSvg.createSvgTree.apply(_ExsurgeDrawing.QuickSvg, [\"g\", {\n\t        class: \"chantLine\",\n\t        transform: \"translate(\" + this.bounds.x + \",\" + (this.bounds.y - top) + \")\",\n\t        \"element-index\": this.elementIndex\n\t      }].concat(_toConsumableArray(inner)));\n\t    }\n\t  }, {\n\t    key: \"createSvgFragment\",\n\t    value: function createSvgFragment(ctxt) {\n\t      var top = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t\n\t      var inner = \"\";\n\t\n\t      // add the chant lines\n\t      var i,\n\t          x1 = this.staffLeft,\n\t          x2 = this.staffRight;\n\t\n\t      // create the staff lines\n\t      for (i = this.score.staffLineCount * -2 + 1; i < 0; i += 2) {\n\t        inner += _ExsurgeDrawing.QuickSvg.createFragment(\"line\", {\n\t          x1: x1,\n\t          y1: ctxt.staffInterval * i,\n\t          x2: x2,\n\t          y2: ctxt.staffInterval * i,\n\t          stroke: ctxt.staffLineColor,\n\t          \"stroke-width\": ctxt.staffLineWeight,\n\t          class: \"staffLine\"\n\t        });\n\t      }\n\t\n\t      inner = _ExsurgeDrawing.QuickSvg.createFragment(\"g\", { class: \"staffLines\" }, inner);\n\t\n\t      if (this.layoutInsertionCursor(ctxt)) {\n\t        inner += this.insertionCursor.createSvgFragment(ctxt);\n\t      }\n\t\n\t      // create the ledger lines\n\t      for (i = 0; i < this.ledgerLines.length; i++) {\n\t        var ledgerLine = this.ledgerLines[i];\n\t        var y = ctxt.calculateHeightFromStaffPosition(ledgerLine.staffPosition);\n\t\n\t        inner += _ExsurgeDrawing.QuickSvg.createFragment(\"line\", {\n\t          x1: ledgerLine.x1,\n\t          y1: y,\n\t          x2: ledgerLine.x2,\n\t          y2: y,\n\t          stroke: ctxt.staffLineColor,\n\t          \"stroke-width\": ctxt.staffLineWeight,\n\t          class: \"ledgerLine\"\n\t        });\n\t      }\n\t\n\t      // add any braces\n\t      for (i = 0; i < this.braces.length; i++) {\n\t        inner += this.braces[i].createSvgFragment(ctxt);\n\t      } // dropCap and the annotations\n\t      if (this.notationsStartIndex === 0) {\n\t        if (this.score.dropCap !== null) inner += this.score.dropCap.createSvgFragment(ctxt);\n\t\n\t        if (this.score.annotation !== null && (!ctxt.mergeAnnotationWithTextLeft || this.score.dropCap))\n\t          // only draw it if there is a dropCap or there is no mergeAnnotationWithTextLeft\n\t          inner += this.score.annotation.createSvgFragment(ctxt);\n\t      }\n\t\n\t      inner += this.startingClef.createSvgFragment(ctxt);\n\t\n\t      var notations = this.score.notations;\n\t      var lastIndex = this.notationsStartIndex + this.numNotationsOnLine;\n\t\n\t      // add all of the notations\n\t      for (i = this.notationsStartIndex; i < lastIndex; i++) {\n\t        inner += notations[i].createSvgFragment(ctxt);\n\t      }if (this.custos) inner += this.custos.createSvgFragment(ctxt);\n\t\n\t      return _ExsurgeDrawing.QuickSvg.createFragment(\"g\", {\n\t        class: \"chantLine\",\n\t        transform: \"translate(\" + this.bounds.x + \",\" + (this.bounds.y - top) + \")\",\n\t        \"element-index\": this.elementIndex\n\t      }, inner);\n\t    }\n\t\n\t    // code below based on code by: https://gist.github.com/alexhornbake\n\t    //\n\t    // optimized for braces that are only drawn horizontally.\n\t    // returns svg path string ready to insert into svg doc\n\t\n\t  }, {\n\t    key: \"generateCurlyBraceDrawable\",\n\t    value: function generateCurlyBraceDrawable(ctxt, x1, x2, y, isAbove) {\n\t      var h;\n\t\n\t      if (isAbove) h = -ctxt.staffInterval / 2;else h = ctxt.staffInterval / 2;\n\t\n\t      // and q factor, .5 is normal, higher q = more expressive bracket\n\t      var q = 0.6;\n\t\n\t      var len = x2 - x1;\n\t\n\t      //Calculate Control Points of path,\n\t      var qx1 = x1;\n\t      var qy1 = y + q * h;\n\t      var qx2 = x1 + 0.25 * len;\n\t      var qy2 = y + (1 - q) * h;\n\t      var tx1 = x1 + 0.5 * len;\n\t      var ty1 = y + h;\n\t      var qx3 = x2;\n\t      var qy3 = y + q * h;\n\t      var qx4 = x1 + 0.75 * len;\n\t      var qy4 = y + (1 - q) * h;\n\t      var d = \"M \" + x1 + \" \" + y + \" Q \" + qx1 + \" \" + qy1 + \" \" + qx2 + \" \" + qy2 + \" T \" + tx1 + \" \" + ty1 + \" M \" + x2 + \" \" + y + \" Q \" + qx3 + \" \" + qy3 + \" \" + qx4 + \" \" + qy4 + \" T \" + tx1 + \" \" + ty1;\n\t\n\t      return _ExsurgeDrawing.QuickSvg.createFragment(\"path\", {\n\t        d: d,\n\t        stroke: ctxt.neumeLineColor,\n\t        \"stroke-width\": ctxt.neumeLineWeight + \"px\",\n\t        fill: \"none\"\n\t      });\n\t    }\n\t  }, {\n\t    key: \"buildFromChantNotationIndex\",\n\t    value: function buildFromChantNotationIndex(ctxt, newElementStart, width) {\n\t      // todo: reset / clear the children we have in case they have data\n\t      var notations = this.score.notations,\n\t          beginningLyrics = null,\n\t          prev = null,\n\t          prevNeume = null,\n\t          prevLyrics = [];\n\t      var condensableSpaces = [];\n\t      this.notationsStartIndex = newElementStart;\n\t      this.numNotationsOnLine = 0;\n\t\n\t      this.staffLeft = 0;\n\t      this.paddingLeft = 0;\n\t\n\t      this.extraTextOnlyIndex = null;\n\t      this.extraTextOnlyLyricIndex = 0;\n\t\n\t      if (width > 0) this.staffRight = width;else this.staffRight = Infinity; // no limit to staff size\n\t\n\t      // If this is the first chant line, then we have to make room for a\n\t      // drop cap and/or annotation, if present\n\t      if (this.notationsStartIndex === 0) {\n\t        var padding = 0;\n\t\n\t        if (this.score.dropCap) padding = this.score.dropCap.bounds.width + this.score.dropCap.padding * 2;\n\t\n\t        if (this.score.annotation && (!ctxt.mergeAnnotationWithTextLeft || this.score.dropCap)) padding = Math.max(padding, this.score.annotation.bounds.width + this.score.annotation.padding * 2);\n\t\n\t        this.staffLeft += padding;\n\t        if (this.score.dropCap) this.paddingLeft = (padding - this.score.dropCap.bounds.width) / 2;\n\t      } else {\n\t        prev = notations[newElementStart - 1];\n\t        if (prev.constructor === _ExsurgeChantSigns.DoubleBar && prev.hasLyrics() && (prev.lyrics.length > 1 || !prev.lyrics[0].text.match(/^(i\\.?)+j\\.?/))) {\n\t          beginningLyrics = prev.lyrics.map(function (lyric) {\n\t            var newLyric = new _ExsurgeDrawing.Lyric(ctxt, lyric.originalText, lyric.lyricType, lyric.notation, lyric.notations, lyric.sourceIndex);\n\t            newLyric.elidesToNext = lyric.elidesToNext;\n\t            // Hide the original lyric by setting its bounds.y to an extremely high number.\n\t            // If the chant is re-laid out, this value will be recalculated so that it won't stay hidden.\n\t            lyric.bounds.y = Number.MAX_SAFE_INTEGER;\n\t            return newLyric;\n\t          });\n\t          var minX = beginningLyrics.map(function (l) {\n\t            return l.bounds.x;\n\t          }).reduce(function (a, b) {\n\t            return a < b ? a : b;\n\t          });\n\t          beginningLyrics.forEach(function (l) {\n\t            l.bounds.x -= minX;\n\t          });\n\t        }\n\t      }\n\t\n\t      // set up the clef...\n\t      // if the first notation on the line is a starting clef, then we treat it a little differently...\n\t      // the clef becomes this line's starting clef and we skip over the clef in the notations array\n\t      if (notations.length && notations[newElementStart].isClef) {\n\t        ctxt.activeClef = notations[newElementStart];\n\t        newElementStart++;\n\t        this.notationsStartIndex++;\n\t      }\n\t\n\t      // make a copy for this line to use at the beginning\n\t      this.startingClef = ctxt.activeClef.clone();\n\t      this.startingClef.performLayout(ctxt);\n\t      this.startingClef.bounds.x = this.staffLeft;\n\t\n\t      var curr = this.startingClef;\n\t\n\t      if (beginningLyrics) {\n\t        _ExsurgeDrawing.LyricArray.setNotation(beginningLyrics, curr);\n\t      }\n\t\n\t      // estimate how much space we have available to us\n\t      var rightNotationBoundary = this.staffRight - _ExsurgeGlyphs.Glyphs.CustosLong.bounds.width * ctxt.glyphScaling; // possible custos on the line\n\t      var lastTranslationTextWithEndNeume = null;\n\t\n\t      // iterate through the notations, fittng what we can on this line\n\t      var i,\n\t          j,\n\t          lastNotationIndex = notations.length - 1;\n\t\n\t      if (curr.hasLyrics()) _ExsurgeDrawing.LyricArray.mergeIn(this.lastLyrics, curr.lyrics);\n\t\n\t      // if we already have a start brace on the context, we must be continuing it from the previous system.\n\t      if (ctxt.lastStartBrace && !ctxt.lastStartBrace.note) {\n\t        ctxt.lastStartBrace.note = this.startingClef;\n\t      }\n\t      var lastLyricsBeforeTextOnly;\n\t      var textOnlyStartIndex;\n\t\n\t      for (i = newElementStart; i <= lastNotationIndex; i++) {\n\t        prev = curr;\n\t        if (curr.constructor !== _ExsurgeChant.TextOnly) prevNeume = curr;\n\t\n\t        curr = notations[i];\n\t\n\t        var actualRightBoundary;\n\t        if (i === lastNotationIndex || curr.constructor === _ExsurgeChantSigns.Custos || prev.constructor === _ExsurgeChantSigns.Custos && curr.isDivider || curr.constructor === _ExsurgeChant.ChantLineBreak && prevNeume.constructor === _ExsurgeChantSigns.Custos) {\n\t          // on the last notation of the score, we don't need a custos or trailing space, so we use staffRight as the\n\t          // right boundary.\n\t          // Also, if the current notation is a divider and the previous was a custos, we don't need extra space\n\t          // because if the following notation won't fit, we can switch the order and use the custos as the end-of-the-line custos\n\t          // Ditto in the case of the current element being a chant line break and the previous neume a custos, because that custos will become our end-of-line custos\n\t          actualRightBoundary = this.staffRight;\n\t        } else if (i === lastNotationIndex - 1) {\n\t          // on the penultimate notation, make sure there is at least enough room for whichever takes up less space,\n\t          // between the final notation and a custos:\n\t          actualRightBoundary = Math.max(rightNotationBoundary, this.staffRight - notations[lastNotationIndex].bounds.width);\n\t        } else {\n\t          // Otherwise, we use rightNotationBoundary, which leaves room for a custos...\n\t          actualRightBoundary = rightNotationBoundary;\n\t        }\n\t\n\t        // First check if we're already beyond the rightNotationBoundary (due to condensing that hasn't yet happened) and have a good element to end with\n\t        // but if we have 2 or fewer elements, or if the current element is a line break or a custos, we'll go ahead and try for them anyway.\n\t        var forceBreak = !curr.isDivider && curr.constructor !== _ExsurgeChant.ChantLineBreak && curr.constructor !== _ExsurgeChantSigns.Custos && !(curr.constructor === _ExsurgeChant.TextOnly && curr.hasLyrics() && /^(?:[*†]|i+j\\.?)$/.test(curr.lyrics[0].text)) && lastNotationIndex - i > 1 && !prevNeume.keepWithNext && prevNeume.bounds.right() >= rightNotationBoundary;\n\t\n\t        // also force a break if we've run into extra TextOnly elements, but the current notation is not a TextOnly and has lyrics\n\t        forceBreak = forceBreak || this.extraTextOnlyIndex !== null && curr.constructor !== _ExsurgeChant.TextOnly && curr.constructor !== _ExsurgeChant.ChantLineBreak && curr.constructor !== _ExsurgeChantSigns.Custos && curr.hasLyrics();\n\t\n\t        if (curr instanceof _ExsurgeChant.TextOnly && prev === prevNeume) {\n\t          lastLyricsBeforeTextOnly = this.lastLyrics.slice();\n\t          textOnlyStartIndex = i;\n\t        }\n\t        if (curr instanceof _ExsurgeChant.TextOnly && notations[textOnlyStartIndex] && !notations[textOnlyStartIndex].hasLyrics()) {\n\t          // we want textOnlyStartIndex to be the first TextOnly that actually has lyrics,\n\t          // so if the current \"textOnlyStart\" element does not have lyrics, and we have another textOnly\n\t          // that does have lyrics, we will use it instead\n\t          textOnlyStartIndex = i;\n\t        }\n\t\n\t        if (curr.hasLyrics() && curr.lyrics[0].needsLayout) {\n\t          curr.lyrics[0].recalculateMetrics(ctxt);\n\t        }\n\t\n\t        // try to fit the curr element on this line.\n\t        // if it doesn't fit, we finish up here.\n\t        var fitsOnLine = !forceBreak && this.positionNotationElement(ctxt, this.lastLyrics, prevNeume, curr, actualRightBoundary, this.extraTextOnlyIndex ? [] : condensableSpaces // no spaces are condensable once we are on extra text only lyrics\n\t        );\n\t        var candidateForExtraTextOnlyLine = ctxt.useExtraTextOnly && curr.constructor === _ExsurgeChant.TextOnly && _ExsurgeDrawing.LyricArray.hasOnlyOneLyric(curr.lyrics) && (fitsOnLine === false || this.extraTextOnlyIndex !== null);\n\t        var extraTextOnlyLyricIndex;\n\t        if (candidateForExtraTextOnlyLine && this.extraTextOnlyIndex === null) {\n\t          // check to make sure there is enough text to put on the text only line:\n\t          extraTextOnlyLyricIndex = _ExsurgeDrawing.LyricArray.indexOfLyric(curr.lyrics);\n\t          if (textOnlyStartIndex === i) {\n\t            var currentLyric = notations[i].lyrics[extraTextOnlyLyricIndex].text;\n\t            if (currentLyric.length <= 1) {\n\t              var nextNotation = notations[i + 1];\n\t              candidateForExtraTextOnlyLine = nextNotation && nextNotation.constructor === _ExsurgeChant.TextOnly && nextNotation.lyrics[extraTextOnlyLyricIndex] && nextNotation.lyrics[extraTextOnlyLyricIndex].text.length > 0;\n\t            }\n\t          }\n\t        }\n\t        if (candidateForExtraTextOnlyLine) {\n\t          // a special case for TextOnly elements that don't fit on the line: since they don't have neumes associated with them, we can place this\n\t          // and any additional TextOnly elements just below the current lyric lines, but we can only do this if the TextOnly elements have only one\n\t          // line of lyrics associated with them.\n\t          var firstOnLine;\n\t          extraTextOnlyLyricIndex = this.extraTextOnlyLyricIndex;\n\t          if (this.extraTextOnlyIndex === null && notations[textOnlyStartIndex].lyrics.length) {\n\t            if (textOnlyStartIndex === this.notationsStartIndex || !ctxt.startExtraTextOnlyFromFirst) {\n\t              textOnlyStartIndex = i;\n\t              var lastNotationWithLyrics = notations.slice(this.notationsStartIndex, i).reverse().find(function (notation) {\n\t                return notation.hasLyrics();\n\t              });\n\t              lastLyricsBeforeTextOnly = lastNotationWithLyrics && lastNotationWithLyrics.lyrics.slice() || [];\n\t            }\n\t            // go back to the first in this string of consecutive TextOnly elements.\n\t            this.extraTextOnlyIndex = textOnlyStartIndex;\n\t            extraTextOnlyLyricIndex = this.extraTextOnlyLyricIndex = _ExsurgeDrawing.LyricArray.indexOfLyric(curr.lyrics);\n\t            this.lastLyricsBeforeTextOnly = lastLyricsBeforeTextOnly;\n\t            this.lastLyrics = [];\n\t            i = textOnlyStartIndex - 1;\n\t            this.numNotationsOnLine = textOnlyStartIndex - this.notationsStartIndex;\n\t            continue;\n\t          }\n\t          delete curr.lyrics[extraTextOnlyLyricIndex].lineWidth;\n\t          if (!fitsOnLine || i === this.extraTextOnlyIndex) {\n\t            curr.bounds.x = curr.lyrics[extraTextOnlyLyricIndex].origin.x;\n\t            var lastLyricRight = ctxt.startExtraTextOnlyFromFirst ? _ExsurgeDrawing.LyricArray.getRight(this.lastLyrics) + (ctxt.minLyricWordSpacing || 0) : 0;\n\t            curr.lyrics[extraTextOnlyLyricIndex].setMaxWidth(ctxt, this.staffRight, this.staffRight - lastLyricRight);\n\t            firstOnLine = curr;\n\t          }\n\t          if (firstOnLine) firstOnLine.lyrics[extraTextOnlyLyricIndex].lineWidth = curr.lyrics[extraTextOnlyLyricIndex].getRight();\n\t        } else if (fitsOnLine === false) {\n\t          var isTextOnlyBeforeDivider = function isTextOnlyBeforeDivider(i) {\n\t            var curr = notations[i];\n\t            if (curr.constructor !== _ExsurgeChant.TextOnly) return false;\n\t            var firstDivider = notations.slice(i + 1).findIndex(function (notation) {\n\t              return notation.isDivider;\n\t            });\n\t            if (firstDivider < 0) return false;\n\t            return notations.slice(i + 1, i + 1 + firstDivider).every(function (notation) {\n\t              return notation.constructor === _ExsurgeChant.TextOnly;\n\t            });\n\t          };\n\t          // first check for elements that cannot begin a system: dividers and custodes\n\t          while (this.numNotationsOnLine > 1 && (curr.isDivider || curr.constructor === _ExsurgeChantSigns.Custos || isTextOnlyBeforeDivider(i))) {\n\t            curr = notations[--i];\n\t            this.numNotationsOnLine--;\n\t            if (this.lastLyricsBeforeTextOnly && isTextOnlyBeforeDivider(i)) {\n\t              delete this.lastLyricsBeforeTextOnly;\n\t            }\n\t          }\n\t\n\t          if (lastTranslationTextWithEndNeume) {}\n\t          // console.info(notations[i - 1], lastTranslationTextWithEndNeume);\n\t          // TODO?: need to go back to before the last translation text start:\n\t\n\t\n\t          // count syllables and notes\n\t          var notationsAfterBreak = notations.slice(i + 1);\n\t          var countSyllables = 0;\n\t          var countNotes = 0;\n\t          if (ctxt.minSyllablesLastLine && ctxt.minNotesLastLine) {\n\t            countSyllables = notationsAfterBreak.filter(function (notation) {\n\t              return notation.hasLyrics();\n\t            }).length;\n\t            countNotes = notationsAfterBreak.flatMap(function (notation) {\n\t              return notation.notes;\n\t            }).filter(function (note) {\n\t              return !!note;\n\t            }).length;\n\t          }\n\t\n\t          // check if the prev elements want to be kept with this one\n\t          for (j = i - 1; j > this.notationsStartIndex; j--) {\n\t            var cne = notations[j];\n\t            curr = notations[j + 1];\n\t\n\t            // curr is the first notation on the next line\n\t            // cne is the last notation on this line\n\t            if (ctxt.minSyllablesLastLine && ctxt.minNotesLastLine) {\n\t              countSyllables += curr.hasLyrics() ? 1 : 0;\n\t              countNotes += (curr.notes || []).length;\n\t            }\n\t\n\t            if (cne.firstWithNoWidth) {\n\t              this.numNotationsOnLine--;\n\t              continue;\n\t            }\n\t\n\t            // don't let a line break occur in the middle of a translation\n\t            if (lastTranslationTextWithEndNeume) {\n\t              this.numNotationsOnLine--;\n\t              if (cne === lastTranslationTextWithEndNeume) {\n\t                lastTranslationTextWithEndNeume = null;\n\t              }\n\t              continue;\n\t            }\n\t\n\t            // force any notations starting with a quilisma or inclinatum (diamond) to be kept with the previous notation:\n\t            if (curr && curr.notes && (curr.notes[0].shape === _ExsurgeChant.NoteShape.Quilisma || curr.notes[0].shape === _ExsurgeChant.NoteShape.Inclinatum)) {\n\t              this.numNotationsOnLine--;\n\t              continue;\n\t            }\n\t\n\t            if (countSyllables < ctxt.minSyllablesLastLine && countNotes < ctxt.minNotesLastLine) {\n\t              this.numNotationsOnLine--;\n\t              continue;\n\t            }\n\t\n\t            // if the line break is allowed (cne.allowLineBreakBeforeNext), keep this number of notations around so we can check during justification\n\t            // whether there would be too much space introduced between\n\t            if (cne.keepWithNext === true) {\n\t              if (cne.allowLineBreakBeforeNext && !this.maxNumNotationsOnLine) this.maxNumNotationsOnLine = this.numNotationsOnLine;\n\t              this.numNotationsOnLine--;\n\t            } else break;\n\t          }\n\t          if (this.extraTextOnlyIndex && this.notationsStartIndex + this.numNotationsOnLine <= this.extraTextOnlyIndex) {\n\t            // we've cut back to before the extra text only index, so we have to remove it:\n\t            this.extraTextOnlyIndex = null;\n\t          }\n\t\n\t          // if for some reason not a single notation can fit on the line, we'd better put it on anyway, to avoid an infinite loop:\n\t          if (this.numNotationsOnLine === 0) this.numNotationsOnLine = 1;\n\t\n\t          // determine the neumes we can space apart, if we do end up justifying\n\t          curr = this.findNeumesToJustify(prevLyrics);\n\t\n\t          this.lastLyrics = prevLyrics;\n\t          if (this.maxNumNotationsOnLine) {\n\t            // Check whether we should squeeze some extra notations on the line to avoid too much space after justification:\n\t            // Check how much space we would have without the extra notations\n\t            var extraSpace = this.getWhitespaceOnRight(ctxt);\n\t            if (extraSpace / this.toJustify.length > ctxt.staffInterval * ctxt.maxExtraSpaceInStaffIntervals) {\n\t              _ExsurgeDrawing.LyricArray.mergeInArray(prevLyrics, notations.slice(this.notationsStartIndex + this.numNotationsOnLine, this.notationsStartIndex + this.maxNumNotationsOnLine));\n\t              this.numNotationsOnLine = this.maxNumNotationsOnLine;\n\t              delete this.maxNumNotationsOnLine;\n\t            }\n\t          }\n\t\n\t          // if the next line begins with a fresh word, than there can be extra space between the last notation on this line and the custos:\n\t          var next = this.score.notations[this.extraTextOnlyIndex === null ? this.notationsStartIndex + this.numNotationsOnLine : this.extraTextOnlyIndex];\n\t          if (next && next.hasLyrics() && (next.lyrics[0].lyricType === _ExsurgeDrawing.LyricType.BeginningSyllable || next.lyrics[0].lyricType === _ExsurgeDrawing.LyricType.SingleSyllable)) {\n\t            this.toJustify.push(this.custos);\n\t          }\n\t\n\t          if (j >= 1 && notations[j].isDivider && notations[j - 1].constructor === _ExsurgeChantSigns.Custos) {\n\t            // reverse the order: put the divider first, and end the line with the custos.\n\t            prevLyrics = [];\n\t            for (i = j - 2; i >= this.notationsStartIndex; i--) {\n\t              if (notations[i].hasLyrics()) {\n\t                _ExsurgeDrawing.LyricArray.mergeIn(prevLyrics, notations[i].lyrics);\n\t                break;\n\t              }\n\t            }\n\t            // remove the custos and divider from the condensable spaces list, before adding the divider back, when repositioning it.\n\t            condensableSpaces.sum -= condensableSpaces.pop().condensable;\n\t            condensableSpaces.sum -= condensableSpaces.pop().condensable;\n\t            this.positionNotationElement(ctxt, prevLyrics, notations[j - 2], notations[j], this.staffRight, condensableSpaces);\n\t            this.custos = notations[j - 1];\n\t            this.custos.bounds.x = this.staffRight - this.custos.bounds.width - this.custos.leadingSpace;\n\t          }\n\t\n\t          // we are at the end of the line!\n\t          break;\n\t        }\n\t\n\t        if (curr.hasLyrics()) _ExsurgeDrawing.LyricArray.mergeIn(this.lastLyrics, curr.lyrics);\n\t\n\t        if (lastTranslationTextWithEndNeume && curr === lastTranslationTextWithEndNeume.translationText[0].endNeume) {\n\t          lastTranslationTextWithEndNeume = null;\n\t        } else if (curr.translationText && curr.translationText.length && curr.translationText[0].endNeume) {\n\t          lastTranslationTextWithEndNeume = curr;\n\t        }\n\t\n\t        curr.line = this;\n\t        this.numNotationsOnLine++;\n\t\n\t        if (curr.isClef) ctxt.activeClef = curr;\n\t\n\t        // line breaks are a special case indicating to stop processing here\n\t        if (curr.constructor === _ExsurgeChant.ChantLineBreak && width > 0) {\n\t          this.justify = curr.justify || this.extraTextOnlyIndex !== null || this.getWhitespaceOnRight(ctxt) < 0;\n\t          if (this.justify) this.findNeumesToJustify(prevLyrics);\n\t          break;\n\t        }\n\t\n\t        if (curr.constructor === _ExsurgeChantSigns.Custos) {\n\t          this.custos = curr;\n\t        } else if (curr.isNeume) {\n\t          this.custos = null;\n\t        }\n\t      }\n\t\n\t      var lastIndex = this.notationsStartIndex + this.numNotationsOnLine - 1;\n\t      var last = notations[lastIndex] || {};\n\t      while (lastIndex > 0 && (last.constructor === _ExsurgeChant.ChantLineBreak || last.constructor === _ExsurgeChantSigns.Custos || last.constructor === _ExsurgeChant.TextOnly)) {\n\t        last = notations[--lastIndex];\n\t      }\n\t      var isLastLine = this.notationsStartIndex + this.numNotationsOnLine === notations.length;\n\t      if (this.justify && this.extraTextOnlyIndex !== null || width > 0 && isLastLine) {\n\t        // this is the last chant line, or it has extra TextOnly elements at the end\n\t        if (!this.toJustify) this.findNeumesToJustify(prevLyrics);\n\t        this.justify = (!isLastLine || last.isDivider) && this.getWhitespaceOnRight(ctxt) / (this.toJustify.length || 1) <= ctxt.staffInterval * ctxt.maxExtraSpaceInStaffIntervals;\n\t      }\n\t\n\t      if (!this.custos) {\n\t        // create the automatic custos at the end of the line if there are neumes left in the notations\n\t        for (i = this.notationsStartIndex + this.numNotationsOnLine; i < notations.length; i++) {\n\t          var notation = notations[i];\n\t\n\t          if (notation.isNeume) {\n\t            this.custos = new _ExsurgeChantSigns.Custos(true);\n\t            ctxt.currNotationIndex = i - 1; // make sure the context knows where the custos is\n\t            this.custos.performLayout(ctxt);\n\t\n\t            if (this.justify) {\n\t              // Put the custos at the very end of the line\n\t              this.custos.bounds.x = this.staffRight - this.custos.bounds.width - this.custos.leadingSpace;\n\t            } else {\n\t              this.custos.bounds.x = prevNeume.bounds.right() + prevNeume.calculatedTrailingSpace;\n\t            }\n\t            // nothing more to see here...\n\t            break;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (this.lastLyricsBeforeTextOnly) {\n\t        this.lastLyrics = this.lastLyricsBeforeTextOnly;\n\t        delete this.lastLyricsBeforeTextOnly;\n\t      }\n\t\n\t      // find the final lyric and mark it as connecting if needed.\n\t      if (width > 0) {\n\t        var whitespace = this.getWhitespaceOnRight();\n\t        var rightEdge = this.staffRight;\n\t        if (whitespace < 0) {\n\t          rightEdge -= whitespace;\n\t        }\n\t      }\n\t      i = 0;\n\t      while (this.lastLyrics && this.lastLyrics[i]) {\n\t        var lyrics = this.lastLyrics[i];\n\t        if (lyrics.allowsConnector()) {\n\t          lyrics.setNeedsConnector(true, 0);\n\t          if (width > 0 && ctxt.minLyricWordSpacing < ctxt.hyphenWidth) {\n\t            whitespace = rightEdge - lyrics.getRight();\n\t            // shrink the hyphen if we are already out of whitespace or if we would be if we used a regular hyphen:\n\t            if (whitespace < 0) {\n\t              var minHyphenWidth = Math.max(ctxt.hyphenWidth + whitespace, this.lastLyrics.length > 1 ? ctxt.intraNeumeSpacing : ctxt.minLyricWordSpacing);\n\t              // we might not need to shift the syllable, but we do want to shrink the hyphen...\n\t              lyrics.setConnectorWidth(minHyphenWidth);\n\t            }\n\t          }\n\t        }\n\t        ++i;\n\t      }\n\t\n\t      // if the provided width is less than zero, then set the width of the line\n\t      // based on the last notation\n\t      if (width <= 0) {\n\t        var lastNotation = notations[this.notationsStartIndex + this.numNotationsOnLine - 1];\n\t        if (lastNotation) {\n\t          this.staffRight = lastNotation.bounds.right();\n\t        }\n\t        this.justify = false;\n\t      }\n\t\n\t      // Justify the line if we need to\n\t      this.justifyElements(ctxt, this.justify, condensableSpaces);\n\t\n\t      this.centerDividers();\n\t\n\t      if (width > 0 && isLastLine && this.score.extendLastSystemStaffLines !== true) {\n\t        // set the staff lines to only extend to the last element\n\t        var _lastNotation = notations[this.notationsStartIndex + this.numNotationsOnLine - 1];\n\t        if (_lastNotation) {\n\t          this.staffRight = _lastNotation.bounds.right();\n\t        }\n\t      }\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }, {\n\t    key: \"centerDividers\",\n\t    value: function centerDividers() {\n\t      var lastIndex = this.extraTextOnlyIndex === null ? this.notationsStartIndex + this.numNotationsOnLine : this.extraTextOnlyIndex,\n\t          curr;\n\t      for (var i = this.notationsStartIndex; i < lastIndex; i++) {\n\t        curr = this.score.notations[i];\n\t\n\t        if (curr && curr.isDivider) {\n\t          var j = 1;\n\t          var prev = this.score.notations[i - 1];\n\t          var next = i + 1 === lastIndex ? this.custos : this.score.notations[i + 1];\n\t          if (prev === next && next === this.custos) {\n\t            prev = this.score.notations[i - 2];\n\t            // force custos to right edge in this case, since it is a custos that exists\n\t            // regardless of line break, and would normally be before the double bar, but in this case it ends the line:\n\t            next.bounds.x = this.staffRight - next.bounds.width;\n\t          }\n\t          if (prev && next) {\n\t            //if (prev instanceof TextOnly || next instanceof TextOnly) continue;\n\t            var oldBoundsX = curr.bounds.x;\n\t            var barWidth = curr.bounds.width;\n\t            var leftPoint = prev instanceof _ExsurgeChant.TextOnly && prev.hasLyrics() ? prev.lyrics[0].getRight() : prev.bounds.right(),\n\t                rightPoint = next instanceof _ExsurgeChant.TextOnly && next.hasLyrics() ? next.lyrics[0].getLeft() : next.bounds.x;\n\t            if (prev instanceof _ExsurgeChant.TextOnly) {\n\t              var _prev = this.score.notations.slice(this.notationsStartIndex, i).reverse().find(function (notation) {\n\t                return !(notation instanceof _ExsurgeChant.TextOnly);\n\t              });\n\t              leftPoint = _prev ? _prev.bounds.right() : 0;\n\t            }\n\t            if (leftPoint) {\n\t              curr.bounds.x = (leftPoint + rightPoint - barWidth) / 2;\n\t            }\n\t            if (curr.hasLyrics()) {\n\t              var offset = oldBoundsX - curr.bounds.x;\n\t              for (j = curr.lyrics.length - 1; j >= 0; j--) {\n\t                curr.lyrics[j].bounds.x += offset;\n\t                curr.lyrics[j].needsLayout = true;\n\t              }\n\t            }\n\t          } else if (i === lastIndex - 1 && this.justify && (curr.constructor === _ExsurgeChantSigns.DoubleBar || curr.constructor === _ExsurgeChantSigns.FullBar)) {\n\t            curr.bounds.x = this.staffRight - curr.bounds.width;\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: \"findNeumesToJustify\",\n\t    value: function findNeumesToJustify(prevLyrics) {\n\t      this.toJustify = [];\n\t      var prev,\n\t          curr = null,\n\t          next = null,\n\t          nextOrCurr = null,\n\t          lastIndex = this.notationsStartIndex + this.numNotationsOnLine;\n\t      for (var i = this.notationsStartIndex; i < lastIndex; i++) {\n\t        prev = nextOrCurr;\n\t        curr = this.score.notations[i];\n\t        next = curr.isAccidental && this.score.notations[++i];\n\t        nextOrCurr = next || curr;\n\t        var hasLyrics = nextOrCurr.hasLyrics();\n\t\n\t        if (!curr || !prev) continue;\n\t\n\t        if (this.extraTextOnlyIndex !== null && i >= this.extraTextOnlyIndex && curr.constructor === _ExsurgeChant.TextOnly) continue;\n\t\n\t        if (prev !== null) {\n\t          _ExsurgeDrawing.LyricArray.mergeIn(prevLyrics, prev.lyrics);\n\t          if (prev.keepWithNext === true) continue;\n\t        }\n\t\n\t        if (!curr.isDivider && prevLyrics.length && prevLyrics[0].allowsConnector() && hasLyrics) continue;\n\t\n\t        if (nextOrCurr.constructor === _ExsurgeChant.ChantLineBreak) continue;\n\t\n\t        if (nextOrCurr === this.custos && !hasLyrics) continue;\n\t\n\t        if (i === 0 && this.score.useDropCap && hasLyrics) continue;\n\t\n\t        // otherwise, we can add space before this element\n\t        this.toJustify.push(curr);\n\t      }\n\t      if (nextOrCurr !== null) _ExsurgeDrawing.LyricArray.mergeIn(prevLyrics, nextOrCurr.lyrics);\n\t      return nextOrCurr;\n\t    }\n\t  }, {\n\t    key: \"getWhitespaceOnRight\",\n\t    value: function getWhitespaceOnRight(ctxt) {\n\t      var notations = this.score.notations;\n\t      var lastIndex = this.notationsStartIndex + this.numNotationsOnLine;\n\t      var last = notations[lastIndex - 1];\n\t      if (this.extraTextOnlyIndex !== null && last.constructor === _ExsurgeChant.TextOnly) {\n\t        lastIndex = this.extraTextOnlyIndex;\n\t        last = notations[lastIndex - 1];\n\t      }\n\t      var lastRightNeume = last ? last.bounds.right() + last.calculatedTrailingSpace : 0;\n\t      var lastLyrics = this.lastLyricsBeforeTextOnly || this.lastLyrics;\n\t      var lastRightLyric = lastLyrics.length ? _ExsurgeDrawing.LyricArray.getRight(lastLyrics) : 0;\n\t\n\t      if (this.custos) {\n\t        lastRightNeume += this.custos.bounds.width + this.custos.leadingSpace;\n\t        if (this.custos.hasLyrics()) {\n\t          lastRightLyric = _ExsurgeDrawing.LyricArray.getRight(this.custos.lyrics);\n\t        }\n\t      } else if (ctxt && lastIndex < notations.length) {\n\t        lastRightNeume += _ExsurgeGlyphs.Glyphs.CustosLong.bounds.width * ctxt.glyphScaling;\n\t      }\n\t      return this.staffRight - Math.max(lastRightLyric, lastRightNeume);\n\t    }\n\t  }, {\n\t    key: \"justifyElements\",\n\t    value: function justifyElements(ctxt, doJustify, condensableSpaces) {\n\t      var i;\n\t      var toJustify = this.toJustify || [];\n\t      var notations = this.score.notations;\n\t      var lastIndex = this.notationsStartIndex + this.numNotationsOnLine;\n\t\n\t      // if it wasn't an ideal line break, and the last note is further from the custos than it would have been from its next punctum,\n\t      // move the custos over.\n\t      // We do this first so that if it opens up any new whitespace, that gets accounted for when we do the justification\n\t      var lastNotation = notations[this.notationsStartIndex + this.numNotationsOnLine - 1];\n\t      var extraSpaceBeforeCustos = this.staffRight < Infinity && this.custos && lastNotation.keepWithNext && this.custos.bounds.x - lastNotation.bounds.right() - lastNotation.calculatedTrailingSpace;\n\t      if (extraSpaceBeforeCustos > 0) {\n\t        // first, shrink the hyphen(s) if applicable, to move the neumes closer to the custos:\n\t        i = 0;\n\t        while (this.lastLyrics && this.lastLyrics[i]) {\n\t          var lyrics = this.lastLyrics[i];\n\t          if (lyrics.allowsConnector()) {\n\t            var connectorWidth = lyrics.getConnectorWidth();\n\t            if (ctxt.minLyricWordSpacing < connectorWidth) {\n\t              var minHyphenWidth = Math.max(connectorWidth - extraSpaceBeforeCustos, this.lastLyrics.length > 1 ? ctxt.intraNeumeSpacing : ctxt.minLyricWordSpacing);\n\t              // we might not need to shift the syllable, but we do want to shrink the hyphen...\n\t              lyrics.setConnectorWidth(minHyphenWidth);\n\t            }\n\t          }\n\t          ++i;\n\t        }\n\t        this.custos.bounds.x = lastNotation.bounds.right() + lastNotation.calculatedTrailingSpace;\n\t      }\n\t\n\t      // first step of justification is to determine how much space we have to use up\n\t      var extraSpace = this.getWhitespaceOnRight();\n\t\n\t      if (Math.abs(extraSpace) < 0.5 || extraSpace > 0 && (doJustify && toJustify.length === 0 || !doJustify)) return;\n\t\n\t      this.condensableSpaces = condensableSpaces;\n\t\n\t      var curr, prev;\n\t      var offset = 0;\n\t      var increment = extraSpace / toJustify.length;\n\t      var multiplier = 0;\n\t      var toJustifyIndex = 0;\n\t      if (extraSpace < 0) {\n\t        toJustify = condensableSpaces.filter(function (s) {\n\t          return s.condensable > 0;\n\t        });\n\t        multiplier = extraSpace / condensableSpaces.sum;\n\t        increment = 0;\n\t      }\n\t      var nextToJustify = toJustify[toJustifyIndex++];\n\t      var incrementOffsetAtNextChance = false;\n\t      for (i = this.notationsStartIndex; i < lastIndex; i++) {\n\t        prev = curr;\n\t        curr = notations[i];\n\t\n\t        if (this.extraTextOnlyIndex !== null && i >= this.extraTextOnlyIndex && curr.constructor === _ExsurgeChant.TextOnly) {\n\t          continue;\n\t        }\n\t\n\t        if (!multiplier && curr === this.custos) {\n\t          if (curr.hasLyrics()) {\n\t            curr.bounds.x = Math.min(curr.bounds.x + (this.staffRight - _ExsurgeDrawing.LyricArray.getRight(curr.lyrics)), this.staffRight - curr.bounds.width);\n\t            offset += increment;\n\t          } else {\n\t            curr.bounds.x = Math.min(curr.bounds.x + offset, this.staffRight - curr.bounds.width);\n\t          }\n\t          continue;\n\t        }\n\t\n\t        if (multiplier) {\n\t          if (nextToJustify && nextToJustify.notation === curr) {\n\t            offset += multiplier * nextToJustify.condensable;\n\t            nextToJustify = toJustify[toJustifyIndex++];\n\t          }\n\t        } else if (nextToJustify === curr) {\n\t          if (prev.hasNoWidth) {\n\t            incrementOffsetAtNextChance = true;\n\t          } else {\n\t            offset += increment;\n\t          }\n\t          nextToJustify = toJustify[toJustifyIndex++];\n\t        } else if (incrementOffsetAtNextChance && !prev.hasNoWidth) {\n\t          incrementOffsetAtNextChance = false;\n\t          offset += increment;\n\t        }\n\t\n\t        curr.bounds.x += offset;\n\t      }\n\t\n\t      if (extraSpaceBeforeCustos > 0) {\n\t        this.custos.bounds.x = lastNotation.bounds.right() + lastNotation.calculatedTrailingSpace;\n\t      }\n\t    }\n\t  }, {\n\t    key: \"handleEndBrace\",\n\t    value: function handleEndBrace(ctxt, note, i) {\n\t      var startBrace = ctxt.lastStartBrace;\n\t      if (!startBrace) return;\n\t      // calculate the y value of the brace by iterating over all notations\n\t      // under/over the brace.\n\t      var y;\n\t      var k = startBrace.notationIndex;\n\t      var notations = this.score.notations;\n\t      var dy = ctxt.intraNeumeSpacing / 2; // some safe space between brace and notes.\n\t      var startNote = startBrace.note;\n\t\n\t      if (startBrace.isAbove) {\n\t        y = Math.min.apply(Math, [ctxt.calculateHeightFromStaffPosition(this.score.staffLineCount * 2)].concat(_toConsumableArray([startNote, note].concat(notations.slice(k, i + 1)).map(function (n) {\n\t          return n.bounds.y - dy;\n\t        }))));\n\t      } else {\n\t        y = Math.max.apply(Math, [ctxt.calculateHeightFromStaffPosition(0)].concat(_toConsumableArray([startNote, note].concat(notations.slice(k, i + 1)).map(function (n) {\n\t          return n.bounds.bottom() + dy;\n\t        }))));\n\t      }\n\t\n\t      var addAcuteAccent = false;\n\t\n\t      if (startBrace.shape === _ExsurgeChantMarkings.BraceShape.RoundBrace) {\n\t        this.braces.push(new _ExsurgeDrawing.RoundBraceVisualizer(ctxt, startBrace.getAttachmentX(startNote), note.braceEnd.getAttachmentX(note), y, startBrace.isAbove));\n\t      } else {\n\t        if (startBrace.shape === _ExsurgeChantMarkings.BraceShape.AccentedCurlyBrace) addAcuteAccent = true;\n\t\n\t        this.braces.push(new _ExsurgeDrawing.CurlyBraceVisualizer(ctxt, startBrace.getAttachmentX(startNote), note.braceEnd.getAttachmentX(note), y, startBrace.isAbove, addAcuteAccent));\n\t      }\n\t\n\t      delete ctxt.lastStartBrace;\n\t    }\n\t  }, {\n\t    key: \"finishLayout\",\n\t    value: function finishLayout(ctxt) {\n\t      var _this2 = this;\n\t\n\t      this.ledgerLines = []; // clear any existing ledger lines\n\t\n\t      var notations = this.score.notations;\n\t      var lastIndex = this.notationsStartIndex + this.numNotationsOnLine;\n\t\n\t      // an element needs to have a staffPosition property, as well as the standard\n\t      // bounds property. so it could be a note, or it could be a custos\n\t      // offsetX can be used to add to the position info for the element,\n\t      // useful in the case of notes.\n\t      var processElementForLedgerLine = function processElementForLedgerLine(element) {\n\t        var endElem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : element;\n\t        var staffPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : element.staffPosition;\n\t        var offsetX = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : element.neume ? element.neume.bounds.x : 0;\n\t\n\t        // do we need a ledger line for this note?\n\t        var ledgerLinePositionAbove = ctxt.staffLineCount * 2 + 1;\n\t        if (staffPosition >= ledgerLinePositionAbove || staffPosition <= -1) {\n\t          var x1 = offsetX + element.bounds.x - ctxt.intraNeumeSpacing;\n\t          var x2 = offsetX + endElem.bounds.x + endElem.bounds.width + ctxt.intraNeumeSpacing;\n\t\n\t          // round the staffPosition to the nearest line\n\t          if (staffPosition > 0) staffPosition = staffPosition - (staffPosition - 1) % 2;else staffPosition = staffPosition - (staffPosition + 1) % 2;\n\t\n\t          // if we have a ledger line close by, then average out the distance between the two\n\t          var minLedgerSeparation = ctxt.staffInterval * ctxt.minLedgerSeparation;\n\t\n\t          if (_this2.ledgerLines.length > 0 && _this2.ledgerLines[_this2.ledgerLines.length - 1].x2 + minLedgerSeparation >= x1) {\n\t            // average out the distance\n\t            var half = (x1 - _this2.ledgerLines[_this2.ledgerLines.length - 1].x2) / 2;\n\t            _this2.ledgerLines[_this2.ledgerLines.length - 1].x2 += half;\n\t            x1 -= half;\n\t          }\n\t\n\t          // never let a ledger line extend past the staff width\n\t          if (x2 > _this2.staffRight) x2 = _this2.staffRight;\n\t\n\t          // finally, add the ledger line\n\t          _this2.ledgerLines.push({\n\t            x1: x1,\n\t            x2: x2,\n\t            staffPosition: staffPosition\n\t          });\n\t        }\n\t      };\n\t\n\t      var episemata = []; // keep track of episemata in case we can connect some\n\t      var startBrace = null;\n\t      var minY = Number.MAX_VALUE,\n\t          maxY = Number.MIN_VALUE; // for braces\n\t\n\t      var positionNonLyricText = function positionNonLyricText(text, neume, rightX) {\n\t        text.setMaxWidth(ctxt, _this2.staffRight);\n\t        //text.bounds.x = neume.hasLyrics()? Math.min(...neume.lyrics.map(l => l.bounds.x)) : 0;\n\t        text.bounds.x = 0;\n\t        if (rightX) text.bounds.x = (text.bounds.x + rightX - text.bounds.width) / 2;\n\t        var beyondStaffRight = neume.bounds.x + text.bounds.right() - _this2.staffRight;\n\t        if (beyondStaffRight > 0) {\n\t          text.bounds.x -= beyondStaffRight;\n\t        }\n\t        if (neume.bounds.x + text.bounds.x < 0) {\n\t          text.bounds.x = -neume.bounds.x;\n\t        }\n\t      };\n\t\n\t      // make a final pass over all of the notes to add any necessary\n\t      // ledger lines and to smooth out episemata\n\t      for (var i = this.notationsStartIndex; i < lastIndex; i++) {\n\t        var neume = notations[i];\n\t\n\t        minY = Math.min(minY, neume.bounds.y);\n\t        maxY = Math.max(maxY, neume.bounds.bottom());\n\t\n\t        if (neume.constructor === _ExsurgeChantSigns.Custos) {\n\t          processElementForLedgerLine(neume);\n\t          continue;\n\t        }\n\t\n\t        // if the AboveLinesText would extend beyond the right edge of the staff, right align it instead\n\t        if (neume.alText) {\n\t          for (var j = 0; j < neume.alText.length; j++) {\n\t            positionNonLyricText(neume.alText[j], neume);\n\t          }\n\t        }\n\t\n\t        // set up horizontal position of translations\n\t        if (neume.translationText) {\n\t          for (j = 0; j < neume.translationText.length; j++) {\n\t            var text = neume.translationText[j];\n\t            if (text.endNeume) {\n\t              var rightX = text.endNeume.hasLyrics() ? text.endNeume.bounds.x + Math.max.apply(Math, _toConsumableArray(text.endNeume.lyrics.map(function (l) {\n\t                return l.bounds.right();\n\t              }))) : text.endNeume.bounds.right();\n\t              rightX -= neume.bounds.x;\n\t              positionNonLyricText(text, neume, rightX);\n\t            } else {\n\t              positionNonLyricText(text, neume);\n\t            }\n\t          }\n\t        }\n\t\n\t        // if it's not a neume then just skip here\n\t        if (!neume.isNeume) continue;\n\t\n\t        for (j = 0; j < neume.ledgerLines.length; j++) {\n\t          var ll = neume.ledgerLines[j];\n\t          processElementForLedgerLine(ll.element, ll.endElem, ll.staffPosition);\n\t        }\n\t\n\t        for (j = 0; j < neume.notes.length; j++) {\n\t          var k,\n\t              note = neume.notes[j];\n\t\n\t          // blend episemata as we're able\n\t          if (note.episemata.length === 0) episemata = [];\n\t          for (k = 0; k < note.episemata.length; k++) {\n\t            var episema = note.episemata[k];\n\t\n\t            var spaceBetweenEpisemata = 0;\n\t\n\t            // calculate the distance between the last episemata and this one...\n\t            // lots of code for a simple: currEpisemata.left - prevEpisemata.right\n\t            if (episemata.length > 0) spaceBetweenEpisemata = neume.bounds.x + episema.bounds.x - (episemata[episemata.length - 1].note.neume.bounds.x + episemata[episemata.length - 1].bounds.right());\n\t\n\t            // we try to blend the episema if we're able.\n\t            if (episemata.length === 0 || episemata[episemata.length - 1].positionHint !== episema.positionHint || episemata[episemata.length - 1].terminating === true || episemata[episemata.length - 1].alignment === _ExsurgeChantMarkings.HorizontalEpisemaAlignment.Left || episemata[episemata.length - 1].alignment === _ExsurgeChantMarkings.HorizontalEpisemaAlignment.Center || episema.alignment === _ExsurgeChantMarkings.HorizontalEpisemaAlignment.Right || episema.alignment === _ExsurgeChantMarkings.HorizontalEpisemaAlignment.Center || spaceBetweenEpisemata > ctxt.intraNeumeSpacing * 2 && note.glyphVisualizer.glyphCode !== _ExsurgeDrawing.GlyphCode.None) {\n\t              // start a new set of episemata to potentially blend\n\t              episemata = [episema];\n\t            } else {\n\t              // blend all previous with this one\n\t              var newY;\n\t\n\t              if (episema.positionHint === _ExsurgeDrawing.MarkingPositionHint.Below) newY = Math.max(episema.bounds.y, episemata[episemata.length - 1].bounds.y);else newY = Math.min(episema.bounds.y, episemata[episemata.length - 1].bounds.y);\n\t\n\t              if (episema.bounds.y !== newY) episema.bounds.y = newY;else {\n\t                for (var l = 0; l < episemata.length; l++) {\n\t                  episemata[l].bounds.y = newY;\n\t                }\n\t              }\n\t\n\t              // extend the last episema to meet the new one\n\t              var newWidth = neume.bounds.x + episema.bounds.x - (episemata[episemata.length - 1].note.neume.bounds.x + episemata[episemata.length - 1].bounds.x);\n\t              if (newWidth < 0) {\n\t                newWidth *= -1;\n\t                episemata[episemata.length - 1].bounds.x -= newWidth;\n\t              }\n\t              episemata[episemata.length - 1].bounds.width = newWidth;\n\t\n\t              episemata.push(episema);\n\t            }\n\t          }\n\t\n\t          if (note.braceEnd) this.handleEndBrace(ctxt, note, i);\n\t\n\t          if (note.braceStart) {\n\t            ctxt.lastStartBrace = startBrace = note.braceStart;\n\t            startBrace.notationIndex = i;\n\t          }\n\t        }\n\t      }\n\t\n\t      // if we still have an active brace, that means it spands two chant lines!\n\t      if (startBrace !== null) {\n\t        if (this.custos) {\n\t          // if the next end brace is on the first note following the line break, simply use it with the custos\n\t          // Do the same if there is only an accidental between\n\t          // otherwise, make a new end brace to work for this one, and a new start brace for the next line.\n\t          var nextNotation = notations[lastIndex];\n\t          var nextNote = nextNotation.notes && nextNotation.notes[0];\n\t          var nextNotationButOne = notations[lastIndex + 1];\n\t          var nextNoteButOne = nextNotationButOne && nextNotationButOne.notes && nextNotationButOne.notes[0];\n\t          var braceEnd = nextNote && nextNote.braceEnd || nextNotation.isAccidental && nextNoteButOne && nextNoteButOne.braceEnd;\n\t          if (braceEnd) {\n\t            this.custos.braceEnd = braceEnd;\n\t            this.handleEndBrace(ctxt, this.custos, i);\n\t          } else {\n\t            this.braceStart = startBrace;\n\t            this.custos.braceEnd = new _ExsurgeChantMarkings.BracePoint(this.custos, startBrace.isAbove, startBrace.shape, _ExsurgeChantMarkings.BraceAttachment.Right);\n\t            this.handleEndBrace(ctxt, this.custos, i - 1);\n\t            ctxt.lastStartBrace = new _ExsurgeChantMarkings.BracePoint(null, startBrace.isAbove, startBrace.shape, _ExsurgeChantMarkings.BraceAttachment.Left);\n\t            ctxt.lastStartBrace.notationIndex = i;\n\t          }\n\t        }\n\t      }\n\t\n\t      // don't forget to also include the final custos, which may need a ledger line too\n\t      if (this.custos) processElementForLedgerLine(this.custos);\n\t    }\n\t\n\t    // this is where the real core of positioning neumes takes place\n\t    // returns true if positioning was able to fit the neume before rightNotationBoundary.\n\t    // returns false if cannot fit before given right margin.\n\t    // fixme: if this returns false, shouldn't we set the connectors on prev to be activated?!\n\t\n\t  }, {\n\t    key: \"positionNotationElement\",\n\t    value: function positionNotationElement(ctxt, prevLyrics, prev, curr, rightNotationBoundary) {\n\t      var condensableSpaces = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];\n\t\n\t      if (!condensableSpaces.hasOwnProperty(\"sum\")) condensableSpaces.sum = 0;\n\t      var i,\n\t          space = { notation: curr },\n\t          fixedX = false;\n\t\n\t      // To begin we just place the current notation right after the previous,\n\t      // irrespective of lyrics.\n\t      // But if the previous neume was part of a polyphonic \"no width\" group and the current is not, or is of a separate group,\n\t      // we force it to have the same x as the previous group.\n\t      if ((!curr.hasNoWidth || curr.firstWithNoWidth === curr) && prev.firstWithNoWidth) {\n\t        curr.bounds.x = prev.firstWithNoWidth.bounds.x;\n\t        fixedX = true;\n\t      } else {\n\t        curr.bounds.x = prev.bounds.right();\n\t      }\n\t\n\t      if (curr.constructor === _ExsurgeChant.TextOnly && this.extraTextOnlyIndex === null || !curr.hasLyrics() && prev.calculatedTrailingSpace < 0) {\n\t        // We transfer over the trailing space from the previous neume if the current neume is text only,\n\t        // so that the text only neume has a better chance at not needing a connector.\n\t        curr.calculatedTrailingSpace = prev.calculatedTrailingSpace;\n\t        if (curr.hasLyrics()) curr.calculatedTrailingSpace -= curr.lyrics[0].bounds.width;\n\t        if (curr.constructor === _ExsurgeChant.TextOnly && curr.lyrics.length === 1) {\n\t          curr.lyrics[0].setMaxWidth(ctxt, this.staffRight, this.staffRight - _ExsurgeDrawing.LyricArray.getRight(prevLyrics) - ctxt.minLyricWordSpacing);\n\t        }\n\t      } else if (!fixedX) {\n\t        curr.bounds.x += prev.calculatedTrailingSpace;\n\t      }\n\t\n\t      if (curr.hasLyrics() && !prev.isDivider && !prev.isAccidental && this.numNotationsOnLine > 0 && (curr.lyrics[0].lyricType === _ExsurgeDrawing.LyricType.SingleSyllable || curr.lyrics[0].lyricType === _ExsurgeDrawing.LyricType.BeginningSyllable)) {\n\t        curr.bounds.x += ctxt.intraNeumeSpacing * ctxt.interVerbalMultiplier;\n\t      }\n\t      if (curr.hasNoWidth || fixedX) {\n\t        space.total = space.condensable = 0;\n\t      } else if (this.extraTextOnlyIndex !== null && curr.constructor === _ExsurgeChant.TextOnly) {\n\t        curr.bounds.x = 0;\n\t        space.total = space.condensable = 0;\n\t      } else {\n\t        space.total = curr.bounds.x - prev.bounds.right();\n\t        space.condensable = space.total * ctxt.condensingTolerance;\n\t      }\n\t\n\t      // if the previous notation has no lyrics, then we simply make sure the\n\t      // current notation with lyrics is in the bounds of the line\n\t      if (prevLyrics.length === 0) {\n\t        var maxRight = curr.bounds.right() + curr.calculatedTrailingSpace;\n\t\n\t        // if the lyric left is negative, then offset the neume appropriately\n\t        for (i = 0; i < curr.lyrics.length; i++) {\n\t          var currLyric = curr.lyrics[i];\n\t          // we hope for the best!\n\t          // but always use a connector if the lyric has original text that was all used up for the drop cap.\n\t          var needsConnector = currLyric.allowsConnector() && currLyric.dropCap && currLyric.originalText && !currLyric.text;\n\t          currLyric.setNeedsConnector(needsConnector);\n\t          var minLeft = this.staffLeft - this.paddingLeft;\n\t\n\t          if (currLyric.getLeft() < minLeft) curr.bounds.x -= currLyric.getLeft() - minLeft;\n\t\n\t          space.condensable = Math.min(space.condensable, currLyric.getLeft() - minLeft);\n\t          maxRight = Math.max(maxRight, currLyric.getRight());\n\t        }\n\t\n\t        if (maxRight > rightNotationBoundary + condensableSpaces.sum + space.condensable) return false;\n\t        condensableSpaces.push(space);\n\t        condensableSpaces.sum += space.condensable;\n\t        return true;\n\t      } else {\n\t        if (curr.firstOfSyllable && prevLyrics.length && !curr.hasLyrics()) {\n\t          curr.bounds.x = Math.max(curr.bounds.x, prevLyrics[0].getRight());\n\t          space.total = curr.bounds.x - prev.bounds.right();\n\t          space.condensable = space.total * ctxt.condensingTolerance;\n\t        }\n\t      }\n\t\n\t      // if the curr notation has no lyrics, then simply check whether there is enough room\n\t      if (curr.hasLyrics() === false) {\n\t        if (curr.bounds.right() + curr.calculatedTrailingSpace > rightNotationBoundary + condensableSpaces.sum + space.condensable) return false;\n\t        condensableSpaces.push(space);\n\t        condensableSpaces.sum += space.condensable;\n\t        return true;\n\t      }\n\t\n\t      // if we have multiple lyrics on the current or the previous notation,\n\t      // we will have to run several passes over each set of lyrics:\n\t\n\t      // on the first pass, we will check the absolute left-most placement of the new syllables\n\t      // we will make additional passes until everything is stable\n\t      do {\n\t        var hasShifted = false;\n\t        var atLeastOneWithoutConnector = false;\n\t        for (i = 0; i < curr.lyrics.length; i++) {\n\t          if (!curr.lyrics[i].originalText) continue;\n\t          var prevLyricRight = 0;\n\t          var condensableSpacesSincePrevLyric = [];\n\t          var condensableSpaceSincePrevLyric = null;\n\t          if (i < prevLyrics.length && prevLyrics[i]) {\n\t            prevLyricRight = prevLyrics[i].getRight();\n\t            var notationI = condensableSpaces.map(function (s) {\n\t              return s.notation;\n\t            }).lastIndexOf(prevLyrics[i].notation);\n\t            if (notationI >= 0) {\n\t              condensableSpacesSincePrevLyric = condensableSpaces.slice(notationI + 1);\n\t              condensableSpacesSincePrevLyric.sum = condensableSpacesSincePrevLyric.map(function (s) {\n\t                return s.condensable;\n\t              }).reduce(function (a, b) {\n\t                return a + b;\n\t              }, 0);\n\t            } else {\n\t              condensableSpacesSincePrevLyric.sum = 0;\n\t            }\n\t          }\n\t\n\t          curr.lyrics[i].setNeedsConnector(false); // we hope for the best!\n\t          var currLyricLeft = curr.lyrics[i].getLeft();\n\t          if (!prevLyrics[i] || prevLyrics[i].allowsConnector() === false) {\n\t            // No connector needed, but include space between words if necessary!\n\t            var extraSpace = currLyricLeft - prevLyricRight - ctxt.minLyricWordSpacing;\n\t            if (extraSpace < 0) {\n\t              // push the current element over a bit.\n\t              var shift = prevLyricRight + ctxt.minLyricWordSpacing - currLyricLeft;\n\t              curr.bounds.x += shift;\n\t              condensableSpaceSincePrevLyric = 0;\n\t              hasShifted = shift > 0.5;\n\t            } else {\n\t              condensableSpaceSincePrevLyric = extraSpace;\n\t            }\n\t          } else {\n\t            // we may need a connector yet...\n\t            if (prevLyricRight + 0.1 > currLyricLeft - condensableSpacesSincePrevLyric.sum - space.condensable) {\n\t              // in this case, the lyric elements actually overlap.\n\t              // so nope, no connector needed. instead, we just place the lyrics together\n\t              // fixme: for better text layout, we could actually use the kerning values\n\t              // between the prev and curr lyric elements!\n\t              var _shift = prevLyricRight - currLyricLeft;\n\t              if (_shift < -0.1) {\n\t                (function () {\n\t                  // in this case, the spacing needs to be condensed in the neumes since the last lyric...\n\t                  var multiplier = _shift / (condensableSpacesSincePrevLyric.sum + space.condensable);\n\t                  var offset = 0;\n\t                  condensableSpacesSincePrevLyric.forEach(function (s) {\n\t                    offset += multiplier * s.condensable;\n\t                    s.notation.bounds.x += offset;\n\t                  });\n\t                })();\n\t              }\n\t              curr.bounds.x += _shift;\n\t              condensableSpaceSincePrevLyric = 0;\n\t              atLeastOneWithoutConnector = true;\n\t              hasShifted = _shift > 0.5;\n\t            } else {\n\t              // bummer, looks like we couldn't merge the syllables together. Better add a connector...\n\t              if (ctxt.minLyricWordSpacing < ctxt.hyphenWidth) {\n\t                var spaceBetweenSyls = currLyricLeft - prevLyricRight;\n\t                if (spaceBetweenSyls < ctxt.hyphenWidth) {\n\t                  var minHyphenWidth = prevLyrics.length > 1 ? ctxt.intraNeumeSpacing : ctxt.minLyricWordSpacing;\n\t                  // we might not need to shift the syllable, but we do want to shrink the hyphen...\n\t                  prevLyrics[i].setConnectorWidth(Math.max(minHyphenWidth, spaceBetweenSyls));\n\t                }\n\t              }\n\t              prevLyrics[i].setNeedsConnector(true);\n\t              prevLyricRight = prevLyrics[i].getRight();\n\t\n\t              if (prevLyricRight + 0.1 > currLyricLeft) {\n\t                var _shift2 = prevLyricRight - currLyricLeft;\n\t                curr.bounds.x += _shift2;\n\t                condensableSpaceSincePrevLyric = 0;\n\t                hasShifted = _shift2 > 0.5;\n\t              } else {\n\t                condensableSpaceSincePrevLyric = currLyricLeft - prevLyricRight;\n\t              }\n\t            }\n\t          }\n\t\n\t          if (condensableSpaceSincePrevLyric !== null) {\n\t            if (condensableSpaceSincePrevLyric < condensableSpacesSincePrevLyric.sum + space.condensable) {\n\t              (function () {\n\t                // reduce condensable space so that lyrics retain at least the width of a space character between words:\n\t                var multiplier = condensableSpaceSincePrevLyric / (condensableSpacesSincePrevLyric.sum + space.condensable);\n\t                space.condensable *= multiplier;\n\t                if (condensableSpacesSincePrevLyric.sum) {\n\t                  condensableSpacesSincePrevLyric.forEach(function (space) {\n\t                    space.condensable *= multiplier;\n\t                  });\n\t                  condensableSpaces.sum = condensableSpaces.map(function (s) {\n\t                    return s.condensable;\n\t                  }).reduce(function (a, b) {\n\t                    return a + b;\n\t                  }, 0);\n\t                }\n\t              })();\n\t            }\n\t          }\n\t        }\n\t      } while (curr.lyrics.length > 1 && hasShifted && atLeastOneWithoutConnector);\n\t\n\t      for (i = Math.min(curr.lyrics.length, prevLyrics.length) - 1; i >= 0; i--) {\n\t        var pLyrics = prevLyrics[i];\n\t        if (pLyrics.needsConnector && pLyrics.connectorWidth) {\n\t          currLyricLeft = curr.lyrics[i].getLeft();\n\t          prevLyricRight = pLyrics.getRight() - pLyrics.connectorWidth;\n\t          spaceBetweenSyls = currLyricLeft - prevLyricRight;\n\t          if (spaceBetweenSyls >= ctxt.hyphenWidth) spaceBetweenSyls = 0;\n\t          pLyrics.setConnectorWidth(spaceBetweenSyls);\n\t        }\n\t      }\n\t\n\t      if (curr.bounds.right() + curr.calculatedTrailingSpace < rightNotationBoundary + condensableSpaces.sum + space.condensable && _ExsurgeDrawing.LyricArray.getRight(curr.lyrics, true) <= this.staffRight + condensableSpaces.sum + space.condensable) {\n\t        if (prev.isAccidental) {\n\t          // move the previous accidental up next to the current note:\n\t          var _shift3 = curr.bounds.x - prev.bounds.width - prev.calculatedTrailingSpace - prev.bounds.x;\n\t          prev.bounds.x += _shift3;\n\t          if (Math.abs(_shift3) > 0.1) {\n\t            var lastCondensable = condensableSpaces[condensableSpaces.length - 1];\n\t            condensableSpaces.sum -= lastCondensable.condensable;\n\t            lastCondensable.condensable = 0;\n\t          }\n\t        }\n\t        condensableSpaces.push(space);\n\t        condensableSpaces.sum += space.condensable;\n\t        return true;\n\t      }\n\t\n\t      // if we made it this far, then the element won't fit on this line.\n\t      return false;\n\t    }\n\t\n\t    /**\n\t     * Find the notation closest to x without going past it\n\t     * @param {number} x\n\t     */\n\t\n\t  }, {\n\t    key: \"bisectNotationAtX\",\n\t    value: function bisectNotationAtX(x) {\n\t      var useMidpoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t\n\t      var minIndex = -1,\n\t          maxIndex = Math.min(this.numNotationsOnLine, Infinity),\n\t          curIndex = minIndex + (maxIndex - minIndex >> 1),\n\t          notations = this.score.notations.slice(this.notationsStartIndex, this.notationsStartIndex + this.numNotationsOnLine);\n\t\n\t      while (minIndex < curIndex) {\n\t        var _notation = notations[curIndex];\n\t        var notationX = _notation.bounds.x;\n\t        if (notationX > x) {\n\t          maxIndex = curIndex;\n\t        } else {\n\t          minIndex = curIndex;\n\t        }\n\t        curIndex = minIndex + (maxIndex - minIndex >> 1);\n\t      }\n\t      var notation = notations[curIndex];\n\t      if (useMidpoint && notation && notation.bounds.width === 0 && curIndex + 1 < notations.length) {\n\t        var nextNotation = notations[curIndex + 1],\n\t            closenessToLeft = x - notation.bounds.x,\n\t            closenessToRight = nextNotation.bounds.x - x;\n\t        if (nextNotation.bounds.width === 0 && closenessToRight < closenessToLeft) ++curIndex;\n\t      }\n\t      return notations[curIndex];\n\t    }\n\t  }, {\n\t    key: \"staffSpaces\",\n\t    get: function get() {\n\t      return this.score.staffLineCount - 1;\n\t    }\n\t  }]);\n\t\n\t  return ChantLine;\n\t}(_ExsurgeDrawing.ChantLayoutElement);\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.BracePoint = exports.BraceAttachment = exports.BraceShape = exports.Mora = exports.Ictus = exports.HorizontalEpisema = exports.HorizontalEpisemaAlignment = exports.Accent = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _ExsurgeChant = __webpack_require__(8);\n\t\n\tvar _ExsurgeDrawing = __webpack_require__(4);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //\n\t// Author(s):\n\t// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>\n\t//\n\t// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a copy\n\t// of this software and associated documentation files (the \"Software\"), to deal\n\t// in the Software without restriction, including without limitation the rights\n\t// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\t// copies of the Software, and to permit persons to whom the Software is\n\t// furnished to do so, subject to the following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included in\n\t// all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\t// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\t// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\t// THE SOFTWARE.\n\t//\n\t\n\tvar Accent = exports.Accent = function (_GlyphVisualizer) {\n\t  _inherits(Accent, _GlyphVisualizer);\n\t\n\t  function Accent(ctxt, note) {\n\t    var glyphCode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _ExsurgeDrawing.GlyphCode.AcuteAccent;\n\t\n\t    _classCallCheck(this, Accent);\n\t\n\t    var _this = _possibleConstructorReturn(this, (Accent.__proto__ || Object.getPrototypeOf(Accent)).call(this, ctxt, glyphCode));\n\t\n\t    _this.note = note;\n\t    _this.positionHint = _ExsurgeDrawing.MarkingPositionHint.Above;\n\t    return _this;\n\t  }\n\t\n\t  _createClass(Accent, [{\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      this.bounds.x = this.note.bounds.x + this.bounds.width / 2; // center on the note itself\n\t\n\t      // this puts the acute accent either over the staff lines, or over the note if the\n\t      // note is above the staff lines\n\t      this.setStaffPosition(ctxt, Math.max(this.note.staffPosition + 1, 2 * ctxt.staffLineCount));\n\t    }\n\t  }]);\n\t\n\t  return Accent;\n\t}(_ExsurgeDrawing.GlyphVisualizer);\n\t\n\t// for positioning markings on notes\n\t\n\t\n\tvar HorizontalEpisemaAlignment = exports.HorizontalEpisemaAlignment = {\n\t  Default: 0,\n\t  Left: 1,\n\t  Center: 2,\n\t  Right: 3\n\t};\n\t\n\t/*\n\t * HorizontalEpisema\n\t *\n\t * A horizontal episema marking is it's own visualizer (that is, it implements createSvgFragment)\n\t */\n\t\n\tvar HorizontalEpisema = exports.HorizontalEpisema = function (_ChantLayoutElement) {\n\t  _inherits(HorizontalEpisema, _ChantLayoutElement);\n\t\n\t  function HorizontalEpisema(note) {\n\t    _classCallCheck(this, HorizontalEpisema);\n\t\n\t    var _this2 = _possibleConstructorReturn(this, (HorizontalEpisema.__proto__ || Object.getPrototypeOf(HorizontalEpisema)).call(this));\n\t\n\t    _this2.note = note;\n\t\n\t    _this2.positionHint = _ExsurgeDrawing.MarkingPositionHint.Default;\n\t    _this2.terminating = false; // indicates if this episema should terminate itself or not\n\t    _this2.alignment = HorizontalEpisemaAlignment.Default;\n\t    return _this2;\n\t  }\n\t\n\t  _createClass(HorizontalEpisema, [{\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      // following logic helps to keep the episemata away from staff lines if they get too close\n\t\n\t      var y = 0,\n\t          step;\n\t      var minDistanceAway = ctxt.staffInterval * 0.25; // min distance from neume\n\t      var glyphCode = this.note.glyphVisualizer.glyphCode;\n\t      var ledgerLine = this.note.neume.ledgerLines[0] || {};\n\t      var punctumInclinatumShorten = false;\n\t\n\t      if (glyphCode === _ExsurgeDrawing.GlyphCode.PunctumInclinatum) {\n\t        var notes = this.note.neume.notes,\n\t            index = notes.indexOf(this.note),\n\t            prevNote = notes[index - 1];\n\t        if (prevNote && prevNote.glyphVisualizer.glyphCode === _ExsurgeDrawing.GlyphCode.PunctumInclinatum && prevNote.staffPosition - this.note.staffPosition === 1) {\n\t          punctumInclinatumShorten = true;\n\t        }\n\t      }\n\t\n\t      var staffLineCountParity = ctxt.staffLineCount % 2 || 0;\n\t      var staffLineCountNonParity = (staffLineCountParity + 1) % 2;\n\t      if (this.positionHint === _ExsurgeDrawing.MarkingPositionHint.Below) {\n\t        y = this.note.bounds.bottom() + minDistanceAway; // the highest the line could be at\n\t        // convert y to be based around center Y between top and bottom staff lines so that it is symmetric:\n\t        y += ctxt.staffLineCount * ctxt.staffInterval;\n\t\n\t        if (glyphCode === _ExsurgeDrawing.GlyphCode.None)\n\t          // correction for episema under the second note of a porrectus\n\t          y += ctxt.staffInterval / 2;\n\t        step = Math.ceil(y / ctxt.staffInterval);\n\t        // if there's enough space, center the episema between the punctum and the next staff line\n\t        if (Math.abs(step % 2) === staffLineCountParity) {\n\t          step = (step + 3 / 4 + (y - minDistanceAway) / ctxt.staffInterval) / 2;\n\t        } else {\n\t          // otherwise, find nearest acceptable third between staff lines (or staff line)\n\t          step = (Math.ceil(1.5 * y / ctxt.staffInterval - 0.5) * 2 + staffLineCountNonParity) / 3;\n\t\n\t          // if it's an odd step, that means we're on a staff line,\n\t          // so we shift to between the staff line\n\t          if (Math.abs(step) % 2 === staffLineCountNonParity) {\n\t            if (Math.abs(step) < ctxt.staffLineCount || ctxt.convertStaffPositionToSymmetric(ledgerLine.staffPosition) === -step) {\n\t              step += 2 / 3;\n\t            } else {\n\t              // no ledger line, but we don't want the episema to be at exactly the same height the ledger line would occupy:\n\t              step += 1 / 3;\n\t            }\n\t          }\n\t        }\n\t      } else {\n\t        y = this.note.bounds.y - minDistanceAway; // the lowest the line could be at\n\t        // convert y to be based around center Y between top and bottom staff lines so that it is symmetric:\n\t        y += ctxt.staffLineCount * ctxt.staffInterval;\n\t\n\t        step = Math.floor(y / ctxt.staffInterval);\n\t        // if there's enough space, center the episema between the punctum and the next staff line\n\t        if (Math.abs(step % 2) === staffLineCountParity) {\n\t          step = (step - 3 / 4 + (y + minDistanceAway) / ctxt.staffInterval) / 2;\n\t        } else {\n\t          // otherwise, find nearest acceptable third between staff lines (or staff line)\n\t          step = (Math.floor(1.5 * y / ctxt.staffInterval - 0.5) * 2 + staffLineCountNonParity) / 3;\n\t\n\t          // find nearest acceptable third between staff lines (or staff line)\n\t          if (Math.abs(step) % 2 === staffLineCountNonParity) {\n\t            // if it was a staff line, we need to adjust\n\t            if (Math.abs(step) < ctxt.staffLineCount || ctxt.convertStaffPositionToSymmetric(ledgerLine.staffPosition) === -step) {\n\t              step -= 2 / 3;\n\t            } else {\n\t              // no ledger line, but we don't want the episema to be at exactly the same height the ledger line would occupy:\n\t              step -= 1 / 3;\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      y = (step - ctxt.staffLineCount) * ctxt.staffInterval;\n\t\n\t      var width = this.note.bounds.width;\n\t      var x = this.note.bounds.x;\n\t\n\t      // The porrectus requires special handling of the note width,\n\t      // otherwise the width is just that of the note itself\n\t      if (glyphCode === _ExsurgeDrawing.GlyphCode.Porrectus1 || glyphCode === _ExsurgeDrawing.GlyphCode.Porrectus2 || glyphCode === _ExsurgeDrawing.GlyphCode.Porrectus3 || glyphCode === _ExsurgeDrawing.GlyphCode.Porrectus4) width = ctxt.staffInterval;else if (glyphCode === _ExsurgeDrawing.GlyphCode.None) {\n\t        width = ctxt.staffInterval;\n\t        x -= width;\n\t      } else if (punctumInclinatumShorten) {\n\t        width *= 2 / 3;\n\t        x += 0.5 * width;\n\t      } else if (glyphCode === _ExsurgeDrawing.GlyphCode.PunctumInclinatumLiquescent) {\n\t        width *= 2 / 3;\n\t        x += 0.25 * width;\n\t      }\n\t\n\t      // also, the position hint can affect the x/width of the episema\n\t      if (this.alignment === HorizontalEpisemaAlignment.Left) {\n\t        width *= 0.8;\n\t      } else if (this.alignment === HorizontalEpisemaAlignment.Center) {\n\t        x += width * 0.1;\n\t        width *= 0.8;\n\t      } else if (this.alignment === HorizontalEpisemaAlignment.Right) {\n\t        x += width * 0.2;\n\t        width *= 0.8;\n\t      }\n\t\n\t      this.bounds.x = x;\n\t      this.bounds.y = y - ctxt.episemaLineWeight / 2;\n\t      this.bounds.width = width;\n\t      this.bounds.height = ctxt.episemaLineWeight;\n\t\n\t      this.origin.x = 0;\n\t      this.origin.y = 0;\n\t    }\n\t  }, {\n\t    key: \"draw\",\n\t    value: function draw(ctxt) {\n\t      var canvasCtxt = ctxt.canvasCtxt;\n\t\n\t      canvasCtxt.fillStyle = ctxt.neumeLineColor;\n\t\n\t      canvasCtxt.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);\n\t    }\n\t  }, {\n\t    key: \"getSvgProps\",\n\t    value: function getSvgProps(ctxt) {\n\t      return {\n\t        x: this.bounds.x,\n\t        y: this.bounds.y,\n\t        width: this.bounds.width,\n\t        height: this.bounds.height,\n\t        fill: ctxt.neumeLineColor,\n\t        class: \"horizontalEpisema\"\n\t      };\n\t    }\n\t  }, {\n\t    key: \"createSvgNode\",\n\t    value: function createSvgNode(ctxt) {\n\t      return _ExsurgeDrawing.QuickSvg.createNode(\"rect\", this.getSvgProps(ctxt));\n\t    }\n\t  }, {\n\t    key: \"createSvgTree\",\n\t    value: function createSvgTree(ctxt) {\n\t      return _ExsurgeDrawing.QuickSvg.createSvgTree(\"rect\", this.getSvgProps(ctxt));\n\t    }\n\t  }, {\n\t    key: \"createSvgFragment\",\n\t    value: function createSvgFragment(ctxt) {\n\t      return _ExsurgeDrawing.QuickSvg.createFragment(\"rect\", this.getSvgProps(ctxt));\n\t    }\n\t  }]);\n\t\n\t  return HorizontalEpisema;\n\t}(_ExsurgeDrawing.ChantLayoutElement);\n\t\n\t/*\n\t * Ictus\n\t */\n\t\n\t\n\tvar Ictus = exports.Ictus = function (_GlyphVisualizer2) {\n\t  _inherits(Ictus, _GlyphVisualizer2);\n\t\n\t  function Ictus(ctxt, note) {\n\t    _classCallCheck(this, Ictus);\n\t\n\t    var _this3 = _possibleConstructorReturn(this, (Ictus.__proto__ || Object.getPrototypeOf(Ictus)).call(this, ctxt, _ExsurgeDrawing.GlyphCode.VerticalEpisemaAbove));\n\t\n\t    _this3.note = note;\n\t    _this3.positionHint = _ExsurgeDrawing.MarkingPositionHint.Default;\n\t    return _this3;\n\t  }\n\t\n\t  _createClass(Ictus, [{\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      var glyphCode = this.note.glyphVisualizer.glyphCode;\n\t      // we have to place the ictus further from the note in some cases to avoid a collision with an episema on the same note:\n\t      var positionHint = this.positionHint || _ExsurgeDrawing.MarkingPositionHint.Below;\n\t      var staffPosition = this.note.staffPosition + (positionHint === _ExsurgeDrawing.MarkingPositionHint.Above ? 1 : -1);\n\t      var collisionWithEpisema = this.note.episemata.length > 0 && (this.note.episemata[0].positionHint || _ExsurgeDrawing.MarkingPositionHint.Above) === positionHint;\n\t      var horizontalOffset;\n\t      var verticalOffset = 1;\n\t      var shortOffset = -0.2;\n\t      var extraOffset = 0;\n\t      var collisionWithStaffLine = staffPosition % 2 && (Math.abs(ctxt.convertStaffPositionToSymmetric(staffPosition)) < ctxt.staffLineCount || (this.note.neume.ledgerLines[0] || {}).staffPosition === staffPosition);\n\t\n\t      // The porrectus requires special handling of the note width,\n\t      // otherwise the width is just that of the note itself\n\t      if (glyphCode === _ExsurgeDrawing.GlyphCode.Porrectus1 || glyphCode === _ExsurgeDrawing.GlyphCode.Porrectus2 || glyphCode === _ExsurgeDrawing.GlyphCode.Porrectus3 || glyphCode === _ExsurgeDrawing.GlyphCode.Porrectus4) horizontalOffset = ctxt.staffInterval / 2;else if (glyphCode === _ExsurgeDrawing.GlyphCode.None) {\n\t        horizontalOffset = -ctxt.staffInterval / 2;\n\t      } else {\n\t        horizontalOffset = this.note.bounds.width / 2;\n\t        if (glyphCode === _ExsurgeDrawing.GlyphCode.PunctumInclinatum && !collisionWithStaffLine && !collisionWithEpisema) {\n\t          extraOffset = 0.3;\n\t        }\n\t      }\n\t\n\t      if (this.positionHint === _ExsurgeDrawing.MarkingPositionHint.Above) {\n\t        glyphCode = _ExsurgeDrawing.GlyphCode.VerticalEpisemaAbove;\n\t        verticalOffset *= -1;\n\t      } else {\n\t        glyphCode = _ExsurgeDrawing.GlyphCode.VerticalEpisemaBelow;\n\t      }\n\t      if (collisionWithEpisema) {\n\t        extraOffset = 0.4;\n\t      }\n\t      verticalOffset *= ctxt.staffInterval * (extraOffset + (collisionWithStaffLine ? 0.3 : shortOffset));\n\t\n\t      this.setGlyph(ctxt, glyphCode);\n\t      this.setStaffPosition(ctxt, staffPosition);\n\t\n\t      this.bounds.x = this.note.bounds.x + horizontalOffset - this.origin.x;\n\t      this.bounds.y += verticalOffset;\n\t    }\n\t  }]);\n\t\n\t  return Ictus;\n\t}(_ExsurgeDrawing.GlyphVisualizer);\n\t\n\t/*\n\t * Mora\n\t */\n\t\n\t\n\tvar Mora = exports.Mora = function (_GlyphVisualizer3) {\n\t  _inherits(Mora, _GlyphVisualizer3);\n\t\n\t  function Mora(ctxt, note) {\n\t    _classCallCheck(this, Mora);\n\t\n\t    var _this4 = _possibleConstructorReturn(this, (Mora.__proto__ || Object.getPrototypeOf(Mora)).call(this, ctxt, _ExsurgeDrawing.GlyphCode.Mora));\n\t\n\t    _this4.note = note;\n\t    _this4.positionHint = _ExsurgeDrawing.MarkingPositionHint.Default;\n\t    _this4.horizontalOffset = ctxt.staffInterval / 2 + _this4.origin.x;\n\t    return _this4;\n\t  }\n\t\n\t  _createClass(Mora, [{\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      this.setGlyph(ctxt, this.glyphCode);\n\t      this.horizontalOffset = ctxt.staffInterval / 2 + this.origin.x;\n\t      var staffPosition = this.note.staffPosition;\n\t\n\t      this.setStaffPosition(ctxt, staffPosition);\n\t\n\t      var verticalOffset = 0;\n\t      // First, we need to find the next note in the neume.\n\t      var noteIndex = this.note.neume.notes.indexOf(this.note);\n\t      var nextNote;\n\t      if (noteIndex >= 0) {\n\t        ++noteIndex;\n\t        if (this.note.neume.notes.length > noteIndex) {\n\t          nextNote = this.note.neume.notes[noteIndex];\n\t          if (nextNote.morae && nextNote.morae.length && this.note.neume.notes.length === noteIndex + 1) {\n\t            // this note is the second to last in its neume, and the last note also has a mora\n\t            this.horizontalOffset += nextNote.bounds.right() - this.note.bounds.right();\n\t          } else if (nextNote.bounds.right() > this.note.bounds.right()) {\n\t            // center the dot over the following note.\n\t            this.horizontalOffset = (nextNote.bounds.right() - this.note.bounds.right() - this.bounds.right()) / 2;\n\t          } else {\n\t            nextNote = null;\n\t          }\n\t        } else if (this.note.neume.notes.length === noteIndex) {\n\t          // this note is the last in its neume:\n\t          if (this.note.neume.trailingSpace === 0) {\n\t            // if this was the last note in its neume, we only care about the next note if there is no trailing space at the end of this neume.\n\t            var notationIndex = this.note.neume.score.notations.indexOf(this.note.neume);\n\t            if (notationIndex >= 0) {\n\t              var nextNotation = this.note.neume.score.notations[notationIndex + 1];\n\t              if (nextNotation && nextNotation.notes) {\n\t                nextNote = nextNotation.notes[0];\n\t              }\n\t            }\n\t          } else if (this.note.shape !== _ExsurgeChant.NoteShape.Inclinatum) {\n\t            this.note.neume.calculatedTrailingSpace += this.origin.x;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (this.positionHint === _ExsurgeDrawing.MarkingPositionHint.Above) {\n\t        if (staffPosition % 2 === 0) verticalOffset -= ctxt.staffInterval * 1.75;else verticalOffset -= ctxt.staffInterval * 0.75;\n\t      } else if (this.positionHint === _ExsurgeDrawing.MarkingPositionHint.Below) {\n\t        if (staffPosition % 2 === 0) verticalOffset += ctxt.staffInterval * 1.75;else verticalOffset += ctxt.staffInterval * 0.75;\n\t      } else {\n\t        if (staffPosition % 2 === 0) {\n\t          // if the note is in a space and followed by a note on the line below, we often want to move the mora dot up slightly so that it is centered\n\t          // between the top of the note's space and the top of the following note.\n\t          if (nextNote && nextNote.staffPosition === staffPosition - 1) {\n\t            verticalOffset -= ctxt.staffInterval * 0.25;\n\t          }\n\t        } else {\n\t          verticalOffset -= ctxt.staffInterval * 0.75;\n\t        }\n\t      }\n\t      this.bounds.x = this.horizontalOffset + this.note.bounds.right();\n\t      this.bounds.y += verticalOffset;\n\t    }\n\t  }]);\n\t\n\t  return Mora;\n\t}(_ExsurgeDrawing.GlyphVisualizer);\n\t\n\t// indicates the shape of the brace\n\t\n\t\n\tvar BraceShape = exports.BraceShape = {\n\t  RoundBrace: 0,\n\t  CurlyBrace: 1,\n\t  AccentedCurlyBrace: 2\n\t};\n\t\n\t// indicates how the brace is alignerd to the note to which it's connected\n\tvar BraceAttachment = exports.BraceAttachment = {\n\t  Left: 0,\n\t  Right: 1\n\t};\n\t\n\tvar BracePoint = exports.BracePoint = function (_ChantLayoutElement2) {\n\t  _inherits(BracePoint, _ChantLayoutElement2);\n\t\n\t  function BracePoint(note, isAbove, shape, attachment) {\n\t    _classCallCheck(this, BracePoint);\n\t\n\t    var _this5 = _possibleConstructorReturn(this, (BracePoint.__proto__ || Object.getPrototypeOf(BracePoint)).call(this));\n\t\n\t    _this5.note = note;\n\t    _this5.isAbove = isAbove;\n\t    _this5.shape = shape;\n\t    _this5.attachment = attachment;\n\t    return _this5;\n\t  }\n\t\n\t  _createClass(BracePoint, [{\n\t    key: \"getAttachmentX\",\n\t    value: function getAttachmentX(note) {\n\t      if (!note) note = this.note;\n\t      if (this.attachment === BraceAttachment.Left) return (note.neume ? note.neume.bounds.x : 0) + note.bounds.x;else return (note.neume ? note.neume.bounds.x : 0) + note.bounds.right();\n\t    }\n\t  }]);\n\t\n\t  return BracePoint;\n\t}(_ExsurgeDrawing.ChantLayoutElement);\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Virgula = exports.Accidental = exports.AccidentalType = exports.DoubleBar = exports.DominicanBar = exports.InsertionCursor = exports.FullBar = exports.HalfBar = exports.QuarterBar = exports.Divider = exports.Custos = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tvar _ExsurgeCore = __webpack_require__(1);\n\t\n\tvar _ExsurgeDrawing = __webpack_require__(4);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //\n\t// Author(s):\n\t// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>\n\t//\n\t// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a copy\n\t// of this software and associated documentation files (the \"Software\"), to deal\n\t// in the Software without restriction, including without limitation the rights\n\t// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\t// copies of the Software, and to permit persons to whom the Software is\n\t// furnished to do so, subject to the following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included in\n\t// all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\t// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\t// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\t// THE SOFTWARE.\n\t//\n\t\n\t/*\n\t *\n\t */\n\tvar Custos = exports.Custos = function (_ChantNotationElement) {\n\t  _inherits(Custos, _ChantNotationElement);\n\t\n\t  // if auto is true, then the custos will automatically try to determine it's height based on\n\t  // subsequent notations\n\t  function Custos() {\n\t    var auto = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\t\n\t    _classCallCheck(this, Custos);\n\t\n\t    var _this = _possibleConstructorReturn(this, (Custos.__proto__ || Object.getPrototypeOf(Custos)).call(this));\n\t\n\t    _this.auto = auto;\n\t    _this.staffPosition = 2; // default sane value\n\t    return _this;\n\t  }\n\t\n\t  _createClass(Custos, [{\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(Custos.prototype.__proto__ || Object.getPrototypeOf(Custos.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      if (this.auto) {\n\t        var neume = ctxt.findNextNeume();\n\t\n\t        if (neume) this.staffPosition = ctxt.activeClef.pitchToStaffPosition(neume.notes[0].pitch);\n\t\n\t        // in case there was a weird fa/do clef change, let's sanitize the staffPosition by making sure it is\n\t        // within reasonable bounds\n\t        while (this.staffPosition < -2) {\n\t          this.staffPosition += 7;\n\t        }while (this.staffPosition > 2 * ctxt.staffLineCount + 2) {\n\t          this.staffPosition -= 7;\n\t        }\n\t      }\n\t\n\t      var glyph = new _ExsurgeDrawing.GlyphVisualizer(ctxt, Custos.getGlyphCode(this.staffPosition, ctxt.staffLineCount));\n\t      glyph.setStaffPosition(ctxt, this.staffPosition);\n\t      this.addVisualizer(glyph);\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t\n\t    // called when layout has changed and our dependencies are no longer good\n\t\n\t  }, {\n\t    key: \"resetDependencies\",\n\t    value: function resetDependencies() {\n\t      // we only need to resolve new dependencies if we're an automatic custos\n\t      if (this.auto) this.needsLayout = true;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @param {number} staffPosition position of custos\n\t     * @param {number} staffLineCount number of lines on staff\n\t     * @returns \n\t     */\n\t\n\t  }], [{\n\t    key: \"getGlyphCode\",\n\t    value: function getGlyphCode(staffPosition) {\n\t      var staffLineCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;\n\t\n\t      if (staffPosition <= staffLineCount * 2 - 2) {\n\t        // ascending custos\n\t        if (Math.abs(staffPosition) % 2 === 1) return _ExsurgeDrawing.GlyphCode.CustosLong;else return _ExsurgeDrawing.GlyphCode.CustosShort;\n\t      } else {\n\t        // descending custos\n\t        if (Math.abs(staffPosition) % 2 === 1) return _ExsurgeDrawing.GlyphCode.CustosDescLong;else return _ExsurgeDrawing.GlyphCode.CustosDescShort;\n\t      }\n\t    }\n\t  }]);\n\t\n\t  return Custos;\n\t}(_ExsurgeDrawing.ChantNotationElement);\n\t\n\t/*\n\t * Divider\n\t */\n\t\n\t\n\tvar Divider = exports.Divider = function (_ChantNotationElement2) {\n\t  _inherits(Divider, _ChantNotationElement2);\n\t\n\t  function Divider() {\n\t    var withCarryover = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\t\n\t    _classCallCheck(this, Divider);\n\t\n\t    var _this2 = _possibleConstructorReturn(this, (Divider.__proto__ || Object.getPrototypeOf(Divider)).call(this));\n\t\n\t    _this2.isDivider = true;\n\t    _this2.hasCarryover = withCarryover || false;\n\t    _this2.resetsAccidentals = true;\n\t    return _this2;\n\t  }\n\t\n\t  _createClass(Divider, [{\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(Divider.prototype.__proto__ || Object.getPrototypeOf(Divider.prototype), \"performLayout\", this).call(this, ctxt);\n\t      if (this.hasCarryover) {\n\t        var top = ctxt.staffLineCount * 2;\n\t        var y = ctxt.calculateHeightFromStaffPosition(top);\n\t        this.addVisualizer(new _ExsurgeDrawing.RoundBraceVisualizer(ctxt, -ctxt.staffInterval * 1.5, ctxt.staffInterval * 1.5, y, true));\n\t      }\n\t    }\n\t  }]);\n\t\n\t  return Divider;\n\t}(_ExsurgeDrawing.ChantNotationElement);\n\t\n\t/*\n\t * QuarterBar\n\t */\n\t\n\t\n\tvar QuarterBar = exports.QuarterBar = function (_Divider) {\n\t  _inherits(QuarterBar, _Divider);\n\t\n\t  function QuarterBar() {\n\t    _classCallCheck(this, QuarterBar);\n\t\n\t    return _possibleConstructorReturn(this, (QuarterBar.__proto__ || Object.getPrototypeOf(QuarterBar)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(QuarterBar, [{\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(QuarterBar.prototype.__proto__ || Object.getPrototypeOf(QuarterBar.prototype), \"performLayout\", this).call(this, ctxt);\n\t      var top = ctxt.staffLineCount * 2;\n\t      this.addVisualizer(new _ExsurgeDrawing.DividerLineVisualizer(ctxt, top - 2, top, this));\n\t      this.origin.x = this.bounds.width / 2;\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return QuarterBar;\n\t}(Divider);\n\t\n\t/*\n\t * HalfBar\n\t */\n\t\n\t\n\tvar HalfBar = exports.HalfBar = function (_Divider2) {\n\t  _inherits(HalfBar, _Divider2);\n\t\n\t  function HalfBar() {\n\t    _classCallCheck(this, HalfBar);\n\t\n\t    return _possibleConstructorReturn(this, (HalfBar.__proto__ || Object.getPrototypeOf(HalfBar)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(HalfBar, [{\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(HalfBar.prototype.__proto__ || Object.getPrototypeOf(HalfBar.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      var offset = ctxt.staffLineCount === 2 ? 1.5 : 2;\n\t      this.addVisualizer(new _ExsurgeDrawing.DividerLineVisualizer(ctxt, offset, ctxt.staffLineCount * 2 - offset, this));\n\t\n\t      this.origin.x = this.bounds.width / 2;\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return HalfBar;\n\t}(Divider);\n\t\n\t/*\n\t * FullBar\n\t */\n\t\n\t\n\tvar FullBar = exports.FullBar = function (_Divider3) {\n\t  _inherits(FullBar, _Divider3);\n\t\n\t  function FullBar() {\n\t    _classCallCheck(this, FullBar);\n\t\n\t    return _possibleConstructorReturn(this, (FullBar.__proto__ || Object.getPrototypeOf(FullBar)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(FullBar, [{\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(FullBar.prototype.__proto__ || Object.getPrototypeOf(FullBar.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      this.addVisualizer(new _ExsurgeDrawing.DividerLineVisualizer(ctxt, 1, ctxt.staffLineCount * 2 - 1, this));\n\t\n\t      this.origin.x = this.bounds.width / 2;\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return FullBar;\n\t}(Divider);\n\t\n\t/*\n\t * Insertion Cursor\n\t */\n\t\n\t\n\tvar InsertionCursor = exports.InsertionCursor = function (_Divider4) {\n\t  _inherits(InsertionCursor, _Divider4);\n\t\n\t  function InsertionCursor() {\n\t    _classCallCheck(this, InsertionCursor);\n\t\n\t    return _possibleConstructorReturn(this, (InsertionCursor.__proto__ || Object.getPrototypeOf(InsertionCursor)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(InsertionCursor, [{\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(InsertionCursor.prototype.__proto__ || Object.getPrototypeOf(InsertionCursor.prototype), \"performLayout\", this).call(this, ctxt);\n\t      this.cssClass = 'InsertionCursor';\n\t\n\t      this.addVisualizer(new _ExsurgeDrawing.DividerLineVisualizer(ctxt, 0, ctxt.staffLineCount * 2));\n\t\n\t      this.origin.x = this.bounds.width / 2;\n\t      this.bounds.width = 0;\n\t      this.bounds.height = 0;\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return InsertionCursor;\n\t}(Divider);\n\t\n\t/*\n\t * DominicanBar\n\t */\n\t\n\t\n\tvar DominicanBar = exports.DominicanBar = function (_Divider5) {\n\t  _inherits(DominicanBar, _Divider5);\n\t\n\t  function DominicanBar(staffPosition) {\n\t    _classCallCheck(this, DominicanBar);\n\t\n\t    var _this7 = _possibleConstructorReturn(this, (DominicanBar.__proto__ || Object.getPrototypeOf(DominicanBar)).call(this));\n\t\n\t    var parity = (staffPosition + 1) % 2;\n\t\n\t    _this7.staffPosition = staffPosition - 2 * parity;\n\t    return _this7;\n\t  }\n\t\n\t  _createClass(DominicanBar, [{\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(DominicanBar.prototype.__proto__ || Object.getPrototypeOf(DominicanBar.prototype), \"performLayout\", this).call(this, ctxt);\n\t      this.addVisualizer(new _ExsurgeDrawing.DividerLineVisualizer(ctxt, this.staffPosition, this.staffPosition + 3, this));\n\t\n\t      this.origin.x = this.bounds.width / 2;\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return DominicanBar;\n\t}(Divider);\n\t\n\t/*\n\t * DoubleBar\n\t */\n\t\n\t\n\tvar DoubleBar = exports.DoubleBar = function (_Divider6) {\n\t  _inherits(DoubleBar, _Divider6);\n\t\n\t  function DoubleBar() {\n\t    _classCallCheck(this, DoubleBar);\n\t\n\t    return _possibleConstructorReturn(this, (DoubleBar.__proto__ || Object.getPrototypeOf(DoubleBar)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(DoubleBar, [{\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(DoubleBar.prototype.__proto__ || Object.getPrototypeOf(DoubleBar.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      var top = ctxt.staffLineCount * 2 - 1;\n\t      var line0 = new _ExsurgeDrawing.DividerLineVisualizer(ctxt, 1, top, this);\n\t      line0.bounds.x = 0;\n\t      this.addVisualizer(line0);\n\t\n\t      var line1 = new _ExsurgeDrawing.DividerLineVisualizer(ctxt, 1, top, this);\n\t      line1.bounds.x = ctxt.intraNeumeSpacing * 2 - line1.bounds.width;\n\t      this.addVisualizer(line1);\n\t\n\t      this.origin.x = this.bounds.width / 2;\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return DoubleBar;\n\t}(Divider);\n\t\n\tvar AccidentalType = exports.AccidentalType = {\n\t  Flat: -1,\n\t  Natural: 0,\n\t  Sharp: 1\n\t};\n\t\n\t/*\n\t * Accidental\n\t */\n\t\n\tvar Accidental = exports.Accidental = function (_ChantNotationElement3) {\n\t  _inherits(Accidental, _ChantNotationElement3);\n\t\n\t  function Accidental(staffPosition, accidentalType) {\n\t    _classCallCheck(this, Accidental);\n\t\n\t    var _this9 = _possibleConstructorReturn(this, (Accidental.__proto__ || Object.getPrototypeOf(Accidental)).call(this));\n\t\n\t    _this9.isAccidental = true;\n\t    _this9.keepWithNext = true; // accidentals should always stay connected...\n\t\n\t    _this9.staffPosition = staffPosition;\n\t    _this9.accidentalType = accidentalType;\n\t    return _this9;\n\t  }\n\t\n\t  _createClass(Accidental, [{\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(Accidental.prototype.__proto__ || Object.getPrototypeOf(Accidental.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      this.addVisualizer(this.createGlyphVisualizer(ctxt));\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t\n\t    // creation of the glyph visualizer is refactored out or performLayout\n\t    // so that clefs can use the same logic for their accidental glyph\n\t\n\t  }, {\n\t    key: \"createGlyphVisualizer\",\n\t    value: function createGlyphVisualizer(ctxt) {\n\t      var glyphCode = _ExsurgeDrawing.GlyphCode.Flat;\n\t\n\t      switch (this.accidentalType) {\n\t        case AccidentalType.Natural:\n\t          glyphCode = _ExsurgeDrawing.GlyphCode.Natural;\n\t          break;\n\t        case AccidentalType.Sharp:\n\t          glyphCode = _ExsurgeDrawing.GlyphCode.Sharp;\n\t          break;\n\t        default:\n\t          glyphCode = _ExsurgeDrawing.GlyphCode.Flat;\n\t          break;\n\t      }\n\t\n\t      var glyph = new _ExsurgeDrawing.GlyphVisualizer(ctxt, glyphCode);\n\t      glyph.setStaffPosition(ctxt, this.staffPosition);\n\t\n\t      return glyph;\n\t    }\n\t  }, {\n\t    key: \"adjustStep\",\n\t    value: function adjustStep(step) {\n\t      switch (this.accidentalType) {\n\t        case AccidentalType.Flat:\n\t          if (step === _ExsurgeCore.Step.Ti) return _ExsurgeCore.Step.Te;\n\t          if (step === _ExsurgeCore.Step.Mi) return _ExsurgeCore.Step.Me;\n\t          break;\n\t        case AccidentalType.Sharp:\n\t          if (step === _ExsurgeCore.Step.Do) return _ExsurgeCore.Step.Du;\n\t          if (step === _ExsurgeCore.Step.Fa) return _ExsurgeCore.Step.Fu;\n\t          break;\n\t        case AccidentalType.Natural:\n\t          if (step === _ExsurgeCore.Step.Te) return _ExsurgeCore.Step.Ti;\n\t          if (step === _ExsurgeCore.Step.Me) return _ExsurgeCore.Step.Mi;\n\t          if (step === _ExsurgeCore.Step.Du) return _ExsurgeCore.Step.Do;\n\t          if (step === _ExsurgeCore.Step.Fu) return _ExsurgeCore.Step.Fa;\n\t          break;\n\t      }\n\t\n\t      // no adjustment needed\n\t      return step;\n\t    }\n\t  }, {\n\t    key: \"applyToPitch\",\n\t    value: function applyToPitch(pitch) {\n\t      // no adjusment needed\n\t      if (this.pitch.octave !== pitch.octave) return;\n\t\n\t      pitch.step = this.adjustStep(pitch.step);\n\t    }\n\t  }]);\n\t\n\t  return Accidental;\n\t}(_ExsurgeDrawing.ChantNotationElement);\n\t\n\t/*\n\t * Virgula\n\t */\n\t\n\t\n\tvar Virgula = exports.Virgula = function (_Divider7) {\n\t  _inherits(Virgula, _Divider7);\n\t\n\t  function Virgula() {\n\t    var withCarryover = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\t\n\t    _classCallCheck(this, Virgula);\n\t\n\t    // unlike other dividers a virgula does not reset accidentals\n\t    var _this10 = _possibleConstructorReturn(this, (Virgula.__proto__ || Object.getPrototypeOf(Virgula)).call(this, withCarryover));\n\t\n\t    _this10.resetsAccidentals = false;\n\t\n\t    // the staff position of the virgula is customizable, so that it\n\t    // can be placed on different lines (top or bottom) depending on the\n\t    // notation tradition of what is being notated (e.g., Benedictine has it\n\t    //  on top line, Norbertine at the bottom)\n\t    _this10.staffPosition = 7;\n\t    return _this10;\n\t  }\n\t\n\t  _createClass(Virgula, [{\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(Virgula.prototype.__proto__ || Object.getPrototypeOf(Virgula.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      var glyph = new _ExsurgeDrawing.GlyphVisualizer(ctxt, _ExsurgeDrawing.GlyphCode.Virgula);\n\t      glyph.setStaffPosition(ctxt, this.staffPosition);\n\t\n\t      this.addVisualizer(glyph);\n\t\n\t      this.origin.x = this.bounds.width / 2;\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return Virgula;\n\t}(Divider);\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Gabc = exports.GabcHeader = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); //\n\t// Author(s):\n\t// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>\n\t//\n\t// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a copy\n\t// of this software and associated documentation files (the \"Software\"), to deal\n\t// in the Software without restriction, including without limitation the rights\n\t// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\t// copies of the Software, and to permit persons to whom the Software is\n\t// furnished to do so, subject to the following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included in\n\t// all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\t// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\t// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\t// THE SOFTWARE.\n\t//\n\t\n\tvar _ExsurgeCore = __webpack_require__(1);\n\t\n\tvar _ExsurgeDrawing = __webpack_require__(4);\n\t\n\tvar _ExsurgeChant = __webpack_require__(8);\n\t\n\tvar _ExsurgeChantMarkings = __webpack_require__(10);\n\t\n\tvar Markings = _interopRequireWildcard(_ExsurgeChantMarkings);\n\t\n\tvar _ExsurgeChantSigns = __webpack_require__(11);\n\t\n\tvar Signs = _interopRequireWildcard(_ExsurgeChantSigns);\n\t\n\tvar _ExsurgeChantNeumes = __webpack_require__(13);\n\t\n\tvar Neumes = _interopRequireWildcard(_ExsurgeChantNeumes);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// reusable reg exps\n\tvar __syllablesRegex = /(?=\\S)((?:<v>[\\s\\S]*<\\/v>|[^(])*)(?:\\(?([^)]*)\\)?)?/g;\n\tvar __altTranslationRegex = /<alt>(.*?)<\\/alt>|\\[(alt:)?(.*?)\\]/g;\n\t\n\tvar __notationsRegex = /z0|z|Z|(::|(?::|[,;][1-8]?|`)_?)|(?:[cfg]|cb|treble-?)[1-5]|\\/+| |\\!|-?[a-mA-M][oOwWvVrRsxy#~\\+><_\\.'012345]*(?:\\[[^\\]]*\\]?)*|\\{([^}]+)\\}?/g;\n\tvar __notationsRegex_group_bar = 1;\n\tvar __notationsRegex_group_insideBraces = 2;\n\t\n\tvar __bracketedCommandRegex = /^([a-z]+):(.*)/;\n\t\n\t// for the brace string inside of [ and ] in notation data\n\t// the capturing groups are:\n\t//  1. o or u, to indicate over or under\n\t//  2. b, cb, or cba, to indicate the brace type\n\t//  3. 0 or 1 to indicate the attachment point\n\t//  4. { or } to indicate opening/closing (this group will be null if the metric version is used)\n\t//  5. a float indicating the millimeter length of the brace (not supported yet)\n\tvar __braceSpecRegex = /([ou])(b|cb|cba):([01])(?:([{}])|;(\\d*(?:\\.\\d+)?)mm)/;\n\t\n\tvar TrailingSpaceForAccidental = function TrailingSpaceForAccidental(ctxt) {\n\t  return ctxt.intraNeumeSpacing * ctxt.accidentalSpaceMultiplier;\n\t};\n\tvar TrailingSpaceMultiple = function TrailingSpaceMultiple(multiplier) {\n\t  return function (ctxt) {\n\t    return ctxt.intraNeumeSpacing * multiplier;\n\t  };\n\t};\n\t\n\tvar regexHeaderEnd = /(?:^|\\n)%%\\s?\\n/;\n\tvar regexHeaderLine = /^([\\w-_.]+):\\s*((?:[^;\\r\\n]|;[ \\t])*)(?:;|$)/i;\n\tvar regexHeaderComment = /^%.*/;\n\t\n\tvar GabcHeader = exports.GabcHeader = function () {\n\t  _createClass(GabcHeader, null, [{\n\t    key: \"getLength\",\n\t    value: function getLength(gabc) {\n\t      var match = gabc.match(regexHeaderEnd);\n\t      return match ? match.index + match[0].length : 0;\n\t    }\n\t  }]);\n\t\n\t  function GabcHeader(text) {\n\t    _classCallCheck(this, GabcHeader);\n\t\n\t    if (typeof text !== \"string\") text = \"\";\n\t    this.comments = [];\n\t    this.cValues = {};\n\t    this.original = \"\";\n\t    var match = text.match(regexHeaderEnd);\n\t    if (match) {\n\t      var txtHeader = this.original = text.slice(0, match.index + match[0].length);\n\t      var lines = txtHeader.split(/\\r?\\n/g);\n\t      for (var i = 0; i < lines.length; ++i) {\n\t        var line = lines[i],\n\t            _match = regexHeaderLine.exec(line);\n\t        if (_match) {\n\t          var key = _match[1].replace(/-([a-z])/g, function (a, letter) {\n\t            return letter.toUpperCase();\n\t          });\n\t          if (this[_match[1]]) {\n\t            var arrayName = _match[1] + \"Array\";\n\t            if (!this[arrayName]) {\n\t              this[arrayName] = [this[_match[1]]];\n\t            }\n\t            this[arrayName].push(_match[2]);\n\t          } else {\n\t            this[_match[1]] = _match[2];\n\t          }\n\t          if (key !== _match[1]) this[key] = this[_match[1]];\n\t        } else if (_match = regexHeaderComment.exec(line)) {\n\t          if (line !== \"%%\") {\n\t            _match = regexHeaderLine.exec(line.slice(1));\n\t            if (_match) {\n\t              var _key = _match[1].replace(/-([a-z])/g, function (a, letter) {\n\t                return letter.toUpperCase();\n\t              });\n\t              this.cValues[_match[1]] = _match[2];\n\t              if (_key !== _match[1]) this.cValues[_key] = _match[2];\n\t            } else {\n\t              this.comments[i] = line;\n\t            }\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  _createClass(GabcHeader, [{\n\t    key: \"toString\",\n\t    value: function toString() {\n\t      var result = [];\n\t      for (var key in this) {\n\t        if (typeof this[key] !== \"string\" || /^(length|original|comments|cValues)$/.test(key)) {\n\t          continue;\n\t        }\n\t        var alternateKey = key.replace(/[A-Z]/g, function (letter) {\n\t          return \"-\" + letter.toLowerCase();\n\t        });\n\t        if (alternateKey !== key && alternateKey in this) continue;\n\t        var array = this[key + \"Array\"];\n\t        if (array) {\n\t          for (var i = 0; i < array.length; ++i) {\n\t            result.push(key + \": \" + array[i] + \";\");\n\t          }\n\t        } else {\n\t          result.push(key + \": \" + this[key] + \";\");\n\t        }\n\t      }\n\t      for (var _key2 in this.cValues) {\n\t        if (_key2.length === 0 || !this.cValues.hasOwnProperty(_key2)) continue;\n\t        result.push(\"%\" + _key2 + \": \" + this.cValues[_key2] + \";\");\n\t      }\n\t      for (var _i in this.comments) {\n\t        if (!this.comments.hasOwnProperty(_i)) continue;\n\t        try {\n\t          result.splice(_i, 0, this.comments[_i]);\n\t        } catch (e) {\n\t          console.warn(e);\n\t        }\n\t      }\n\t      return result.join(\"\\n\") + \"\\n%%\\n\";\n\t    }\n\t  }]);\n\t\n\t  return GabcHeader;\n\t}();\n\t\n\tvar elementCountForNotations = function elementCountForNotations(items) {\n\t  return items.reduce(function (sum, item) {\n\t    return sum + (item.notes ? item.notes.length : 1);\n\t  }, 0);\n\t};\n\t\n\tvar Gabc = exports.Gabc = function () {\n\t  function Gabc() {\n\t    _classCallCheck(this, Gabc);\n\t  }\n\t\n\t  _createClass(Gabc, null, [{\n\t    key: \"createMappingsFromSource\",\n\t\n\t    // takes gabc source code (without the header info) and returns an array\n\t    // of ChantMappings describing the chant. A chant score can then be created\n\t    // fron the chant mappings and later updated via updateMappings() if need\n\t    // be...\n\t    value: function createMappingsFromSource(ctxt, gabcSource) {\n\t      var headerLength = GabcHeader.getLength(gabcSource);\n\t      gabcSource = gabcSource.slice(headerLength);\n\t      var words = this.splitWords(gabcSource);\n\t\n\t      // set the default clef\n\t      ctxt.activeClef = _ExsurgeChant.Clef.default();\n\t\n\t      var mappings = this.createMappingsFromWords(ctxt, words, function (clef) {\n\t        return ctxt.activeClef = clef;\n\t      });\n\t\n\t      // always set the last notation to have a trailingSpace of 0. This makes layout for the last chant line simpler\n\t      if (mappings.length > 0 && mappings[mappings.length - 1].notations.length > 0) mappings[mappings.length - 1].notations[mappings[mappings.length - 1].notations.length - 1].trailingSpace = 0;\n\t\n\t      return mappings;\n\t    }\n\t\n\t    // A simple general purpose diff algorithm adapted here for comparing\n\t    // an array of existing mappings with an updated list of gabc words.\n\t    // note before is an array of mappings, and after is an array of strings\n\t    // (gabc words).\n\t    //\n\t    // This is definitely not the most effecient diff algorithm, but for our\n\t    // limited needs and source size it seems to work just fine...\n\t    //\n\t    // code is adapted from: https://github.com/paulgb/simplediff\n\t    //\n\t    // Returns:\n\t    //   A list of pairs, with the first part of the pair being one of three\n\t    //   strings ('-', '+', '=') and the second part being a list of values from\n\t    //   the original before and/or after lists. The first part of the pair\n\t    //   corresponds to whether the list of values is a deletion, insertion, or\n\t    //   unchanged, respectively.\n\t\n\t  }, {\n\t    key: \"diffDescriptorsAndNewWords\",\n\t    value: function diffDescriptorsAndNewWords(before, after) {\n\t      // Create a map from before values to their indices\n\t      var oldIndexMap = {},\n\t          i;\n\t      for (i = 0; i < before.length; i++) {\n\t        oldIndexMap[before[i].source] = oldIndexMap[before[i].source] || [];\n\t        oldIndexMap[before[i].source].push(i);\n\t      }\n\t\n\t      var overlap = [],\n\t          startOld,\n\t          startNew,\n\t          subLength,\n\t          inew;\n\t\n\t      startOld = startNew = subLength = 0;\n\t\n\t      for (inew = 0; inew < after.length; inew++) {\n\t        var _overlap = [];\n\t        oldIndexMap[after[inew]] = oldIndexMap[after[inew]] || [];\n\t        for (i = 0; i < oldIndexMap[after[inew]].length; i++) {\n\t          var iold = oldIndexMap[after[inew]][i];\n\t          // now we are considering all values of val such that\n\t          // `before[iold] == after[inew]`\n\t          _overlap[iold] = (iold && overlap[iold - 1] || 0) + 1;\n\t          if (_overlap[iold] > subLength) {\n\t            // this is the largest substring seen so far, so store its indices\n\t            subLength = _overlap[iold];\n\t            startOld = iold - subLength + 1;\n\t            startNew = inew - subLength + 1;\n\t          }\n\t        }\n\t        overlap = _overlap;\n\t      }\n\t\n\t      if (subLength === 0) {\n\t        // If no common substring is found, we return an insert and delete...\n\t        var result = [];\n\t\n\t        if (before.length) result.push([\"-\", before]);\n\t\n\t        if (after.length) result.push([\"+\", after]);\n\t\n\t        return result;\n\t      }\n\t\n\t      // ...otherwise, the common substring is unchanged and we recursively\n\t      // diff the text before and after that substring\n\t      return [].concat(this.diffDescriptorsAndNewWords(before.slice(0, startOld), after.slice(0, startNew)), [[\"=\", after.slice(startNew, startNew + subLength)]], this.diffDescriptorsAndNewWords(before.slice(startOld + subLength), after.slice(startNew + subLength)));\n\t    }\n\t\n\t    // this function essentially performs and applies a rudimentary diff between a\n\t    // previously parsed set of mappings and between a new gabc source text.\n\t    // the mappings array passed in is changed in place to be updated from the\n\t    // new source\n\t\n\t  }, {\n\t    key: \"updateMappingsFromSource\",\n\t    value: function updateMappingsFromSource(ctxt, mappings, newGabcSource) {\n\t      var insertionIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\t      var oldInsertionIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\t\n\t      var headerLength = GabcHeader.getLength(newGabcSource);\n\t      newGabcSource = newGabcSource.slice(headerLength);\n\t      // always remove the last old mapping since it's spacing/trailingSpace is handled specially\n\t      mappings.pop();\n\t\n\t      if (insertionIndex === null) {\n\t        insertionIndex = NaN;\n\t      }\n\t      if (oldInsertionIndex === null) {\n\t        oldInsertionIndex = NaN;\n\t      }\n\t\n\t      var newWords = this.splitWords(newGabcSource);\n\t\n\t      var results = this.diffDescriptorsAndNewWords(mappings, newWords);\n\t\n\t      var index = 0,\n\t          j,\n\t          k,\n\t          l,\n\t          sourceIndex = 0,\n\t          wordLength = 0,\n\t          mapping,\n\t          elementIndex = 0;\n\t\n\t      ctxt.activeClef = _ExsurgeChant.Clef.default();\n\t\n\t      // apply the results to the mappings, marking notations that need to be processed\n\t      var lastTranslationNeumes = [];\n\t      for (var i = 0; i < results.length; i++) {\n\t        var resultCode = results[i][0];\n\t        var resultValues = results[i][1];\n\t\n\t        if (index > 0) sourceIndex = mappings[index - 1].sourceIndex + mappings[index - 1].source.length + 1;\n\t        if (resultCode === \"=\") {\n\t          var sourceIndexDiff = sourceIndex - mappings[index].sourceIndex;\n\t          // skip over ones that haven't changed, but updating the clef and source\n\t          // index (and pitch in case clef or accidentals have changed) as we go\n\t          for (j = 0; j < resultValues.length; j++, index++) {\n\t            mapping = mappings[index];\n\t            if (elementIndex === 0 && mapping.notations.length && mapping.notations[0].isClef) {\n\t              // the first clef doesn't get kept as a notation:\n\t              elementIndex = -1;\n\t            }\n\t            if (insertionIndex >= elementIndex || oldInsertionIndex >= elementIndex) {\n\t              // check if the insertion index is within this mapping:\n\t              var elementCount = elementCountForNotations(mapping.notations);\n\t              if (insertionIndex >= elementIndex && insertionIndex < elementIndex + elementCount || oldInsertionIndex >= elementIndex && oldInsertionIndex < elementIndex + elementCount) {\n\t                // re-do this mapping:\n\t                // TODO: check sourceIndex\n\t                var _sourceIndex = mapping.sourceIndex + sourceIndexDiff;\n\t                mapping = this.createMappingFromWord(ctxt, resultValues[j], _sourceIndex, lastTranslationNeumes, insertionIndex - elementIndex);\n\t                mappings.splice(index, 1, mapping);\n\t\n\t                elementIndex += elementCount;\n\t                continue;\n\t              }\n\t              elementIndex += elementCount;\n\t            }\n\t            mapping.sourceIndex += sourceIndexDiff;\n\t            for (k = 0; k < mapping.notations.length; k++) {\n\t              var curNotation = mapping.notations[k];\n\t              var prevIsAccidental = mapping.notations[k - 1] && mapping.notations[k - 1].isAccidental;\n\t              // notify the notation that its dependencies are no longer valid\n\t              curNotation.resetDependencies();\n\t\n\t              if (curNotation.isClef) {\n\t                ctxt.activeClef = mappings[index].notations[k];\n\t              }\n\t\n\t              if (curNotation.isAccidental) {\n\t                ctxt.activeClef.activeAccidental = curNotation;\n\t              } else if (curNotation.resetsAccidentals || !prevIsAccidental && curNotation.hasLyrics() && curNotation.lyrics[0].lyricType <= _ExsurgeDrawing.LyricType.BeginningSyllable) {\n\t                ctxt.activeClef.resetAccidentals();\n\t              }\n\t\n\t              // update source index, pitch, and automatic braces\n\t              if (curNotation.notes) {\n\t                for (l = 0; l < curNotation.notes.length; ++l) {\n\t                  var note = curNotation.notes[l];\n\t                  note.sourceIndex += sourceIndexDiff;\n\t                  note.pitch = ctxt.activeClef.staffPositionToPitch(note.staffPosition);\n\t                  if (note.braceEnd && note.braceEnd.automatic) delete note.braceEnd;\n\t                  if (this.needToEndBrace && !note.braceStart && !note.braceEnd) {\n\t                    note.braceEnd = new Markings.BracePoint(note, this.needToEndBrace.isAbove, this.needToEndBrace.shape, this.needToEndBrace.attachment === Markings.BraceAttachment.Left ? Markings.BraceAttachment.Right : Markings.BraceAttachment.Left);\n\t                    note.braceEnd.automatic = true;\n\t                    delete this.needToEndBrace;\n\t                  } else if (note.braceStart && note.braceStart.automatic) {\n\t                    this.needToEndBrace = note.braceStart;\n\t                  }\n\t                }\n\t              }\n\t              if (curNotation.translationText) {\n\t                for (l = 0; l < curNotation.translationText.length; ++l) {\n\t                  var transText = curNotation.translationText[l];\n\t                  delete transText.endNeume;\n\t                  curNotation.translationText[l].sourceIndex += sourceIndexDiff;\n\t                  if (transText.textAnchor === \"end\" && lastTranslationNeumes[0]) {\n\t                    var lastTranslationText = lastTranslationNeumes[0].translationText[l];\n\t                    if (lastTranslationText) lastTranslationText.endNeume = curNotation;\n\t                  }\n\t                }\n\t                lastTranslationNeumes[0] = curNotation;\n\t              }\n\t              if (sourceIndexDiff) {\n\t                if (typeof curNotation.sourceIndex === \"number\") {\n\t                  curNotation.sourceIndex += sourceIndexDiff;\n\t                }\n\t                for (l = 0; l < curNotation.lyrics.length; ++l) {\n\t                  curNotation.lyrics[l].sourceIndex += sourceIndexDiff;\n\t                }\n\t                if (curNotation.alText) {\n\t                  for (l = 0; l < curNotation.alText.length; ++l) {\n\t                    curNotation.alText[l].sourceIndex += sourceIndexDiff;\n\t                  }\n\t                }\n\t              }\n\t            }\n\t          }\n\t        } else if (resultCode === \"-\") {\n\t          // delete elements that no longer exist, but first notify all\n\t          // elements of the change\n\t          mappings.splice(index, resultValues.length);\n\t        } else if (resultCode === \"+\") {\n\t          // insert new ones\n\t          for (j = 0; j < resultValues.length; j++) {\n\t            wordLength = resultValues[j].length + 1;\n\t            mapping = this.createMappingFromWord(ctxt, resultValues[j], sourceIndex, lastTranslationNeumes, insertionIndex - elementIndex);\n\t\n\t            if (elementIndex === 0 && mapping.notations.length && mapping.notations[0].isClef) {\n\t              // the first clef doesn't get kept as a notation:\n\t              elementIndex = -1;\n\t              var _elementCount = elementCountForNotations(mapping.notations);\n\t              if (insertionIndex < _elementCount) {\n\t                // re-do the first mapping, because it was broken up incorrectly, due to the presence of the initial clef\n\t                mapping = this.createMappingFromWord(ctxt, resultValues[j], sourceIndex, lastTranslationNeumes, insertionIndex - elementIndex);\n\t              }\n\t            }\n\t\n\t            for (k = 0; k < mapping.notations.length; k++) {\n\t              var _curNotation = mapping.notations[k];\n\t              elementIndex += _curNotation.notes ? _curNotation.notes.length : 1;\n\t              if (_curNotation.isClef) {\n\t                ctxt.activeClef = mapping.notations[k];\n\t              }\n\t            }\n\t\n\t            mappings.splice(index++, 0, mapping);\n\t            sourceIndex += wordLength;\n\t          }\n\t        }\n\t      }\n\t\n\t      // always set the last notation to have a trailingSpace of 0. This makes layout for the last chant line simpler\n\t      if (mappings.length > 0 && mappings[mappings.length - 1].notations.length > 0) mappings[mappings.length - 1].notations[mappings[mappings.length - 1].notations.length - 1].trailingSpace = 0;\n\t\n\t      return headerLength;\n\t    }\n\t\n\t    // takes an array of gabc words (like that returned by splitWords below)\n\t    // and returns an array of ChantMapping objects, one for each word.\n\t\n\t  }, {\n\t    key: \"createMappingsFromWords\",\n\t    value: function createMappingsFromWords(ctxt, words) {\n\t      var mappings = [];\n\t      var sourceIndex = 0,\n\t          wordLength = 0,\n\t          lastTranslationNeumes = [];\n\t\n\t      for (var i = 0; i < words.length; i++) {\n\t        sourceIndex += wordLength;\n\t        wordLength = words[i].length + 1;\n\t        var word = words[i].trim();\n\t\n\t        if (word === \"\") continue;\n\t\n\t        var mapping = this.createMappingFromWord(ctxt, word, sourceIndex, lastTranslationNeumes);\n\t\n\t        if (mapping) mappings.push(mapping);\n\t      }\n\t\n\t      return mappings;\n\t    }\n\t\n\t    // takes a gabc word (like those returned by splitWords below) and returns\n\t    // a ChantMapping object that contains the gabc word source text as well\n\t    // as the generated notations.\n\t\n\t  }, {\n\t    key: \"createMappingFromWord\",\n\t    value: function createMappingFromWord(ctxt, word, sourceIndex, lastTranslationNeumes, insertionIndex) {\n\t      var matches = [];\n\t      var notations = [];\n\t      var currSyllable = 0;\n\t\n\t      while (match = __syllablesRegex.exec(word)) {\n\t        matches.push(match);\n\t      }for (var j = 0; j < matches.length; j++) {\n\t        var match = matches[j];\n\t\n\t        var lyricText = match[1].replace(/(^|<\\/sp>)([\\s\\S]*?)($|<sp>)/g, function (_, pre, main, post) {\n\t          return \"\" + pre + main.replace(/~/g, \" \") + post;\n\t        });\n\t        var alText = [];\n\t        var translationText = [];\n\t        var notationData = match[2];\n\t\n\t        // new words reset the accidentals, per the Solesmes style (see LU xviij)\n\t        // but we need to also make sure that there _is_ a word and that it has notes associated with it.\n\t        if (currSyllable === 0 && /[a-z]/i.test(lyricText) && /[a-m]/i.test(notationData)) ctxt.activeClef.resetAccidentals();\n\t\n\t        var items = this.parseNotations(ctxt, notationData, sourceIndex + match.index + match[1].length + 1, insertionIndex);\n\t\n\t        if (items.length === 0) continue;\n\t\n\t        if (insertionIndex >= 0) insertionIndex -= elementCountForNotations(items);\n\t\n\t        items[0].firstOfSyllable = !!lyricText;\n\t        items[0].firstOfParentheses = true;\n\t        notations.push.apply(notations, _toConsumableArray(items));\n\t\n\t        // add the lyrics and/or alText to the first notation that makes sense...\n\t        var notationWithLyrics = null;\n\t        for (var i = 0; i < items.length; i++) {\n\t          var cne = items[i];\n\t\n\t          if (cne.isAccidental && i + 1 < items.length) continue;\n\t\n\t          notationWithLyrics = cne;\n\t          break;\n\t        }\n\t\n\t        var m = __altTranslationRegex.exec();\n\t        var indexOffset = 0;\n\t        while (m = __altTranslationRegex.exec(lyricText)) {\n\t          var index = m.index;\n\t          lyricText = lyricText.slice(0, index) + lyricText.slice(index + m[0].length);\n\t          index += sourceIndex + indexOffset + 1;\n\t          if (typeof m[1] === \"string\") {\n\t            var elem = new _ExsurgeDrawing.AboveLinesText(ctxt, m[1], notationWithLyrics, index + 4);\n\t            elem.alIndex = alText.push(elem) - 1;\n\t          } else if (typeof m[2] === \"string\") {\n\t            var _elem = new _ExsurgeDrawing.AboveLinesText(ctxt, m[3], notationWithLyrics, index + m[2].length);\n\t            _elem.alIndex = alText.push(_elem) - 1;\n\t          } else {\n\t            var _elem2 = new _ExsurgeDrawing.TranslationText(ctxt, m[3], notationWithLyrics, index);\n\t            _elem2.translationIndex = translationText.push(_elem2) - 1;\n\t          }\n\t          indexOffset += m[0].length;\n\t          __altTranslationRegex.exec();\n\t        }\n\t        if (lyricText === \"\" && alText.length === 0) continue;\n\t\n\t        if (notationWithLyrics === null) return new _ExsurgeChant.ChantMapping(word, notations, sourceIndex);\n\t\n\t        if (alText.length) notationWithLyrics.alText = alText;\n\t\n\t        if (translationText.length) {\n\t          notationWithLyrics.translationText = translationText;\n\t          for (i = 0; i < translationText.length; ++i) {\n\t            var transText = translationText[i];\n\t            if (transText.textAnchor === \"end\" && lastTranslationNeumes[0]) {\n\t              var lastTranslationText = lastTranslationNeumes[0].translationText[i];\n\t              if (lastTranslationText) lastTranslationText.endNeume = notationWithLyrics;\n\t            }\n\t          }\n\t          lastTranslationNeumes[0] = notationWithLyrics;\n\t        }\n\t\n\t        if (lyricText === \"\") continue;\n\t\n\t        var proposedLyricType;\n\t\n\t        // if it's not a neume or a TextOnly notation, then make the lyrics a directive\n\t        if (!cne.isNeume && cne.constructor !== _ExsurgeChant.TextOnly) proposedLyricType = _ExsurgeDrawing.LyricType.Directive;\n\t        // otherwise trye to guess the lyricType for the first lyric anyway\n\t        else if (currSyllable === 0 && j === matches.length - 1) proposedLyricType = _ExsurgeDrawing.LyricType.SingleSyllable;else if (currSyllable === 0 && j < matches.length - 1) proposedLyricType = _ExsurgeDrawing.LyricType.BeginningSyllable;else if (j === matches.length - 1) proposedLyricType = _ExsurgeDrawing.LyricType.EndingSyllable;else proposedLyricType = _ExsurgeDrawing.LyricType.MiddleSyllable;\n\t\n\t        currSyllable++;\n\t\n\t        var lyrics = this.createSyllableLyrics(ctxt, lyricText, proposedLyricType, notationWithLyrics, items, sourceIndex + match.index);\n\t\n\t        if (lyrics === null || lyrics.length === 0) continue;\n\t\n\t        notationWithLyrics.lyrics = lyrics;\n\t      }\n\t\n\t      return new _ExsurgeChant.ChantMapping(word, notations, sourceIndex);\n\t    }\n\t\n\t    // returns an array of lyrics (an array because each syllable can have multiple lyrics)\n\t\n\t  }, {\n\t    key: \"createSyllableLyrics\",\n\t    value: function createSyllableLyrics(ctxt, text, proposedLyricType, notation, notations, sourceIndex) {\n\t      var _this = this;\n\t\n\t      var lyrics = [];\n\t\n\t      // an extension to gabc: multiple lyrics per syllable can be separated by a |\n\t      var lyricTexts = text.split(\"|\");\n\t\n\t      var _loop = function _loop() {\n\t        lyricText = lyricTexts[i];\n\t\n\t\n\t        if (i > 0) {\n\t          if (lyricText.match(/\\s$/)) {\n\t            lyricText = lyricText.replace(/s+$/, \"\");\n\t            proposedLyricType = _ExsurgeDrawing.LyricType.EndingSyllable;\n\t          } else {\n\t            proposedLyricType = _ExsurgeDrawing.LyricType.MiddleSyllable;\n\t          }\n\t        }\n\t\n\t        // gabc allows lyrics to indicate the centering part of the text by\n\t        // using braces to indicate how to center the lyric. So a lyric can\n\t        // look like \"f{i}re\" or \"{fenced}\" to center on the i or on the entire\n\t        // word, respectively. Here we determine if the lyric should be spaced\n\t        // manually with this method of using braces.\n\t        // however, we don't want to consider any braces inside of v tags, so we\n\t        // do a bit of text processing here:\n\t        lyricTextWithoutVTags = lyricText;\n\t\n\t        var vtagRegex = /<v>[\\s\\S]*?<\\/v>/;\n\t        var match = void 0;\n\t        var vtags = [];\n\t        while (match = vtagRegex.exec(lyricTextWithoutVTags)) {\n\t          var index = match.index;\n\t          var length = match[0].length;\n\t          vtags[index] = length;\n\t          lyricTextWithoutVTags = lyricTextWithoutVTags.slice(0, index) + lyricTextWithoutVTags.slice(index + length);\n\t        }\n\t        centerStartIndex = lyricTextWithoutVTags.indexOf(\"{\");\n\t        centerLength = 0;\n\t\n\t\n\t        if (centerStartIndex >= 0) {\n\t          var indexClosingBracket = lyricTextWithoutVTags.indexOf(\"}\");\n\t\n\t          if (indexClosingBracket >= 0 && indexClosingBracket > centerStartIndex) {\n\t            var getTrueIndex = function getTrueIndex(indexWithoutVTags) {\n\t              // map indices back to the lyricText with the V tags:\n\t              var accum = 0;\n\t              for (var _index in vtags) {\n\t                if (vtags.hasOwnProperty(_index) && indexWithoutVTags >= _index) {\n\t                  accum += vtags[_index];\n\t                } else {\n\t                  break;\n\t                }\n\t              }\n\t              return indexWithoutVTags + accum;\n\t            };\n\t            centerStartIndex = getTrueIndex(centerStartIndex);\n\t            indexClosingBracket = getTrueIndex(indexClosingBracket);\n\t            centerLength = indexClosingBracket - centerStartIndex - 1;\n\t\n\t            // strip out the brackets:\n\t            lyricText = lyricText.substring(0, centerStartIndex) + lyricText.substring(centerStartIndex + 1, indexClosingBracket) + lyricText.substring(indexClosingBracket + 1, lyricText.length);\n\t          } else centerStartIndex = -1; // if there's no closing bracket, don't enable centering\n\t        }\n\t\n\t        lyric = _this.makeLyric(ctxt, lyricText, proposedLyricType, notation, notations, sourceIndex);\n\t\n\t\n\t        if (centerStartIndex >= 0) {\n\t          // update indices in case there had been any tags, etc.\n\t          var textIndex = 0,\n\t              centerEndIndex = -1;\n\t          var _iteratorNormalCompletion = true;\n\t          var _didIteratorError = false;\n\t          var _iteratorError = undefined;\n\t\n\t          try {\n\t            for (var _iterator = lyric.spans[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t              var span = _step.value;\n\t\n\t              if (centerStartIndex >= span.index && centerStartIndex <= span.index + span.text.length) {\n\t                centerEndIndex = centerStartIndex + centerLength;\n\t                centerStartIndex += textIndex - span.index;\n\t              }\n\t              if (centerEndIndex >= 0 && centerEndIndex >= span.index && centerEndIndex <= span.index + span.text.length) {\n\t                centerEndIndex += textIndex - span.index;\n\t                centerLength = centerEndIndex - centerStartIndex;\n\t                centerEndIndex = -1;\n\t                break;\n\t              }\n\t              textIndex += span.text.length;\n\t            }\n\t          } catch (err) {\n\t            _didIteratorError = true;\n\t            _iteratorError = err;\n\t          } finally {\n\t            try {\n\t              if (!_iteratorNormalCompletion && _iterator.return) {\n\t                _iterator.return();\n\t              }\n\t            } finally {\n\t              if (_didIteratorError) {\n\t                throw _iteratorError;\n\t              }\n\t            }\n\t          }\n\t\n\t          if (centerEndIndex >= 0) {\n\t            centerEndIndex = textIndex;\n\t            centerLength = centerEndIndex - centerStartIndex;\n\t          }\n\t        }\n\t\n\t        // if we have manual lyric centering, then set it now\n\t        if (centerStartIndex >= 0) {\n\t          lyric.centerStartIndex = centerStartIndex;\n\t          lyric.centerLength = centerLength;\n\t        }\n\t\n\t        lyric.lyricIndex = lyrics.push(lyric) - 1;\n\t        sourceIndex += lyricText.length + 1;\n\t      };\n\t\n\t      for (var i = 0; i < lyricTexts.length; i++) {\n\t        var lyricText;\n\t        var lyricTextWithoutVTags;\n\t        var centerStartIndex;\n\t        var centerLength;\n\t        var lyric;\n\t\n\t        _loop();\n\t      }\n\t      notation.lyrics = lyrics;\n\t      return lyrics;\n\t    }\n\t  }, {\n\t    key: \"makeLyric\",\n\t    value: function makeLyric(ctxt, text, lyricType, notation, notations, sourceIndex) {\n\t      var elides = false;\n\t      var forceConnector = false;\n\t      if (text.length > 1) {\n\t        if (text[text.length - 1] === \"-\") {\n\t          forceConnector = true;\n\t          if (lyricType === _ExsurgeDrawing.LyricType.EndingSyllable) lyricType = _ExsurgeDrawing.LyricType.MiddleSyllable;else if (lyricType === _ExsurgeDrawing.LyricType.SingleSyllable) lyricType = _ExsurgeDrawing.LyricType.BeginningSyllable;\n\t\n\t          text = text.slice(0, -1);\n\t        } else if (text[text.length - 1] === \" \") {\n\t          if (lyricType === _ExsurgeDrawing.LyricType.MiddleSyllable) lyricType = _ExsurgeDrawing.LyricType.EndingSyllable;else if (lyricType === _ExsurgeDrawing.LyricType.BeginningSyllable) lyricType = _ExsurgeDrawing.LyricType.SingleSyllable;\n\t\n\t          text = text.slice(0, -1);\n\t        } else if (/<\\/i>$/.test(text)) {\n\t          // must be an elision\n\t          elides = true;\n\t        }\n\t      }\n\t\n\t      if (text.match(/^(?:[*†]+|i+j|\\d+)\\.?$/)) lyricType = _ExsurgeDrawing.LyricType.Directive;\n\t\n\t      var lyric = new _ExsurgeDrawing.Lyric(ctxt, text, lyricType, notation, notations, sourceIndex);\n\t      lyric.elidesToNext = elides;\n\t      if (forceConnector) lyric.setForceConnector(true);\n\t\n\t      return lyric;\n\t    }\n\t\n\t    // takes a string of gabc notations and creates exsurge objects out of them.\n\t    // returns an array of notations.\n\t\n\t  }, {\n\t    key: \"parseNotations\",\n\t    value: function parseNotations(ctxt, data, sourceIndex, insertionIndex) {\n\t      var _this2 = this;\n\t\n\t      // if there is no data, then this must be a text only object\n\t      if (!data) return [new _ExsurgeChant.TextOnly(sourceIndex, 0)];\n\t\n\t      var baseSourceIndex = sourceIndex;\n\t      var sourceLength = 0;\n\t      var notations = [];\n\t      var notes = [];\n\t      var trailingSpace = _ExsurgeDrawing.DefaultTrailingSpace;\n\t\n\t      var addToLastSourceGabc = function addToLastSourceGabc(gabc) {\n\t        if (notes.length > 0) {\n\t          notes[notes.length - 1].sourceGabc += gabc;\n\t        }\n\t      };\n\t      var addNotation = function addNotation(notation) {\n\t        // first, if we have any notes left over, we create a neume out of them\n\t        if (notes.length > 0) {\n\t          // create neume(s)\n\t          var neumes = _this2.createNeumesFromNotes(ctxt, notes, trailingSpace);\n\t          for (var i = 0; i < neumes.length; i++) {\n\t            notations.push(neumes[i]);\n\t          }notes = [];\n\t        }\n\t\n\t        // reset the trailing space\n\t        trailingSpace = _ExsurgeDrawing.DefaultTrailingSpace;\n\t\n\t        // then, if we're passed a notation, let's add it\n\t        // also, perform chant logic here\n\t        if (notation !== null) {\n\t          var prevNotation = notations[notations.length - 1];\n\t          notation.sourceIndex = sourceIndex;\n\t          notation.sourceGabc = match[0];\n\t          if (notation.isClef) {\n\t            ctxt.activeClef = notation;\n\t            if (prevNotation && prevNotation.trailingSpace.isDefault && prevNotation.isDivider) {\n\t              prevNotation.trailingSpace = TrailingSpaceForAccidental;\n\t            }\n\t          } else if (notation.isAccidental) {\n\t            ctxt.activeClef.activeAccidental = notation;\n\t          } else if (notation.trailingSpace.isDefault && notation instanceof Signs.Custos) {\n\t            notation.trailingSpace = TrailingSpaceForAccidental;\n\t          } else if (notation.resetsAccidentals) ctxt.activeClef.resetAccidentals();\n\t\n\t          notations.push(notation);\n\t        }\n\t      };\n\t\n\t      var regex = new RegExp(__notationsRegex);\n\t      var match;\n\t\n\t      while (match = regex.exec(data)) {\n\t        sourceIndex = baseSourceIndex + match.index;\n\t        sourceLength = match[0].length;\n\t        var atom = match[0];\n\t        var bar = match[__notationsRegex_group_bar];\n\t\n\t        var barWithCarryover = !!bar && bar.endsWith('_');\n\t        if (barWithCarryover) {\n\t          atom = atom.slice(0, -1);\n\t        }\n\t\n\t        // handle the clefs and dividers here\n\t        switch (atom) {\n\t          case \",\":\n\t            addNotation(new Signs.QuarterBar(barWithCarryover));\n\t            break;\n\t          case \"`\":\n\t            addNotation(new Signs.Virgula(barWithCarryover));\n\t            break;\n\t          case \";\":\n\t            addNotation(new Signs.HalfBar(barWithCarryover));\n\t            break;\n\t          case \";1\":\n\t          case \";2\":\n\t          case \";3\":\n\t          case \";4\":\n\t          case \";5\":\n\t          case \";6\":\n\t          case \";7\":\n\t          case \";8\":\n\t          case \",1\":\n\t          case \",2\":\n\t          case \",3\":\n\t          case \",4\":\n\t          case \",5\":\n\t          case \",6\":\n\t          case \",7\":\n\t          case \",8\":\n\t            addNotation(new Signs.DominicanBar(parseInt(atom[1], 10)));\n\t            break;\n\t          case \":\":\n\t            addNotation(new Signs.FullBar(barWithCarryover));\n\t            break;\n\t          case \"::\":\n\t            addNotation(new Signs.DoubleBar());\n\t            break;\n\t          // other gregorio dividers are not supported yet\n\t\n\t          case \"c1\":\n\t          case \"c2\":\n\t          case \"c3\":\n\t          case \"c4\":\n\t          case \"c5\":\n\t            addNotation(ctxt.activeClef = new _ExsurgeChant.DoClef(2 * parseInt(atom[1], 10) - 1, 2));\n\t            break;\n\t          case \"f1\":\n\t          case \"f2\":\n\t          case \"f3\":\n\t          case \"f4\":\n\t          case \"f5\":\n\t            addNotation(ctxt.activeClef = new _ExsurgeChant.FaClef(2 * parseInt(atom[1], 10) - 1, 2));\n\t            break;\n\t          case \"treble1\":\n\t          case \"treble2\":\n\t          case \"treble3\":\n\t          case \"treble4\":\n\t          case \"treble5\":\n\t          case \"treble-1\":\n\t          case \"treble-2\":\n\t          case \"treble-3\":\n\t          case \"treble-4\":\n\t          case \"treble-5\":\n\t            addNotation(ctxt.activeClef = new _ExsurgeChant.TrebleClef(2 * parseInt(atom.slice(-1), 10) - 1, 2, null, atom[6] === '-'));\n\t            break;\n\t          case \"cb1\":\n\t          case \"cb2\":\n\t          case \"cb3\":\n\t          case \"cb4\":\n\t          case \"cb5\":\n\t            {\n\t              var line = 2 * parseInt(atom[2], 10) - 1;\n\t              addNotation(ctxt.activeClef = new _ExsurgeChant.DoClef(line, 2, new Signs.Accidental(line - 1, Signs.AccidentalType.Flat)));\n\t            }\n\t            break;\n\t\n\t          case \"z\":\n\t            addNotation(new _ExsurgeChant.ChantLineBreak(true));\n\t            break;\n\t          case \"Z\":\n\t            addNotation(new _ExsurgeChant.ChantLineBreak(false));\n\t            break;\n\t          case \"z0\":\n\t            addNotation(new Signs.Custos(true));\n\t            break;\n\t\n\t          // spacing indicators\n\t          case \"!\":\n\t            trailingSpace = 0;\n\t            addToLastSourceGabc(atom);\n\t            addNotation(null);\n\t            break;\n\t          case \" \":\n\t            // fixme: is this correct? logically what is the difference in gabc\n\t            // between putting a space between notes vs putting '//' between notes?\n\t            trailingSpace = TrailingSpaceMultiple(2);\n\t            addToLastSourceGabc(atom);\n\t            addNotation(null);\n\t            break;\n\t\n\t          default:\n\t            // might be a number of slashes, a custos, might be an accidental, or might be a note\n\t            if (atom[0] === \"/\") {\n\t              trailingSpace = TrailingSpaceMultiple(atom.length);\n\t              addToLastSourceGabc(atom);\n\t              addNotation(null);\n\t            } else if (atom.length > 1 && atom[1] === \"+\") {\n\t              // custos\n\t              var custos = new Signs.Custos();\n\t\n\t              custos.staffPosition = this.gabcHeightToExsurgeHeight(atom[0]);\n\t\n\t              addNotation(custos);\n\t            } else if (atom.length > 1 && /[xy#]/.test(atom[1])) {\n\t              var accidentalType;\n\t\n\t              switch (atom[1]) {\n\t                case \"y\":\n\t                  accidentalType = Signs.AccidentalType.Natural;\n\t                  break;\n\t                case \"#\":\n\t                  accidentalType = Signs.AccidentalType.Sharp;\n\t                  break;\n\t                default:\n\t                  accidentalType = Signs.AccidentalType.Flat;\n\t                  break;\n\t              }\n\t\n\t              var noteArray = [];\n\t              this.createNoteFromData(ctxt, ctxt.activeClef, atom, noteArray, sourceIndex);\n\t              var accidental = new Signs.Accidental(noteArray[0].staffPosition, accidentalType);\n\t              accidental.pitch = this.gabcHeightToExsurgePitch(ctxt.activeClef, atom[0]);\n\t              accidental.sourceIndex = sourceIndex;\n\t              accidental.sourceLength = sourceLength;\n\t              accidental.trailingSpace = TrailingSpaceForAccidental;\n\t\n\t              ctxt.activeClef.activeAccidental = accidental;\n\t\n\t              addNotation(accidental);\n\t            } else if (atom.length > 1 && atom[0] === \"{\") {\n\t              (function () {\n\t                trailingSpace = 0;\n\t                addNotation(null);\n\t                var bracketedNotations = _this2.parseNotations(ctxt, match[__notationsRegex_group_insideBraces], sourceIndex + 1);\n\t                // Set the width of these notations to 0\n\t                bracketedNotations.forEach(function (neume) {\n\t                  neume.hasNoWidth = true;\n\t                  neume.firstWithNoWidth = bracketedNotations[0];\n\t                });\n\t                notations.push.apply(notations, _toConsumableArray(bracketedNotations));\n\t              })();\n\t            } else {\n\t              // looks like it's a note\n\t              if (insertionIndex === -1) {\n\t                trailingSpace = TrailingSpaceMultiple(1);\n\t                addNotation(null);\n\t              }\n\t              this.createNoteFromData(ctxt, ctxt.activeClef, atom, notes, sourceIndex);\n\t              --insertionIndex;\n\t            }\n\t            break;\n\t        }\n\t      }\n\t\n\t      // finish up any remaining notes we have left\n\t      addNotation(null);\n\t\n\t      return notations;\n\t    }\n\t  }, {\n\t    key: \"createNeumesFromNotes\",\n\t    value: function createNeumesFromNotes(ctxt, notes, finalTrailingSpace) {\n\t      var neumes = [];\n\t      var firstNoteIndex = 0;\n\t      var currNoteIndex = 0;\n\t\n\t      // here we use a simple finite state machine to create the neumes from the notes\n\t      // createNeume is helper function which returns the next state after a neume is created\n\t      // (unknownState). Each state object has a neume() function and a handle() function.\n\t      // neume() allows us to create the neume of the state in the event that we run out\n\t      // of notes. handle() gives the state an opportunity to examine the currNote and\n\t      // determine what to do...either transition to a different neume/state, or\n\t      // continue building the neume of that state. handle() returns the next state\n\t\n\t      var createNeume = function createNeume(neume, includeCurrNote) {\n\t        var includePrevNote = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\t\n\t        // add the notes to the neume\n\t        var lastNoteIndex;\n\t        if (includeCurrNote) lastNoteIndex = currNoteIndex;else if (includePrevNote) lastNoteIndex = currNoteIndex - 1;else lastNoteIndex = currNoteIndex - 2;\n\t\n\t        if (lastNoteIndex < 0) return;\n\t\n\t        while (firstNoteIndex <= lastNoteIndex) {\n\t          var note = notes[firstNoteIndex++];\n\t          neume.addNote(note);\n\t          if (note.alText) {\n\t            if (!neume.alText) neume.alText = [];\n\t            neume.alText.push(note.alText);\n\t            note.alText.noteIndex = firstNoteIndex - 1;\n\t          }\n\t        }\n\t\n\t        neumes.push(neume);\n\t\n\t        if (includeCurrNote === false) {\n\t          currNoteIndex--;\n\t\n\t          if (includePrevNote === false) currNoteIndex--;\n\t\n\t          neume.keepWithNext = true;\n\t          if (notes[currNoteIndex + 1].shape === _ExsurgeChant.NoteShape.Quilisma) neume.trailingSpace = 0;else {\n\t            neume.trailingSpace = TrailingSpaceMultiple(1);\n\t            neume.allowLineBreakBeforeNext = true;\n\t          }\n\t        }\n\t\n\t        return unknownState;\n\t      };\n\t\n\t      var unknownState = {\n\t        neume: function neume() {\n\t          return new Neumes.Punctum();\n\t        },\n\t        handle: function handle(currNote, prevNote) {\n\t          if (currNote.shape === _ExsurgeChant.NoteShape.Virga) return virgaState;else if (currNote.shape === _ExsurgeChant.NoteShape.Stropha) return apostrophaState;else if (currNote.shape === _ExsurgeChant.NoteShape.Oriscus) return oriscusState;else if (currNote.shape === _ExsurgeChant.NoteShape.Inclinatum) return punctaInclinataState;else if (currNote.shapeModifiers & _ExsurgeChant.NoteShapeModifiers.Cavum) return createNeume(new Neumes.Punctum(), true);else return punctumState;\n\t        }\n\t      };\n\t\n\t      var punctumState = {\n\t        neume: function neume() {\n\t          return new Neumes.Punctum();\n\t        },\n\t        handle: function handle(currNote, prevNote, notesRemaining) {\n\t          if (currNote.shape || prevNote.liquescent === _ExsurgeChant.LiquescentType.Small) {\n\t            var neume = new Neumes.Punctum();\n\t            var state = createNeume(neume, false);\n\t            // if the current note is on a space within the staff AND the previous note is on the line below AND the previous note has a mora,\n\t            // then we went the trailing space at its default of intraNeumeSpacing to prevent the dot from running up into the current note.\n\t            // Otherwise, we want no trailing space.\n\t            if (currNote.staffPosition > prevNote.staffPosition && (currNote.staffPosition % 2 === 1 || prevNote.staffPosition !== currNote.staffPosition - 1 || !prevNote.morae || prevNote.morae.length === 0)) neume.trailingSpace = 0;\n\t            return state;\n\t          }\n\t\n\t          if (currNote.staffPosition > prevNote.staffPosition) {\n\t            if (currNote.ictus) currNote.ictus.positionHint = _ExsurgeDrawing.MarkingPositionHint.Above;\n\t            return podatusState;\n\t          } else if (currNote.staffPosition < prevNote.staffPosition) {\n\t            if (prevNote.ictus) prevNote.ictus.positionHint = _ExsurgeDrawing.MarkingPositionHint.Above;\n\t            if (currNote.shape === _ExsurgeChant.NoteShape.Inclinatum) return climacusState;else {\n\t              return clivisState;\n\t            }\n\t          } else if (!prevNote.morae || !prevNote.morae.length) {\n\t            return distrophaState;\n\t          }\n\t          return createNeume(new Neumes.Punctum(), false);\n\t        }\n\t      };\n\t\n\t      var punctaInclinataState = {\n\t        neume: function neume() {\n\t          return new Neumes.PunctaInclinata();\n\t        },\n\t        handle: function handle() {\n\t          if (currNote.shape !== _ExsurgeChant.NoteShape.Inclinatum) return createNeume(new Neumes.PunctaInclinata(), false);else return punctaInclinataState;\n\t        }\n\t      };\n\t\n\t      var oriscusState = {\n\t        neume: function neume() {\n\t          return new Neumes.Oriscus();\n\t        },\n\t        handle: function handle(currNote, prevNote) {\n\t          if (currNote.shape === _ExsurgeChant.NoteShape.Default) {\n\t            if (currNote.staffPosition > prevNote.staffPosition) {\n\t              prevNote.shapeModifiers |= _ExsurgeChant.NoteShapeModifiers.Ascending;\n\t              return createNeume(new Neumes.PesQuassus(), true);\n\t            } else if (currNote.staffPosition < prevNote.staffPosition) {\n\t              prevNote.shapeModifiers |= _ExsurgeChant.NoteShapeModifiers.Descending;\n\t              return createNeume(new Neumes.Clivis(), true);\n\t            }\n\t          }\n\t          // stand alone oriscus\n\t          var neume = new Neumes.Oriscus(),\n\t              state = createNeume(neume, false);\n\t          // if the current note is on a space within the staff AND the previous note is on the line below AND the previous note has a mora,\n\t          // then we went the trailing space at its default of intraNeumeSpacing to prevent the dot from running up into the current note.\n\t          // Otherwise, we want no trailing space.\n\t          if (currNote.staffPosition > prevNote.staffPosition && (currNote.staffPosition % 2 === 1 || prevNote.staffPosition !== currNote.staffPosition - 1 || !prevNote.morae || prevNote.morae.length === 0)) neume.trailingSpace = 0;\n\t          return state;\n\t        }\n\t      };\n\t\n\t      var podatusState = {\n\t        neume: function neume() {\n\t          return new Neumes.Podatus();\n\t        },\n\t        handle: function handle(currNote, prevNote) {\n\t          if (currNote.staffPosition > prevNote.staffPosition) {\n\t            if (currNote.ictus) currNote.ictus.positionHint = _ExsurgeDrawing.MarkingPositionHint.Above;\n\t            if (prevNote.ictus) prevNote.ictus.positionHint = _ExsurgeDrawing.MarkingPositionHint.Below;\n\t\n\t            if (prevNote.shape === _ExsurgeChant.NoteShape.Oriscus) return salicusState;else return scandicusState;\n\t          } else if (currNote.staffPosition < prevNote.staffPosition) {\n\t            if (currNote.shape === _ExsurgeChant.NoteShape.Inclinatum) return pesSubpunctisState;else return torculusState;\n\t          } else return createNeume(new Neumes.Podatus(), false);\n\t        }\n\t      };\n\t\n\t      var clivisState = {\n\t        neume: function neume() {\n\t          return new Neumes.Clivis();\n\t        },\n\t        handle: function handle(currNote, prevNote) {\n\t          if (currNote.shape === _ExsurgeChant.NoteShape.Default && currNote.staffPosition > prevNote.staffPosition) {\n\t            if (currNote.ictus) currNote.ictus.positionHint = _ExsurgeDrawing.MarkingPositionHint.Above;\n\t            return porrectusState;\n\t          } else if (currNote.staffPosition < prevNote.staffPosition && currNote.liquescent & _ExsurgeChant.LiquescentType.Small) {\n\t            return createNeume(new Neumes.Ancus(), true);\n\t          } else {\n\t            return createNeume(new Neumes.Clivis(), false);\n\t          }\n\t        }\n\t      };\n\t\n\t      var climacusState = {\n\t        neume: function neume() {\n\t          return new Neumes.Climacus();\n\t        },\n\t        handle: function handle(currNote, prevNote) {\n\t          if (currNote.shape !== _ExsurgeChant.NoteShape.Inclinatum) return createNeume(new Neumes.Climacus(), false);else return state;\n\t        }\n\t      };\n\t\n\t      var porrectusState = {\n\t        neume: function neume() {\n\t          return new Neumes.Porrectus();\n\t        },\n\t        handle: function handle(currNote, prevNote) {\n\t          if (currNote.shape === _ExsurgeChant.NoteShape.Default && currNote.staffPosition < prevNote.staffPosition) return createNeume(new Neumes.PorrectusFlexus(), true);else return createNeume(new Neumes.Porrectus(), false);\n\t        }\n\t      };\n\t\n\t      var pesSubpunctisState = {\n\t        neume: function neume() {\n\t          return new Neumes.PesSubpunctis();\n\t        },\n\t        handle: function handle(currNote, prevNote) {\n\t          if (currNote.shape !== _ExsurgeChant.NoteShape.Inclinatum) return createNeume(new Neumes.PesSubpunctis(), false);else return state;\n\t        }\n\t      };\n\t\n\t      var salicusState = {\n\t        neume: function neume() {\n\t          return new Neumes.Salicus();\n\t        },\n\t        handle: function handle(currNote, prevNote) {\n\t          if (currNote.staffPosition < prevNote.staffPosition) return salicusFlexusState;else return createNeume(new Neumes.Salicus(), false);\n\t        }\n\t      };\n\t\n\t      var salicusFlexusState = {\n\t        neume: function neume() {\n\t          return new Neumes.SalicusFlexus();\n\t        },\n\t        handle: function handle(currNote, prevNote) {\n\t          return createNeume(new Neumes.SalicusFlexus(), false);\n\t        }\n\t      };\n\t\n\t      var scandicusState = {\n\t        neume: function neume() {\n\t          return new Neumes.Scandicus();\n\t        },\n\t        handle: function handle(currNote, prevNote) {\n\t          if (prevNote.shape === _ExsurgeChant.NoteShape.Virga && currNote.shape === _ExsurgeChant.NoteShape.Inclinatum && currNote.staffPosition < prevNote.staffPosition) {\n\t            // if we get here, then it seems we have a podatus, now being followed by a climacus\n\t            // rather than a scandicus. react accordingly\n\t            return createNeume(new Neumes.Podatus(), false, false);\n\t          } else if (currNote.shape === _ExsurgeChant.NoteShape.Default && currNote.staffPosition < prevNote.staffPosition) return scandicusFlexusState;else return createNeume(new Neumes.Scandicus(), false);\n\t        }\n\t      };\n\t\n\t      var scandicusFlexusState = {\n\t        neume: function neume() {\n\t          return new Neumes.ScandicusFlexus();\n\t        },\n\t        handle: function handle(currNote, prevNote) {\n\t          return createNeume(new Neumes.ScandicusFlexus(), false);\n\t        }\n\t      };\n\t\n\t      var virgaState = {\n\t        neume: function neume() {\n\t          return new Neumes.Virga();\n\t        },\n\t        handle: function handle(currNote, prevNote) {\n\t          if (currNote.shape === _ExsurgeChant.NoteShape.Inclinatum && currNote.staffPosition < prevNote.staffPosition) return climacusState;else if (currNote.shape === _ExsurgeChant.NoteShape.Virga && currNote.staffPosition === prevNote.staffPosition) return bivirgaState;else return createNeume(new Neumes.Virga(), false);\n\t        }\n\t      };\n\t\n\t      var bivirgaState = {\n\t        neume: function neume() {\n\t          return new Neumes.Bivirga();\n\t        },\n\t        handle: function handle(currNote, prevNote) {\n\t          if (currNote.shape === _ExsurgeChant.NoteShape.Virga && currNote.staffPosition === prevNote.staffPosition) return createNeume(new Neumes.Trivirga(), true);else return createNeume(new Neumes.Bivirga(), false);\n\t        }\n\t      };\n\t\n\t      var apostrophaState = {\n\t        neume: function neume() {\n\t          return new Neumes.Apostropha();\n\t        },\n\t        handle: function handle(currNote, prevNote) {\n\t          if (currNote.staffPosition === prevNote.staffPosition) return distrophaState;else return createNeume(new Neumes.Apostropha(), false);\n\t        }\n\t      };\n\t\n\t      var distrophaState = {\n\t        neume: function neume() {\n\t          return new Neumes.Distropha();\n\t        },\n\t        handle: function handle(currNote, prevNote) {\n\t          if (currNote.staffPosition === prevNote.staffPosition) {\n\t            if (prevNote.morae && prevNote.morae.length) {\n\t              return createNeume(new Neumes.Distropha(), false);\n\t            } else {\n\t              return tristrophaState;\n\t            }\n\t          } else return createNeume(new Neumes.Apostropha(), false, false);\n\t        }\n\t      };\n\t\n\t      var tristrophaState = {\n\t        neume: function neume() {\n\t          return new Neumes.Tristropha();\n\t        },\n\t        handle: function handle(currNote, prevNote) {\n\t          // we only create a tristropha when the note run ends after three\n\t          // and the neume() function of this state is called. Otherwise\n\t          // we always interpret the third note to belong to the next sequence\n\t          // of notes.\n\t          //\n\t          // fixme: gabc allows any number of punctum/stropha in succession...\n\t          // is this a valid neume type? Or is it just multiple *stropha neumes\n\t          // in succession? Should we simplify the apostropha/distropha/\n\t          // tristropha classes to a generic stropha neume that can have 1 or\n\t          // more successive notes?\n\t          return createNeume(new Neumes.Distropha(), false, false);\n\t        }\n\t      };\n\t\n\t      var torculusState = {\n\t        neume: function neume() {\n\t          return new Neumes.Torculus();\n\t        },\n\t        handle: function handle(currNote, prevNote) {\n\t          if (currNote.shape === _ExsurgeChant.NoteShape.Default && currNote.staffPosition > prevNote.staffPosition) {\n\t            var prevNoteButOne = notes[currNoteIndex - 2];\n\t            if (prevNoteButOne && prevNoteButOne.staffPosition - prevNote.staffPosition <= 4) {\n\t              if (currNote.ictus) currNote.ictus.positionHint = _ExsurgeDrawing.MarkingPositionHint.Above;\n\t              return torculusResupinusState;\n\t            }\n\t          }\n\t          return createNeume(new Neumes.Torculus(), false);\n\t        }\n\t      };\n\t\n\t      var torculusResupinusState = {\n\t        neume: function neume() {\n\t          return new Neumes.TorculusResupinus();\n\t        },\n\t        handle: function handle(currNote, prevNote) {\n\t          if (currNote.shape === _ExsurgeChant.NoteShape.Default && currNote.staffPosition < prevNote.staffPosition) return createNeume(new Neumes.TorculusResupinusFlexus(), true);else return createNeume(new Neumes.TorculusResupinus(), false);\n\t        }\n\t      };\n\t\n\t      var state = unknownState;\n\t\n\t      while (currNoteIndex < notes.length) {\n\t        var prevNote = currNoteIndex > 0 ? notes[currNoteIndex - 1] : null;\n\t        var currNote = notes[currNoteIndex];\n\t\n\t        state = state.handle(currNote, prevNote, notes.length - 1 - currNoteIndex);\n\t\n\t        // if we are on the last note, then try to create a neume if we need to.\n\t        if (currNoteIndex === notes.length - 1 && state !== unknownState) createNeume(state.neume(), true);\n\t\n\t        currNoteIndex++;\n\t      }\n\t\n\t      if (neumes.length > 0) {\n\t        if (!finalTrailingSpace.isDefault) {\n\t          neumes[neumes.length - 1].trailingSpace = finalTrailingSpace;\n\t          neumes[neumes.length - 1].keepWithNext = true;\n\t\n\t          if (finalTrailingSpace > 0) neumes[neumes.length - 1].allowLineBreakBeforeNext = neumes[neumes.length - 1].keepWithNext = true;\n\t        }\n\t      }\n\t\n\t      return neumes;\n\t    }\n\t\n\t    // appends any notes created to the notes array argument\n\t\n\t  }, {\n\t    key: \"createNoteFromData\",\n\t    value: function createNoteFromData(ctxt, clef, data, notes, sourceIndex) {\n\t      var note = new _ExsurgeChant.Note();\n\t      note.sourceIndex = sourceIndex;\n\t      note.sourceGabc = data;\n\t\n\t      if (data.length < 1) throw \"Invalid note data: \" + data;\n\t\n\t      if (data[0] === \"-\") {\n\t        // liquescent initio debilis\n\t        note.liquescent = _ExsurgeChant.LiquescentType.InitioDebilis;\n\t        data = data.substring(1);\n\t      }\n\t\n\t      if (data.length < 1) throw \"Invalid note data: \" + data;\n\t\n\t      // the next char is always the pitch\n\t      var pitch = this.gabcHeightToExsurgePitch(clef, data[0]);\n\t\n\t      if (data[0] === data[0].toUpperCase()) note.shape = _ExsurgeChant.NoteShape.Inclinatum;\n\t\n\t      note.staffPosition = this.gabcHeightToExsurgeHeight(data[0]);\n\t      note.pitch = pitch;\n\t\n\t      var mark;\n\t\n\t      var episemaNoteIndex = notes.length;\n\t      var episemaNote = note;\n\t\n\t      // process the modifiers\n\t      for (var i = 1; i < data.length; i++) {\n\t        var c = data[i];\n\t        var lookahead = \"\\0\";\n\t\n\t        var haveLookahead = i + 1 < data.length;\n\t        if (haveLookahead) lookahead = data[i + 1];\n\t\n\t        switch (c) {\n\t          // rhythmic markings\n\t          case \".\":\n\t            mark = null;\n\t\n\t            // gabc supports putting up to two morae on each note, by repeating the\n\t            // period. here, we check to see if we've already created a mora for the\n\t            // note, and if so, we simply force the second one to have an Above\n\t            // position hint. if a user decides to try to put position indicators\n\t            // on the double morae (such as 1 or 2), then really the behavior is\n\t            // not defined by gabc, so it's on the user to figure it out.\n\t            if (note.morae.length > 0 && notes.length) {\n\t              var previousNote = notes.slice(-1)[0];\n\t              var previousMora = note.morae.slice(-1)[0];\n\t              previousMora.note = previousNote;\n\t            }\n\t\n\t            mark = new Markings.Mora(ctxt, note);\n\t            if (haveLookahead && lookahead === \"1\") mark.positionHint = _ExsurgeDrawing.MarkingPositionHint.Above;else if (haveLookahead && lookahead === \"0\") mark.positionHint = _ExsurgeDrawing.MarkingPositionHint.Below;\n\t\n\t            note.morae.push(mark);\n\t            break;\n\t\n\t          case \"_\":\n\t            var episemaHadModifier = false;\n\t\n\t            mark = new Markings.HorizontalEpisema(episemaNote);\n\t            while (haveLookahead) {\n\t              if (lookahead === \"0\") mark.positionHint = _ExsurgeDrawing.MarkingPositionHint.Below;else if (lookahead === \"1\") mark.positionHint = _ExsurgeDrawing.MarkingPositionHint.Above;else if (lookahead === \"2\") mark.terminating = true;\n\t              // episema terminates\n\t              else if (lookahead === \"3\") mark.alignment = Markings.HorizontalEpisemaAlignment.Left;else if (lookahead === \"4\") mark.alignment = Markings.HorizontalEpisemaAlignment.Center;else if (lookahead === \"5\") mark.alignment = Markings.HorizontalEpisemaAlignment.Right;else break;\n\t\n\t              // the gabc definition for episemata is so convoluted...\n\t              // - double underscores create episemata over multiple notes.\n\t              // - unless the _ has a 0, 1, 3, 4, or 5 modifier, which means\n\t              //   another underscore puts a second episema on the same note\n\t              // - (when there's a 2 lookahead, then this is treated as an\n\t              //   unmodified underscore, so another underscore would be\n\t              //   added to previous notes\n\t              if (mark.alignment !== Markings.HorizontalEpisemaAlignment.Default && mark.positionHint !== _ExsurgeDrawing.MarkingPositionHint.Below) episemaHadModifier = true;\n\t\n\t              i++;\n\t              haveLookahead = i + 1 < data.length;\n\t\n\t              if (haveLookahead) lookahead = data[i + 1];\n\t            }\n\t\n\t            // since gabc allows consecutive underscores which is a shortcut to\n\t            // apply the episemata to previous notes, we keep track of that here\n\t            // in order to add the new episema to the correct note.\n\t\n\t            if (episemaNote) episemaNote.episemata.push(mark);\n\t\n\t            if (episemaNote === note && episemaHadModifier) episemaNote = note;else if (episemaNoteIndex >= 0 && notes.length > 0) episemaNote = notes[--episemaNoteIndex];\n\t\n\t            break;\n\t\n\t          case \"'\":\n\t            mark = new Markings.Ictus(ctxt, note);\n\t            if (haveLookahead && lookahead === \"1\") mark.positionHint = _ExsurgeDrawing.MarkingPositionHint.Above;else if (haveLookahead && lookahead === \"0\") mark.positionHint = _ExsurgeDrawing.MarkingPositionHint.Below;else if (note.shape === _ExsurgeChant.NoteShape.Virga)\n\t              // ictus on a virga goes above by default:\n\t              mark.positionHint = _ExsurgeDrawing.MarkingPositionHint.Above;\n\t\n\t            note.ictus = mark;\n\t            break;\n\t\n\t          //note shapes\n\t          case \"r\":\n\t            if (haveLookahead && /^[0-5]$/.test(lookahead)) {\n\t              switch (lookahead) {\n\t                case \"0\":\n\t                  note.shapeModifiers |= _ExsurgeChant.NoteShapeModifiers.Cavum;\n\t                  note.shapeModifiers |= _ExsurgeChant.NoteShapeModifiers.Linea;\n\t                  break;\n\t                case \"1\":\n\t                  note.accent = new Markings.Accent(ctxt, note, _ExsurgeDrawing.GlyphCode.AcuteAccent);\n\t                  break;\n\t                case \"2\":\n\t                  note.accent = new Markings.Accent(ctxt, note, _ExsurgeDrawing.GlyphCode.GraveAccent);\n\t                  break;\n\t                case \"3\":\n\t                  note.accent = new Markings.Accent(ctxt, note, _ExsurgeDrawing.GlyphCode.Circle);\n\t                  break;\n\t                case \"4\":\n\t                  note.accent = new Markings.Accent(ctxt, note, _ExsurgeDrawing.GlyphCode.Semicircle);\n\t                  break;\n\t                case \"5\":\n\t                  note.accent = new Markings.Accent(ctxt, note, _ExsurgeDrawing.GlyphCode.ReversedSemicircle);\n\t                  break;\n\t                default:\n\t              }\n\t              i++;\n\t            } else note.shapeModifiers |= _ExsurgeChant.NoteShapeModifiers.Cavum;\n\t            break;\n\t\n\t          case \"R\":\n\t            note.shapeModifiers |= _ExsurgeChant.NoteShapeModifiers.Linea;\n\t            break;\n\t\n\t          case \"s\":\n\t            if (note.shape === _ExsurgeChant.NoteShape.Stropha) {\n\t              // if we're already a stropha, that means this is gabc's\n\t              // quick stropha feature (e.g., gsss). create a new note\n\t              var newNote = new _ExsurgeChant.Note();\n\t              newNote.sourceIndex = sourceIndex + i;\n\t              newNote.sourceGabc = \"s\";\n\t              newNote.staffPosition = note.staffPosition;\n\t              newNote.pitch = note.pitch;\n\t              notes.push(note);\n\t              note = newNote;\n\t              episemaNoteIndex++; // since a new note was added, increase the index here\n\t            }\n\t\n\t            note.shape = _ExsurgeChant.NoteShape.Stropha;\n\t            break;\n\t\n\t          case \"v\":\n\t            if (note.shape === _ExsurgeChant.NoteShape.Virga) {\n\t              // if we're already a stropha, that means this is gabc's\n\t              // quick virga feature (e.g., gvvv). create a new note\n\t              var _newNote = new _ExsurgeChant.Note();\n\t              _newNote.sourceIndex = sourceIndex + i;\n\t              _newNote.sourceGabc = \"v\";\n\t              _newNote.staffPosition = note.staffPosition;\n\t              _newNote.pitch = note.pitch;\n\t              notes.push(note);\n\t              note = _newNote;\n\t              episemaNoteIndex++; // since a new note was added, increase the index here\n\t            }\n\t\n\t            note.shape = _ExsurgeChant.NoteShape.Virga;\n\t            break;\n\t\n\t          case \"V\":\n\t            note.shape = _ExsurgeChant.NoteShape.Virga;\n\t            note.shapeModifers |= _ExsurgeChant.NoteShapeModifiers.Reverse;\n\t            break;\n\t\n\t          case \"w\":\n\t            note.shape = _ExsurgeChant.NoteShape.Quilisma;\n\t            break;\n\t\n\t          case \"o\":\n\t            note.shape = _ExsurgeChant.NoteShape.Oriscus;\n\t            if (haveLookahead && lookahead === \"<\") {\n\t              note.shapeModifiers |= _ExsurgeChant.NoteShapeModifiers.Ascending;\n\t              i++;\n\t            } else if (haveLookahead && lookahead === \">\") {\n\t              note.shapeModifiers |= _ExsurgeChant.NoteShapeModifiers.Descending;\n\t              i++;\n\t            }\n\t            break;\n\t\n\t          case \"O\":\n\t            note.shape = _ExsurgeChant.NoteShape.Oriscus;\n\t            if (haveLookahead && lookahead === \"<\") {\n\t              note.shapeModifiers |= _ExsurgeChant.NoteShapeModifiers.Ascending | _ExsurgeChant.NoteShapeModifiers.Stemmed;\n\t              i++;\n\t            } else if (haveLookahead && lookahead === \">\") {\n\t              note.shapeModifiers |= _ExsurgeChant.NoteShapeModifiers.Descending | _ExsurgeChant.NoteShapeModifiers.Stemmed;\n\t              i++;\n\t            } else note.shapeModifiers |= _ExsurgeChant.NoteShapeModifiers.Stemmed;\n\t            break;\n\t\n\t          // liquescents\n\t          case \"~\":\n\t            if (note.shape === _ExsurgeChant.NoteShape.Inclinatum) note.liquescent |= _ExsurgeChant.LiquescentType.Small;else if (note.shape === _ExsurgeChant.NoteShape.Oriscus) note.liquescent |= _ExsurgeChant.LiquescentType.Large;else note.liquescent |= _ExsurgeChant.LiquescentType.Small;\n\t            break;\n\t          case \"<\":\n\t            note.liquescent |= _ExsurgeChant.LiquescentType.Ascending;\n\t            break;\n\t          case \">\":\n\t            note.liquescent |= _ExsurgeChant.LiquescentType.Descending;\n\t            break;\n\t\n\t          // accidentals\n\t          case \"x\":\n\t            if (note.pitch.step === _ExsurgeCore.Step.Mi) note.pitch.step = _ExsurgeCore.Step.Me;else if (note.pitch.step === _ExsurgeCore.Step.Ti) note.pitch.step = _ExsurgeCore.Step.Te;\n\t            break;\n\t          case \"y\":\n\t            if (note.pitch.step === _ExsurgeCore.Step.Te) note.pitch.step = _ExsurgeCore.Step.Ti;else if (note.pitch.step === _ExsurgeCore.Step.Me) note.pitch.step = _ExsurgeCore.Step.Mi;else if (note.pitch.step === _ExsurgeCore.Step.Du) note.pitch.step = _ExsurgeCore.Step.Do;else if (note.pitch.step === _ExsurgeCore.Step.Fu) note.pitch.step = _ExsurgeCore.Step.Fa;\n\t            break;\n\t          case \"#\":\n\t            if (note.pitch.step === _ExsurgeCore.Step.Do) note.pitch.step = _ExsurgeCore.Step.Du;else if (note.pitch.step === _ExsurgeCore.Step.Fa) note.pitch.step = _ExsurgeCore.Step.Fu;\n\t            break;\n\t\n\t          // gabc special item groups\n\t          case \"[\":\n\t            // read in the whole group and parse it\n\t            var startIndex = ++i;\n\t            while (i < data.length && data[i] !== \"]\") {\n\t              i++;\n\t            }this.processInstructionForNote(ctxt, note, data.substring(startIndex, i), startIndex);\n\t            break;\n\t        }\n\t      }\n\t\n\t      if (this.needToEndBrace && !note.braceStart && !note.braceEnd && !/[xy#]/.test(c)) {\n\t        note.braceEnd = new Markings.BracePoint(note, this.needToEndBrace.isAbove, this.needToEndBrace.shape, this.needToEndBrace.attachment === Markings.BraceAttachment.Left ? Markings.BraceAttachment.Right : Markings.BraceAttachment.Left);\n\t        note.braceEnd.automatic = true;\n\t        delete this.needToEndBrace;\n\t      }\n\t\n\t      notes.push(note);\n\t    }\n\t\n\t    // an instruction in this context is referring to a special gabc coding found after\n\t    // notes between ['s and ]'s. choral signs and braces fall into this\n\t    // category.\n\t    //\n\t    // currently only brace instructions are supported here!\n\t\n\t  }, {\n\t    key: \"processInstructionForNote\",\n\t    value: function processInstructionForNote(ctxt, note, instruction, sourceIndexOffset) {\n\t      var results = instruction.match(__bracketedCommandRegex);\n\t      if (results === null) return;\n\t      var cmd = results[1];\n\t      var data = results[2];\n\t      switch (cmd) {\n\t        case \"cs\":\n\t          note.choralSign = new _ExsurgeDrawing.ChoralSign(ctxt, data, note, note.sourceIndex + sourceIndexOffset, instruction.length);\n\t          return;\n\t        case \"alt\":\n\t          note.alText = new _ExsurgeDrawing.AboveLinesText(ctxt, data, note, note.sourceIndex + sourceIndexOffset, instruction.length);\n\t          return;\n\t      }\n\t\n\t      results = instruction.match(__braceSpecRegex);\n\t\n\t      if (results === null) return;\n\t\n\t      // see the comments at the definition of __braceSpecRegex for the\n\t      // capturing groups\n\t      var above = results[1] === \"o\";\n\t      var shape = Markings.BraceShape.CurlyBrace; // default\n\t\n\t      switch (results[2]) {\n\t        case \"b\":\n\t          shape = Markings.BraceShape.RoundBrace;\n\t          break;\n\t        case \"cb\":\n\t          shape = Markings.BraceShape.CurlyBrace;\n\t          break;\n\t        case \"cba\":\n\t          shape = Markings.BraceShape.AccentedCurlyBrace;\n\t          break;\n\t      }\n\t\n\t      var attachmentPoint = results[3] === \"1\" ? Markings.BraceAttachment.Left : Markings.BraceAttachment.Right;\n\t\n\t      if (results[4] === \"{\" || results[5]) note.braceStart = new Markings.BracePoint(note, above, shape, attachmentPoint);else note.braceEnd = new Markings.BracePoint(note, above, shape, attachmentPoint);\n\t\n\t      // just have the next note end a brace that uses length;\n\t      if (results[5]) {\n\t        note.braceStart.automatic = true;\n\t        this.needToEndBrace = note.braceStart;\n\t      }\n\t    }\n\t\n\t    // takes raw gabc text source and parses it into words. For example, passing\n\t    // in a string of \"me(f.) (,) ma(fff)num(d!ewf) tu(fgF'E)am,(f.)\" would return\n\t    // an array of four strings: [\"me(f.)\", \"(,)\", \"ma(fff)num(d!ewf)\", \"tu(fgF'E)am,(f.)\"]\n\t\n\t  }, {\n\t    key: \"splitWords\",\n\t    value: function splitWords(gabcNotations) {\n\t      // split the notations on whitespace boundaries, as long as the space\n\t      // immediately follows a set of parentheses. Prior to doing that, we replace\n\t      // all whitespace with spaces, which prevents tabs and newlines from ending\n\t      // up in the notation data.\n\t      gabcNotations = gabcNotations\n\t      // .trim()\n\t      // .replace(/\\s/g, \" \")\n\t      .replace(/\\)\\s(?=[^\\)]*(?:\\(|$))/g, \")\\n\");\n\t      return gabcNotations.split(/\\n/g);\n\t    }\n\t  }, {\n\t    key: \"parseSource\",\n\t    value: function parseSource(gabcSource) {\n\t      return this.parseWords(this.splitWords(gabcSource));\n\t    }\n\t\n\t    // gabcWords is an array of strings, e.g., the result of splitWords above\n\t\n\t  }, {\n\t    key: \"parseWords\",\n\t    value: function parseWords(gabcWords) {\n\t      var words = [];\n\t\n\t      for (var i = 0; i < gabcWords.length; i++) {\n\t        words.push(this.parseWord(gabcWords[i]));\n\t      }return words;\n\t    }\n\t\n\t    // returns an array of objects, each of which has the following properties\n\t    //  - notations (string)\n\t    //  - lyrics (array of strings)\n\t\n\t  }, {\n\t    key: \"parseWord\",\n\t    value: function parseWord(gabcWord) {\n\t      var syllables = [];\n\t      var matches = [];\n\t\n\t      syllables.wordLength = gabcWord.length;\n\t\n\t      while (match = __syllablesRegex.exec(gabcWord)) {\n\t        matches.push(match);\n\t      }for (var j = 0; j < matches.length; j++) {\n\t        var match = matches[j];\n\t\n\t        var lyrics = match[1].trim().split(\"|\");\n\t        var notations = match[2];\n\t\n\t        syllables.push({\n\t          notations: notations,\n\t          lyrics: lyrics\n\t        });\n\t      }\n\t\n\t      return syllables;\n\t    }\n\t\n\t    // returns pitch\n\t\n\t  }, {\n\t    key: \"gabcHeightToExsurgeHeight\",\n\t    value: function gabcHeightToExsurgeHeight(gabcHeight) {\n\t      return gabcHeight.toLowerCase().charCodeAt(0) - \"c\".charCodeAt(0);\n\t    }\n\t\n\t    // returns pitch\n\t\n\t  }, {\n\t    key: \"gabcHeightToExsurgePitch\",\n\t    value: function gabcHeightToExsurgePitch(clef, gabcHeight) {\n\t      var exsurgeHeight = this.gabcHeightToExsurgeHeight(gabcHeight);\n\t\n\t      var pitch = clef.staffPositionToPitch(exsurgeHeight);\n\t\n\t      return pitch;\n\t    }\n\t  }]);\n\n\t  return Gabc;\n\t}();\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Virga = exports.Tristropha = exports.TorculusResupinusFlexus = exports.TorculusResupinus = exports.Torculus = exports.ScandicusFlexus = exports.Scandicus = exports.SalicusFlexus = exports.Salicus = exports.Punctum = exports.PunctaInclinata = exports.PorrectusFlexus = exports.Porrectus = exports.Podatus = exports.PesSubpunctis = exports.PesQuassus = exports.Oriscus = exports.Distropha = exports.Ancus = exports.Clivis = exports.Climacus = exports.Trivirga = exports.Bivirga = exports.Apostropha = exports.Neume = undefined;\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); //\n\t// Author(s):\n\t// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>\n\t//\n\t// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a copy\n\t// of this software and associated documentation files (the \"Software\"), to deal\n\t// in the Software without restriction, including without limitation the rights\n\t// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\t// copies of the Software, and to permit persons to whom the Software is\n\t// furnished to do so, subject to the following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included in\n\t// all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\t// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\t// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\t// THE SOFTWARE.\n\t//\n\t\n\tvar _ExsurgeChant = __webpack_require__(8);\n\t\n\tvar _ExsurgeDrawing = __webpack_require__(4);\n\t\n\tvar _ExsurgeGlyphs = __webpack_require__(3);\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar NeumeBuilder = function () {\n\t  function NeumeBuilder(ctxt, neume) {\n\t    var startingX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\t\n\t    _classCallCheck(this, NeumeBuilder);\n\t\n\t    this.ctxt = ctxt;\n\t    this.neume = neume;\n\t    this.x = startingX;\n\t    this.lastNote = null;\n\t    this.lineIsHanging = false;\n\t    this.minX = 0;\n\t  }\n\t\n\t  // used to start a hanging line on the left of the next note\n\t\n\t\n\t  _createClass(NeumeBuilder, [{\n\t    key: \"lineFrom\",\n\t    value: function lineFrom(note) {\n\t      var previousNotation = this.ctxt.notations[this.ctxt.currNotationIndex - 1];\n\t      if (this.x === 0 && previousNotation && previousNotation.notes && previousNotation.trailingSpace === 0) {\n\t        this.lastNote = previousNotation.notes.slice(-1)[0];\n\t        this.minX = -this.ctxt.neumeLineWeight;\n\t      } else {\n\t        this.lastNote = note;\n\t        this.lineIsHanging = true;\n\t      }\n\t      return this;\n\t    }\n\t\n\t    // add a note, with a connecting line on the left if we have one\n\t\n\t  }, {\n\t    key: \"noteAt\",\n\t    value: function noteAt(note, glyph) {\n\t      var withLineTo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\t\n\t      if (!note) throw \"NeumeBuilder.noteAt: note must be a valid note\";\n\t\n\t      if (!glyph) throw \"NeumeBuilder.noteAt: glyph must be a valid glyph code\";\n\t\n\t      note.setGlyph(this.ctxt, glyph);\n\t      var noteAlignsRight = note.glyphVisualizer.align === \"right\";\n\t\n\t      var needsLine = withLineTo && this.lastNote !== null && (this.lineIsHanging || this.lastNote.glyphVisualizer && this.lastNote.glyphVisualizer.align === \"right\" || Math.abs(this.lastNote.staffPosition - note.staffPosition) > 1);\n\t\n\t      if (needsLine) {\n\t        var line = new _ExsurgeDrawing.NeumeLineVisualizer(this.ctxt, this.lastNote, note, this.lineIsHanging);\n\t        this.neume.addVisualizer(line);\n\t        line.bounds.x = Math.max(this.minX, this.x - line.bounds.width);\n\t\n\t        if (!noteAlignsRight) this.x = line.bounds.x;\n\t      }\n\t\n\t      var xOffset = 0;\n\t      if (note.shapeModifiers & _ExsurgeChant.NoteShapeModifiers.Linea) {\n\t        var linea = new _ExsurgeDrawing.LineaVisualizer(this.ctxt, note);\n\t        this.neume.addVisualizer(linea);\n\t        note.origin.x += linea.origin.x;\n\t        xOffset = linea.origin.x;\n\t      }\n\t\n\t      // if this is the first note of a right aligned glyph (probably an initio debilis),\n\t      // then there's nothing to worry about. but if it's not then first, then this\n\t      // subtraction will right align it visually\n\t      if (noteAlignsRight && this.lastNote) note.bounds.x = this.x - note.bounds.width;else {\n\t        note.bounds.x = this.x + xOffset;\n\t        this.x += note.bounds.width + xOffset;\n\t      }\n\t\n\t      this.neume.addVisualizer(note);\n\t\n\t      this.lastNote = note;\n\t      this.lineIsHanging = false;\n\t\n\t      return this;\n\t    }\n\t\n\t    // a special form of noteAdd that creates a virga\n\t    // uses a punctum cuadratum and a line rather than the virga glyphs\n\t\n\t  }, {\n\t    key: \"virgaAt\",\n\t    value: function virgaAt(note) {\n\t      var withLineTo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t\n\t      // add the punctum for the virga\n\t      this.noteAt(note, _ExsurgeDrawing.GlyphCode.PunctumQuadratum);\n\t\n\t      // add a line for the virga\n\t      var line = new _ExsurgeDrawing.VirgaLineVisualizer(this.ctxt, note);\n\t      this.x -= line.bounds.width;\n\t      if (note.shapeModifers & _ExsurgeChant.NoteShapeModifiers.Reverse) {\n\t        line.bounds.x = 0;\n\t      } else {\n\t        line.bounds.x = this.x;\n\t      }\n\t      this.neume.addVisualizer(line);\n\t\n\t      this.lastNote = note;\n\t      this.lineIsHanging = false;\n\t\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"advanceBy\",\n\t    value: function advanceBy(x) {\n\t      this.lastNote = null;\n\t      this.lineIsHanging = false;\n\t\n\t      this.x += x;\n\t\n\t      return this;\n\t    }\n\t\n\t    // for terminating hanging lines with no lower notes\n\t\n\t  }, {\n\t    key: \"withLineEndingAt\",\n\t    value: function withLineEndingAt(note) {\n\t      if (this.lastNote === null) return;\n\t\n\t      var line = new _ExsurgeDrawing.NeumeLineVisualizer(this.ctxt, this.lastNote, note, true);\n\t      this.neume.addVisualizer(line);\n\t      this.x -= line.bounds.width;\n\t      line.bounds.x = this.x;\n\t\n\t      this.neume.addVisualizer(line);\n\t\n\t      this.lastNote = note;\n\t\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"withPodatus\",\n\t    value: function withPodatus(lowerNote, upperNote) {\n\t      var upperGlyph;\n\t      var lowerGlyph;\n\t\n\t      if (lowerNote.liquescent === _ExsurgeChant.LiquescentType.InitioDebilis) {\n\t        // liquescent upper note or not?\n\t        if (upperNote.liquescent === _ExsurgeChant.LiquescentType.None) upperGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratum;else upperGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent;\n\t\n\t        lowerGlyph = _ExsurgeDrawing.GlyphCode.TerminatingDesLiquescent;\n\t      } else if (upperNote.liquescent & _ExsurgeChant.LiquescentType.Small) {\n\t        lowerGlyph = _ExsurgeDrawing.GlyphCode.BeginningAscLiquescent;\n\t        upperGlyph = _ExsurgeDrawing.GlyphCode.TerminatingAscLiquescent;\n\t      } else if (upperNote.liquescent & _ExsurgeChant.LiquescentType.Ascending) {\n\t        lowerGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratum;\n\t        upperGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumAscLiquescent;\n\t      } else if (upperNote.liquescent & _ExsurgeChant.LiquescentType.Descending) {\n\t        lowerGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratum;\n\t        upperGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent;\n\t      } else {\n\t        // standard shape\n\t        lowerGlyph = _ExsurgeDrawing.GlyphCode.PodatusLower;\n\t        upperGlyph = _ExsurgeDrawing.GlyphCode.PodatusUpper;\n\t      }\n\t\n\t      // allow a quilisma pes\n\t      if (lowerNote.shape === _ExsurgeChant.NoteShape.Quilisma) lowerGlyph = _ExsurgeDrawing.GlyphCode.Quilisma;\n\t\n\t      this.noteAt(lowerNote, lowerGlyph).noteAt(upperNote, upperGlyph);\n\t\n\t      // make sure we don't have lines connected to the podatus\n\t      this.lastNote = null;\n\t\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"withClivisUpper\",\n\t    value: function withClivisUpper(upper, lower) {\n\t      var glyph = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _ExsurgeDrawing.GlyphCode.PunctumQuadratum;\n\t\n\t      if (upper.shape === _ExsurgeChant.NoteShape.Oriscus) this.noteAt(upper, _ExsurgeDrawing.GlyphCode.OriscusDes, false);else {\n\t        if (lower) {\n\t          this.lineFrom(lower);\n\t          this.lineIsHanging = lower.staffPosition < upper.staffPosition;\n\t          if (lower.liquescent & _ExsurgeChant.LiquescentType.Small) {\n\t            glyph = _ExsurgeDrawing.GlyphCode.BeginningDesLiquescent;\n\t          }\n\t        }\n\t        this.noteAt(upper, glyph);\n\t      }\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"withClivisLower\",\n\t    value: function withClivisLower(lower) {\n\t      var lowerGlyph;\n\t      if (lower.liquescent & _ExsurgeChant.LiquescentType.Small) {\n\t        lowerGlyph = _ExsurgeDrawing.GlyphCode.TerminatingDesLiquescent;\n\t      } else if (lower.liquescent === _ExsurgeChant.LiquescentType.Ascending) lowerGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumAscLiquescent;else if (lower.liquescent === _ExsurgeChant.LiquescentType.Descending) lowerGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent;else lowerGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratum;\n\t\n\t      return this.noteAt(lower, lowerGlyph);\n\t    }\n\t  }, {\n\t    key: \"withClivis\",\n\t    value: function withClivis(upper, lower) {\n\t      this.withClivisUpper(upper, lower);\n\t      this.withClivisLower(lower);\n\t\n\t      // make sure we don't have lines connected to the clivis\n\t      this.lastNote = null;\n\t\n\t      return this;\n\t    }\n\t\n\t    // lays out a sequence of notes that are inclinata (e.g., climacus, pes subpunctis)\n\t\n\t  }, {\n\t    key: \"withInclinata\",\n\t    value: function withInclinata(notes) {\n\t      var staffPosition = notes[0].staffPosition,\n\t          prevStaffPosition = notes[0].staffPosition;\n\t\n\t      // it is important to advance by the width of the inclinatum glyph itself\n\t      // rather than by individual note widths, so that any liquescents are spaced\n\t      // the same as non-liquscents\n\t      var advanceWidth = _ExsurgeGlyphs.Glyphs.PunctumInclinatum.bounds.width * this.ctxt.glyphScaling;\n\t\n\t      // now add all the punctum inclinatum\n\t      for (var i = 0; i < notes.length; i++, prevStaffPosition = staffPosition) {\n\t        var note = notes[i];\n\t\n\t        if (note.liquescent & _ExsurgeChant.LiquescentType.Small) note.setGlyph(this.ctxt, _ExsurgeDrawing.GlyphCode.PunctumInclinatumLiquescent);else if (note.liquescent & _ExsurgeChant.LiquescentType.Large)\n\t          // fixme: is the large inclinatum liquescent the same as the apostropha?\n\t          note.setGlyph(this.ctxt, _ExsurgeDrawing.GlyphCode.Stropha);\n\t          // fixme: some climaci in the new chant books end with a punctum quadratum\n\t          // (see, for example, the antiphon \"Sancta Maria\" for October 7).\n\t        else note.setGlyph(this.ctxt, _ExsurgeDrawing.GlyphCode.PunctumInclinatum);\n\t\n\t        staffPosition = note.staffPosition;\n\t\n\t        var multiple = Math.abs(prevStaffPosition - staffPosition);\n\t        switch (multiple) {\n\t          case 0:\n\t            multiple = 1.1;\n\t            break;\n\t          default:\n\t            multiple *= 2 / 3;\n\t            break;\n\t        }\n\t\n\t        if (i > 0) this.x += advanceWidth * multiple;\n\t\n\t        note.bounds.x = this.x;\n\t\n\t        this.neume.addVisualizer(note);\n\t      }\n\t\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"withPorrectusSwash\",\n\t    value: function withPorrectusSwash(start, end) {\n\t      var needsLine = this.lastNote !== null && (this.lineIsHanging || this.lastNote.glyphVisualizer && this.lastNote.glyphVisualizer.align === \"right\" || Math.abs(this.lastNote.staffPosition - start.staffPosition) > 1);\n\t\n\t      if (needsLine) {\n\t        var line = new _ExsurgeDrawing.NeumeLineVisualizer(this.ctxt, this.lastNote, start, this.lineIsHanging);\n\t        this.x = Math.max(this.minX, this.x - line.bounds.width);\n\t        line.bounds.x = this.x;\n\t        this.neume.addVisualizer(line);\n\t      }\n\t\n\t      var glyph;\n\t\n\t      switch (start.staffPosition - end.staffPosition) {\n\t        case 1:\n\t          glyph = _ExsurgeDrawing.GlyphCode.Porrectus1;\n\t          break;\n\t        case 2:\n\t          glyph = _ExsurgeDrawing.GlyphCode.Porrectus2;\n\t          break;\n\t        case 3:\n\t          glyph = _ExsurgeDrawing.GlyphCode.Porrectus3;\n\t          break;\n\t        case 4:\n\t          glyph = _ExsurgeDrawing.GlyphCode.Porrectus4;\n\t          break;\n\t        default:\n\t          // fixme: should we generate an error here?\n\t          glyph = _ExsurgeDrawing.GlyphCode.None;\n\t          break;\n\t      }\n\t\n\t      start.setGlyph(this.ctxt, glyph);\n\t      start.bounds.x = this.x;\n\t\n\t      // the second glyph does not draw anything, but it still has logical importance for the editing\n\t      // environment...it can respond to changes which will then change the swash glyph of the first.\n\t      end.setGlyph(this.ctxt, _ExsurgeDrawing.GlyphCode.None);\n\t\n\t      this.x = start.bounds.right();\n\t      end.bounds.x = this.x - end.bounds.width;\n\t\n\t      this.neume.addVisualizer(start);\n\t      this.neume.addVisualizer(end);\n\t\n\t      this.lastNote = end;\n\t      this.lineIsHanging = false;\n\t\n\t      return this;\n\t    }\n\t  }]);\n\t\n\t  return NeumeBuilder;\n\t}();\n\t\n\t/*\n\t * Neumes base class\n\t */\n\t\n\t\n\tvar Neume = exports.Neume = function (_ChantNotationElement) {\n\t  _inherits(Neume, _ChantNotationElement);\n\t\n\t  function Neume() {\n\t    var notes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\t\n\t    _classCallCheck(this, Neume);\n\t\n\t    var _this = _possibleConstructorReturn(this, (Neume.__proto__ || Object.getPrototypeOf(Neume)).call(this));\n\t\n\t    _this.isNeume = true; // poor man's reflection\n\t    _this.notes = notes;\n\t\n\t    for (var i = 0; i < notes.length; i++) {\n\t      notes[i].neume = _this;\n\t    }return _this;\n\t  }\n\t\n\t  _createClass(Neume, [{\n\t    key: \"addNote\",\n\t    value: function addNote(note) {\n\t      note.neume = this;\n\t      this.notes.push(note);\n\t    }\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(Neume.prototype.__proto__ || Object.getPrototypeOf(Neume.prototype), \"performLayout\", this).call(this, ctxt);\n\t    }\n\t  }, {\n\t    key: \"finishLayout\",\n\t    value: function finishLayout(ctxt) {\n\t      this.ledgerLines = this.requiresLedgerLine(ctxt);\n\t\n\t      // allow subclasses an opportunity to position their own markings...\n\t      this.positionMarkings();\n\t\n\t      // layout the markings of the notes\n\t      for (var i = 0; i < this.notes.length; i++) {\n\t        var note = this.notes[i];\n\t        var j;\n\t\n\t        for (j = 0; j < note.episemata.length; j++) {\n\t          note.episemata[j].performLayout(ctxt);\n\t          this.addVisualizer(note.episemata[j]);\n\t        }\n\t\n\t        for (j = 0; j < note.morae.length; j++) {\n\t          note.morae[j].performLayout(ctxt);\n\t          this.addVisualizer(note.morae[j]);\n\t        }\n\t\n\t        // if the note has an ictus, then add it here\n\t        if (note.ictus) {\n\t          note.ictus.performLayout(ctxt);\n\t          this.addVisualizer(note.ictus);\n\t        }\n\t\n\t        if (note.accent) {\n\t          note.accent.performLayout(ctxt);\n\t          this.addVisualizer(note.accent);\n\t        }\n\t\n\t        if (note.choralSign) {\n\t          note.choralSign.performLayout(ctxt);\n\t          this.addVisualizer(note.choralSign);\n\t        }\n\t\n\t        // braces are handled by the chant line, so we don't mess with them here\n\t        // this is because brace size depends on chant line logic (neume spacing,\n\t        // justification, etc.) so they are considered chant line level\n\t        // markings rather than note level markings\n\t      }\n\t\n\t      this.origin.x = this.notes[0].origin.x;\n\t      this.origin.y = this.notes[0].origin.y;\n\t\n\t      _get(Neume.prototype.__proto__ || Object.getPrototypeOf(Neume.prototype), \"finishLayout\", this).call(this, ctxt);\n\t    }\n\t  }, {\n\t    key: \"requiresLedgerLine\",\n\t    value: function requiresLedgerLine(ctxt) {\n\t      var firstAbove = false,\n\t          needsAbove = false,\n\t          firstBelow = false,\n\t          needsBelow = false,\n\t\n\t      // isPorrectus = false,\n\t      result = [],\n\t          ledgerLinePositionAbove = ctxt.staffLineCount * 2 + 1;\n\t\n\t      if (!this.notes) return result;\n\t\n\t      for (var i = 0; i < this.notes.length; ++i) {\n\t        var note = this.notes[i];\n\t        var staffPosition = note.staffPosition;\n\t        if (staffPosition >= ledgerLinePositionAbove - 1) {\n\t          needsAbove = needsAbove || staffPosition >= ledgerLinePositionAbove;\n\t          if (firstAbove === false) firstAbove = Math.max(0, i - 1);\n\t          if (staffPosition >= ledgerLinePositionAbove) continue;\n\t        } else if (staffPosition <= 0) {\n\t          needsBelow = needsBelow || staffPosition <= -1;\n\t          if (firstBelow === false) firstBelow = Math.max(0, i - 1);\n\t          if (staffPosition <= -1) continue;\n\t        }\n\t        if (needsAbove || needsBelow) {\n\t          var endI = i; // Math.abs(staffPosition) >= 4? i : i - 1;\n\t          result.push({\n\t            element: this.notes[firstAbove || firstBelow || 0],\n\t            endElem: this.notes[endI],\n\t            staffPosition: needsAbove ? ledgerLinePositionAbove : -1\n\t          });\n\t          firstAbove = firstBelow = needsAbove = needsBelow = false;\n\t        }\n\t        // isPorrectus = /^Porrectus\\d$/.test(note.glyphVisualizer.glyphCode);\n\t      }\n\t      if (needsAbove || needsBelow) {\n\t        result.push({\n\t          element: this.notes[firstAbove || firstBelow || 0],\n\t          endElem: this.notes[this.notes.length - 1],\n\t          staffPosition: needsAbove ? ledgerLinePositionAbove : -1\n\t        });\n\t      }\n\t      return result;\n\t    }\n\t  }, {\n\t    key: \"resetDependencies\",\n\t    value: function resetDependencies() {}\n\t  }, {\n\t    key: \"build\",\n\t    value: function build(ctxt) {\n\t      return new NeumeBuilder(ctxt, this);\n\t    }\n\t  }, {\n\t    key: \"positionEpisemata\",\n\t    value: function positionEpisemata(note, position) {\n\t      var i;\n\t      for (i = 0; i < note.episemata.length; i++) {\n\t        if (note.episemata[i].positionHint === _ExsurgeDrawing.MarkingPositionHint.Default) note.episemata[i].positionHint = position;\n\t      }if (note.choralSign) note.choralSign.positionHint = position;\n\t      return note.episemata.length;\n\t    }\n\t  }, {\n\t    key: \"positionEpisemataAbove\",\n\t    value: function positionEpisemataAbove(note) {\n\t      return this.positionEpisemata(note, _ExsurgeDrawing.MarkingPositionHint.Above);\n\t    }\n\t  }, {\n\t    key: \"positionEpisemataBelow\",\n\t    value: function positionEpisemataBelow(note) {\n\t      return this.positionEpisemata(note, _ExsurgeDrawing.MarkingPositionHint.Below);\n\t    }\n\t  }, {\n\t    key: \"positionPodatusEpisemata\",\n\t    value: function positionPodatusEpisemata(bottomNote, topNote) {\n\t      // 1. episema on lower note by default be below, upper note above\n\t      this.positionEpisemataBelow(bottomNote);\n\t      this.positionEpisemataAbove(topNote);\n\t      if (topNote.ictus) {\n\t        topNote.ictus.positionHint = _ExsurgeDrawing.MarkingPositionHint.Above;\n\t      }\n\t    }\n\t  }, {\n\t    key: \"positionInclinataMorae\",\n\t    value: function positionInclinataMorae(notes) {\n\t      notes = notes.slice(-2);\n\t      if (notes.length < 2 || notes[1].staffPosition > notes[0].staffPosition) return;\n\t      var bottomNote = notes[1],\n\t          topNote = notes[0],\n\t          mark;\n\t\n\t      // The mora on the second (lower) note should be below the punctum,\n\t      // if the punctum is on a line and the previous punctum is in the space above.\n\t      if (Math.abs(bottomNote.staffPosition % 2) === 1 && topNote.staffPosition - bottomNote.staffPosition === 1 && bottomNote.morae.length > 0) {\n\t        mark = bottomNote.morae.slice(-1)[0];\n\t        if (mark.positionHint === _ExsurgeDrawing.MarkingPositionHint.Default) mark.positionHint = _ExsurgeDrawing.MarkingPositionHint.Below;\n\t      }\n\t    }\n\t  }, {\n\t    key: \"positionPodatusMorae\",\n\t    value: function positionPodatusMorae(bottomNote, topNote) {\n\t      var mark;\n\t\n\t      // The mora on the first (lower) note should be below it,\n\t      // if it is on a line.\n\t      if (Math.abs(bottomNote.staffPosition % 2) === 1) {\n\t        if (bottomNote.morae.length === 1) {\n\t          mark = bottomNote.morae[0];\n\t        } else if (topNote.morae.length > 1) {\n\t          mark = topNote.morae[0];\n\t        }\n\t        if (mark && mark.positionHint === _ExsurgeDrawing.MarkingPositionHint.Default) mark.positionHint = _ExsurgeDrawing.MarkingPositionHint.Below;\n\t      }\n\t\n\t      // if there is a mora on the first note but not on the second, and the neume\n\t      // continues with a punctum higher than the second note, we need to adjust\n\t      // the space after the neume so that it follows immediately with no gap\n\t      if (bottomNote.morae.length > 0 && topNote.morae.length === 0) {\n\t        bottomNote.morae[0].ignoreBounds = true;\n\t      }\n\t    }\n\t    // for any subclasses that begin with a podatus, they can call this from their own positionMarkings()\n\t\n\t  }, {\n\t    key: \"positionPodatusMarkings\",\n\t    value: function positionPodatusMarkings(bottomNote, topNote) {\n\t      this.positionPodatusEpisemata(bottomNote, topNote);\n\t      this.positionPodatusMorae(bottomNote, topNote);\n\t    }\n\t\n\t    // just like a clivis, but the first note of the three also works like the second note of the clivis:\n\t    // episema below, unless the middle note also has an episema\n\t\n\t  }, {\n\t    key: \"positionTorculusMarkings\",\n\t    value: function positionTorculusMarkings(firstNote, secondNote, thirdNote) {\n\t      var hasTopEpisema = this.positionClivisMarkings(secondNote, thirdNote);\n\t      hasTopEpisema = this.positionEpisemata(firstNote, hasTopEpisema ? _ExsurgeDrawing.MarkingPositionHint.Above : _ExsurgeDrawing.MarkingPositionHint.Below) && hasTopEpisema;\n\t      return hasTopEpisema;\n\t    }\n\t  }, {\n\t    key: \"positionClivisMorae\",\n\t    value: function positionClivisMorae(firstNote, secondNote) {\n\t      // 1. second note of a clivis that ends on a line and goes down one step has its mora below:\n\t      var morae = firstNote.morae.concat(secondNote.morae);\n\t      if (secondNote.morae.length && firstNote.staffPosition - secondNote.staffPosition === 1 && Math.abs(secondNote.staffPosition % 2) === 1) {\n\t        morae.slice(-1)[0].positionHint = _ExsurgeDrawing.MarkingPositionHint.Below;\n\t      }\n\t    }\n\t  }, {\n\t    key: \"positionClivisEpisemata\",\n\t    value: function positionClivisEpisemata(firstNote, secondNote) {\n\t      var hasTopEpisema = this.positionEpisemataAbove(firstNote);\n\t      this.positionEpisemata(secondNote, hasTopEpisema ? _ExsurgeDrawing.MarkingPositionHint.Above : _ExsurgeDrawing.MarkingPositionHint.Below);\n\t      return hasTopEpisema;\n\t    }\n\t  }, {\n\t    key: \"positionClivisMarkings\",\n\t    value: function positionClivisMarkings(firstNote, secondNote) {\n\t      this.positionClivisMorae(firstNote, secondNote);\n\t      return this.positionClivisEpisemata(firstNote, secondNote);\n\t    }\n\t  }, {\n\t    key: \"positionPorrectusMarkings\",\n\t    value: function positionPorrectusMarkings(firstNote, secondNote, thirdNote) {\n\t      // episemata on first and second note work like a clivis,\n\t      // the second note should have its episema below, unless the first note also has an episema.\n\t      this.positionClivisEpisemata(firstNote, secondNote);\n\t      this.positionPodatusMarkings(secondNote, thirdNote);\n\t    }\n\t  }, {\n\t    key: \"positionPorrectusFlexusMarkings\",\n\t    value: function positionPorrectusFlexusMarkings(first, second, third, fourth) {\n\t      var hasTopEpisema = this.positionEpisemataAbove(first);\n\t      hasTopEpisema = this.positionClivisMarkings(third, fourth) || hasTopEpisema;\n\t      this.positionEpisemata(second, hasTopEpisema ? _ExsurgeDrawing.MarkingPositionHint.Above : _ExsurgeDrawing.MarkingPositionHint.Below);\n\t    }\n\t\n\t    // subclasses can override this in order to correctly place markings in a neume specific way\n\t\n\t  }, {\n\t    key: \"positionMarkings\",\n\t    value: function positionMarkings() {}\n\t  }]);\n\t\n\t  return Neume;\n\t}(_ExsurgeDrawing.ChantNotationElement);\n\t\n\t/*\n\t * Apostropha\n\t */\n\t\n\t\n\tvar Apostropha = exports.Apostropha = function (_Neume) {\n\t  _inherits(Apostropha, _Neume);\n\t\n\t  function Apostropha() {\n\t    _classCallCheck(this, Apostropha);\n\t\n\t    return _possibleConstructorReturn(this, (Apostropha.__proto__ || Object.getPrototypeOf(Apostropha)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(Apostropha, [{\n\t    key: \"positionMarkings\",\n\t    value: function positionMarkings() {\n\t      var positionHint = _ExsurgeDrawing.MarkingPositionHint.Above;\n\t\n\t      // logic here is this: if first episema is default position, place it above.\n\t      // then place the second one (if there is one) opposite of the first.\n\t      for (var i = 0; i < this.notes[0].episemata.length; i++) {\n\t        if (this.notes[0].episemata[i].positionHint === _ExsurgeDrawing.MarkingPositionHint.Default) this.notes[0].episemata[i].positionHint = positionHint;else positionHint = this.notes[0].episemata[i].positionHint;\n\t\n\t        // now place the next one in the opposite position\n\t        positionHint = positionHint === _ExsurgeDrawing.MarkingPositionHint.Above ? _ExsurgeDrawing.MarkingPositionHint.Below : _ExsurgeDrawing.MarkingPositionHint.Above;\n\t      }\n\t    }\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(Apostropha.prototype.__proto__ || Object.getPrototypeOf(Apostropha.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      this.build(ctxt).noteAt(this.notes[0], Apostropha.getNoteGlyphCode(this.notes[0]));\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }], [{\n\t    key: \"getNoteGlyphCode\",\n\t    value: function getNoteGlyphCode(note) {\n\t      if (note.shape === _ExsurgeChant.NoteShape.Stropha) return _ExsurgeDrawing.GlyphCode.Stropha;\n\t\n\t      if (note.liquescent & _ExsurgeChant.LiquescentType.Ascending) return _ExsurgeDrawing.GlyphCode.PunctumQuadratumAscLiquescent;else if (note.liquescent & _ExsurgeChant.LiquescentType.Descending) return _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent;\n\t\n\t      if (note.shapeModifiers & _ExsurgeChant.NoteShapeModifiers.Cavum) return _ExsurgeDrawing.GlyphCode.PunctumCavum;\n\t\n\t      return _ExsurgeDrawing.GlyphCode.PunctumQuadratum;\n\t    }\n\t  }]);\n\t\n\t  return Apostropha;\n\t}(Neume);\n\t\n\t/*\n\t * Bivirga\n\t *\n\t * For simplicity in implementation, Bivirga's have two notes in the object\n\t * structure. These technically must be the same pitch though.\n\t */\n\t\n\t\n\tvar Bivirga = exports.Bivirga = function (_Neume2) {\n\t  _inherits(Bivirga, _Neume2);\n\t\n\t  function Bivirga() {\n\t    _classCallCheck(this, Bivirga);\n\t\n\t    return _possibleConstructorReturn(this, (Bivirga.__proto__ || Object.getPrototypeOf(Bivirga)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(Bivirga, [{\n\t    key: \"positionMarkings\",\n\t    value: function positionMarkings() {\n\t      this.positionEpisemataAbove(this.notes[0]);\n\t      this.positionEpisemataAbove(this.notes[1]);\n\t    }\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(Bivirga.prototype.__proto__ || Object.getPrototypeOf(Bivirga.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      this.build(ctxt).virgaAt(this.notes[0]).advanceBy(ctxt.intraNeumeSpacing).virgaAt(this.notes[1]);\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return Bivirga;\n\t}(Neume);\n\t\n\t/*\n\t * Trivirga\n\t *\n\t * For simplicity in implementation, Trivirga's have three notes in the object\n\t * structure. These technically must be the same pitch though.\n\t */\n\t\n\t\n\tvar Trivirga = exports.Trivirga = function (_Neume3) {\n\t  _inherits(Trivirga, _Neume3);\n\t\n\t  function Trivirga() {\n\t    _classCallCheck(this, Trivirga);\n\t\n\t    return _possibleConstructorReturn(this, (Trivirga.__proto__ || Object.getPrototypeOf(Trivirga)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(Trivirga, [{\n\t    key: \"positionMarkings\",\n\t    value: function positionMarkings() {\n\t      this.positionEpisemataAbove(this.notes[0]);\n\t      this.positionEpisemataAbove(this.notes[1]);\n\t      this.positionEpisemataAbove(this.notes[2]);\n\t    }\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(Trivirga.prototype.__proto__ || Object.getPrototypeOf(Trivirga.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      this.build(ctxt).virgaAt(this.notes[0]).advanceBy(ctxt.intraNeumeSpacing).virgaAt(this.notes[1]).advanceBy(ctxt.intraNeumeSpacing).virgaAt(this.notes[2]);\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return Trivirga;\n\t}(Neume);\n\t\n\t/*\n\t * Climacus\n\t */\n\t\n\t\n\tvar Climacus = exports.Climacus = function (_Neume4) {\n\t  _inherits(Climacus, _Neume4);\n\t\n\t  function Climacus() {\n\t    _classCallCheck(this, Climacus);\n\t\n\t    return _possibleConstructorReturn(this, (Climacus.__proto__ || Object.getPrototypeOf(Climacus)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(Climacus, [{\n\t    key: \"positionMarkings\",\n\t    value: function positionMarkings() {\n\t      for (var i = 0; i < this.notes.length; i++) {\n\t        this.positionEpisemataAbove(this.notes[i]);\n\t      }\n\t      this.positionInclinataMorae(this.notes);\n\t    }\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(Climacus.prototype.__proto__ || Object.getPrototypeOf(Climacus.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      this.build(ctxt).virgaAt(this.notes[0]).advanceBy(ctxt.intraNeumeSpacing).withInclinata(this.notes.slice(1));\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return Climacus;\n\t}(Neume);\n\t\n\t/*\n\t * Clivis\n\t */\n\t\n\t\n\tvar Clivis = exports.Clivis = function (_Neume5) {\n\t  _inherits(Clivis, _Neume5);\n\t\n\t  function Clivis() {\n\t    _classCallCheck(this, Clivis);\n\t\n\t    return _possibleConstructorReturn(this, (Clivis.__proto__ || Object.getPrototypeOf(Clivis)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(Clivis, [{\n\t    key: \"positionMarkings\",\n\t    value: function positionMarkings() {\n\t      this.positionClivisMarkings(this.notes[0], this.notes[1]);\n\t    }\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(Clivis.prototype.__proto__ || Object.getPrototypeOf(Clivis.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      var upper = this.notes[0];\n\t      var lower = this.notes[1];\n\t\n\t      this.build(ctxt).withClivis(upper, lower);\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return Clivis;\n\t}(Neume);\n\t\n\t/*\n\t * Ancus\n\t */\n\t\n\t\n\tvar Ancus = exports.Ancus = function (_Neume6) {\n\t  _inherits(Ancus, _Neume6);\n\t\n\t  function Ancus() {\n\t    _classCallCheck(this, Ancus);\n\t\n\t    return _possibleConstructorReturn(this, (Ancus.__proto__ || Object.getPrototypeOf(Ancus)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(Ancus, [{\n\t    key: \"positionMarkings\",\n\t    value: function positionMarkings() {\n\t      this.positionClivisMarkings(this.notes[0], this.notes[2]);\n\t      this.positionClivisMarkings(this.notes[1], this.notes[2]);\n\t    }\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(Ancus.prototype.__proto__ || Object.getPrototypeOf(Ancus.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      var upper = this.notes[0];\n\t      var middle = this.notes[1];\n\t      var lower = this.notes[2];\n\t\n\t      var builder = this.build(ctxt);\n\t      builder.withClivisUpper(upper, middle);\n\t      var middleGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratum;\n\t      if (lower.liquescent & _ExsurgeChant.LiquescentType.Small) {\n\t        middleGlyph = _ExsurgeDrawing.GlyphCode.BeginningDesLiquescent;\n\t      }\n\t      if (upper.staffPosition - middle.staffPosition > 1) {\n\t        builder.withClivisUpper(middle, upper, middleGlyph);\n\t      } else {\n\t        builder.withClivisUpper(middle, null, middleGlyph);\n\t      }\n\t      builder.withClivisLower(lower);\n\t      builder.lastNote = null;\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return Ancus;\n\t}(Neume);\n\t\n\t/*\n\t * Distropha\n\t *\n\t * For simplicity in implementation, Distropha's have two notes in the object\n\t * structure. These technically must be the same pitch though (like Bivirga).\n\t */\n\t\n\t\n\tvar Distropha = exports.Distropha = function (_Neume7) {\n\t  _inherits(Distropha, _Neume7);\n\t\n\t  function Distropha() {\n\t    _classCallCheck(this, Distropha);\n\t\n\t    return _possibleConstructorReturn(this, (Distropha.__proto__ || Object.getPrototypeOf(Distropha)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(Distropha, [{\n\t    key: \"positionMarkings\",\n\t    value: function positionMarkings() {\n\t      this.positionEpisemataAbove(this.notes[0]);\n\t      this.positionEpisemataAbove(this.notes[1]);\n\t    }\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(Distropha.prototype.__proto__ || Object.getPrototypeOf(Distropha.prototype), \"performLayout\", this).call(this, ctxt);\n\t      var glyphCodes = this.notes.map(function (note) {\n\t        return Apostropha.getNoteGlyphCode(note);\n\t      });\n\t      var glyphAdvance = ctxt.intraNeumeSpacing;\n\t      glyphCodes.slice(0, 2).forEach(function (glyphCode) {\n\t        if (glyphCode === _ExsurgeDrawing.GlyphCode.Stropha) glyphAdvance -= ctxt.intraNeumeSpacing / 4;\n\t      });\n\t\n\t      this.build(ctxt).noteAt(this.notes[0], glyphCodes[0]).advanceBy(glyphAdvance).noteAt(this.notes[1], glyphCodes[1]);\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return Distropha;\n\t}(Neume);\n\t\n\t/*\n\t * Oriscus\n\t */\n\t\n\t\n\tvar Oriscus = exports.Oriscus = function (_Neume8) {\n\t  _inherits(Oriscus, _Neume8);\n\t\n\t  function Oriscus() {\n\t    _classCallCheck(this, Oriscus);\n\t\n\t    return _possibleConstructorReturn(this, (Oriscus.__proto__ || Object.getPrototypeOf(Oriscus)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(Oriscus, [{\n\t    key: \"positionMarkings\",\n\t    value: function positionMarkings() {\n\t      this.positionEpisemataAbove(this.notes[0]);\n\t    }\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(Oriscus.prototype.__proto__ || Object.getPrototypeOf(Oriscus.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      // determine the glyph to use\n\t      var note = this.notes[0];\n\t      var glyph;\n\t\n\t      if (note.liquescent !== _ExsurgeChant.LiquescentType.None) {\n\t        glyph = _ExsurgeDrawing.GlyphCode.OriscusLiquescent;\n\t      } else {\n\t        if (note.shapeModifiers & _ExsurgeChant.NoteShapeModifiers.Ascending) glyph = _ExsurgeDrawing.GlyphCode.OriscusAsc;else if (note.shapeModifiers & _ExsurgeChant.NoteShapeModifiers.Descending) glyph = _ExsurgeDrawing.GlyphCode.OriscusDes;else {\n\t          // by default we take the descending form, unless we can figure out by a lookahead here\n\t          glyph = _ExsurgeDrawing.GlyphCode.OriscusDes;\n\t\n\t          // try to find a neume following this one\n\t          var neume = ctxt.findNextNeume();\n\t\n\t          if (neume) {\n\t            var nextNoteStaffPosition = ctxt.activeClef.pitchToStaffPosition(neume.notes[0].pitch);\n\t\n\t            if (nextNoteStaffPosition > note.staffPosition) glyph = _ExsurgeDrawing.GlyphCode.OriscusAsc;\n\t          }\n\t        }\n\t      }\n\t\n\t      this.build(ctxt).noteAt(note, glyph);\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }, {\n\t    key: \"resetDependencies\",\n\t    value: function resetDependencies() {\n\t      // a single oriscus tries to automatically use the right direction\n\t      // based on the following neumes. if we don't have a manually designated\n\t      // direction, then we reset our layout so that we can try to guess it\n\t      // at next layout phase.\n\t      if (this.notes[0].shapeModifiers & _ExsurgeChant.NoteShapeModifiers.Ascending || this.notes[0].shapeModifiers & _ExsurgeChant.NoteShapeModifiers.Descending) return;\n\t\n\t      this.needsLayout = true;\n\t    }\n\t  }]);\n\t\n\t  return Oriscus;\n\t}(Neume);\n\t\n\t/*\n\t * PesQuassus\n\t */\n\t\n\t\n\tvar PesQuassus = exports.PesQuassus = function (_Neume9) {\n\t  _inherits(PesQuassus, _Neume9);\n\t\n\t  function PesQuassus() {\n\t    _classCallCheck(this, PesQuassus);\n\t\n\t    return _possibleConstructorReturn(this, (PesQuassus.__proto__ || Object.getPrototypeOf(PesQuassus)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(PesQuassus, [{\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(PesQuassus.prototype.__proto__ || Object.getPrototypeOf(PesQuassus.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      var lower = this.notes[0];\n\t      var upper = this.notes[1];\n\t\n\t      var lowerGlyph;\n\t\n\t      var lowerStaffPos = lower.staffPosition;\n\t      var upperStaffPos = upper.staffPosition;\n\t\n\t      if (lower.shape === _ExsurgeChant.NoteShape.Oriscus) lowerGlyph = _ExsurgeDrawing.GlyphCode.OriscusAsc;else lowerGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratum;\n\t\n\t      var builder = this.build(ctxt).noteAt(lower, lowerGlyph);\n\t\n\t      if (upperStaffPos - lowerStaffPos === 1)\n\t        // use a virga glyph in this case\n\t        builder.virgaAt(upper);else if (upper.liquescent === _ExsurgeChant.LiquescentType.LargeDescending) builder.noteAt(upper, _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent).withLineEndingAt(lower);else builder.noteAt(upper, _ExsurgeDrawing.GlyphCode.PunctumQuadratum).withLineEndingAt(lower);\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return PesQuassus;\n\t}(Neume);\n\t\n\t/*\n\t * PesSubpunctis\n\t */\n\t\n\t\n\tvar PesSubpunctis = exports.PesSubpunctis = function (_Neume10) {\n\t  _inherits(PesSubpunctis, _Neume10);\n\t\n\t  function PesSubpunctis() {\n\t    _classCallCheck(this, PesSubpunctis);\n\t\n\t    return _possibleConstructorReturn(this, (PesSubpunctis.__proto__ || Object.getPrototypeOf(PesSubpunctis)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(PesSubpunctis, [{\n\t    key: \"positionMarkings\",\n\t    value: function positionMarkings() {\n\t      this.positionPodatusEpisemata(this.notes[0], this.notes[1]);\n\t      for (var i = 2; i < this.notes.length; ++i) {\n\t        this.positionEpisemataAbove(this.notes[i]);\n\t      }\n\t      this.positionInclinataMorae(this.notes.slice(1));\n\t    }\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(PesSubpunctis.prototype.__proto__ || Object.getPrototypeOf(PesSubpunctis.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      // podatus followed by inclinata\n\t      this.build(ctxt).withPodatus(this.notes[0], this.notes[1]).advanceBy(ctxt.intraNeumeSpacing * 0.68).withInclinata(this.notes.slice(2));\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return PesSubpunctis;\n\t}(Neume);\n\t\n\t/*\n\t * Podatus\n\t *\n\t * This podatus class handles a few neume types actually, depending on the note\n\t * data: Podatus (including various liquescent types on the upper note),\n\t * Podatus initio debilis, and Quilisma-Pes\n\t */\n\t\n\t\n\tvar Podatus = exports.Podatus = function (_Neume11) {\n\t  _inherits(Podatus, _Neume11);\n\t\n\t  function Podatus() {\n\t    _classCallCheck(this, Podatus);\n\t\n\t    return _possibleConstructorReturn(this, (Podatus.__proto__ || Object.getPrototypeOf(Podatus)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(Podatus, [{\n\t    key: \"positionMarkings\",\n\t    value: function positionMarkings() {\n\t      this.positionPodatusMarkings(this.notes[0], this.notes[1]);\n\t    }\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(Podatus.prototype.__proto__ || Object.getPrototypeOf(Podatus.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      this.build(ctxt).withPodatus(this.notes[0], this.notes[1]);\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return Podatus;\n\t}(Neume);\n\t\n\t/*\n\t * Porrectus\n\t */\n\t\n\t\n\tvar Porrectus = exports.Porrectus = function (_Neume12) {\n\t  _inherits(Porrectus, _Neume12);\n\t\n\t  function Porrectus() {\n\t    _classCallCheck(this, Porrectus);\n\t\n\t    return _possibleConstructorReturn(this, (Porrectus.__proto__ || Object.getPrototypeOf(Porrectus)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(Porrectus, [{\n\t    key: \"positionMarkings\",\n\t    value: function positionMarkings() {\n\t      this.positionPorrectusMarkings(this.notes[0], this.notes[1], this.notes[2]);\n\t    }\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(Porrectus.prototype.__proto__ || Object.getPrototypeOf(Porrectus.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      var first = this.notes[0];\n\t      var second = this.notes[1];\n\t      var third = this.notes[2];\n\t\n\t      var thirdGlyph;\n\t\n\t      if (third.liquescent & _ExsurgeChant.LiquescentType.Small) thirdGlyph = _ExsurgeDrawing.GlyphCode.TerminatingAscLiquescent;else if (third.liquescent & _ExsurgeChant.LiquescentType.Descending) thirdGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent;else thirdGlyph = _ExsurgeDrawing.GlyphCode.PodatusUpper;\n\t\n\t      this.build(ctxt).lineFrom(second).withPorrectusSwash(first, second).noteAt(third, thirdGlyph);\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return Porrectus;\n\t}(Neume);\n\t\n\t/*\n\t * PorrectusFlexus\n\t */\n\t\n\t\n\tvar PorrectusFlexus = exports.PorrectusFlexus = function (_Neume13) {\n\t  _inherits(PorrectusFlexus, _Neume13);\n\t\n\t  function PorrectusFlexus() {\n\t    _classCallCheck(this, PorrectusFlexus);\n\t\n\t    return _possibleConstructorReturn(this, (PorrectusFlexus.__proto__ || Object.getPrototypeOf(PorrectusFlexus)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(PorrectusFlexus, [{\n\t    key: \"positionMarkings\",\n\t    value: function positionMarkings() {\n\t      this.positionPorrectusFlexusMarkings(this.notes[0], this.notes[1], this.notes[2], this.notes[3]);\n\t    }\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(PorrectusFlexus.prototype.__proto__ || Object.getPrototypeOf(PorrectusFlexus.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      var first = this.notes[0];\n\t      var second = this.notes[1];\n\t      var third = this.notes[2];\n\t      var fourth = this.notes[3];\n\t\n\t      var thirdGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratum,\n\t          fourthGlyph;\n\t\n\t      if (fourth.liquescent & _ExsurgeChant.LiquescentType.Small) {\n\t        thirdGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent;\n\t        fourthGlyph = _ExsurgeDrawing.GlyphCode.TerminatingDesLiquescent;\n\t      } else if (fourth.liquescent & _ExsurgeChant.LiquescentType.Ascending) fourthGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumAscLiquescent;else if (fourth.liquescent & _ExsurgeChant.LiquescentType.Descending) fourthGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent;else fourthGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratum;\n\t\n\t      this.build(ctxt).lineFrom(second).withPorrectusSwash(first, second).noteAt(third, thirdGlyph).noteAt(fourth, fourthGlyph);\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return PorrectusFlexus;\n\t}(Neume);\n\t\n\t// this is some type of pseudo nume right? there is no such thing as a neume\n\t// of puncta inclinata, but this will be part of other composite neumes.\n\t\n\t\n\tvar PunctaInclinata = exports.PunctaInclinata = function (_Neume14) {\n\t  _inherits(PunctaInclinata, _Neume14);\n\t\n\t  function PunctaInclinata() {\n\t    _classCallCheck(this, PunctaInclinata);\n\t\n\t    return _possibleConstructorReturn(this, (PunctaInclinata.__proto__ || Object.getPrototypeOf(PunctaInclinata)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(PunctaInclinata, [{\n\t    key: \"positionMarkings\",\n\t    value: function positionMarkings() {\n\t      this.positionInclinataMorae(this.notes);\n\t    }\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(PunctaInclinata.prototype.__proto__ || Object.getPrototypeOf(PunctaInclinata.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      this.build(ctxt).withInclinata(this.notes);\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return PunctaInclinata;\n\t}(Neume);\n\t\n\t/*\n\t * Punctum\n\t */\n\t\n\t\n\tvar Punctum = exports.Punctum = function (_Neume15) {\n\t  _inherits(Punctum, _Neume15);\n\t\n\t  function Punctum() {\n\t    _classCallCheck(this, Punctum);\n\t\n\t    return _possibleConstructorReturn(this, (Punctum.__proto__ || Object.getPrototypeOf(Punctum)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(Punctum, [{\n\t    key: \"positionMarkings\",\n\t    value: function positionMarkings() {\n\t      this.positionEpisemataAbove(this.notes[0]);\n\t    }\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(Punctum.prototype.__proto__ || Object.getPrototypeOf(Punctum.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      var note = this.notes[0];\n\t      var glyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratum;\n\t\n\t      // determine the glyph to use\n\t      if (note.liquescent !== _ExsurgeChant.LiquescentType.None) {\n\t        if (note.shape === _ExsurgeChant.NoteShape.Inclinatum) glyph = _ExsurgeDrawing.GlyphCode.PunctumInclinatumLiquescent;else if (note.shape === _ExsurgeChant.NoteShape.Oriscus) glyph = _ExsurgeDrawing.GlyphCode.OriscusLiquescent;else if (note.liquescent & _ExsurgeChant.LiquescentType.Ascending) glyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumAscLiquescent;else if (note.liquescent & _ExsurgeChant.LiquescentType.Descending) glyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent;else glyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumLiquescent;\n\t      } else {\n\t        if (note.shapeModifiers & _ExsurgeChant.NoteShapeModifiers.Cavum) glyph = _ExsurgeDrawing.GlyphCode.PunctumCavum;else if (note.shape === _ExsurgeChant.NoteShape.Inclinatum) glyph = _ExsurgeDrawing.GlyphCode.PunctumInclinatum;else if (note.shape === _ExsurgeChant.NoteShape.Quilisma) glyph = _ExsurgeDrawing.GlyphCode.Quilisma;else glyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratum;\n\t      }\n\t\n\t      this.build(ctxt).noteAt(note, glyph);\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return Punctum;\n\t}(Neume);\n\t\n\t/*\n\t * Salicus\n\t */\n\t\n\t\n\tvar Salicus = exports.Salicus = function (_Neume16) {\n\t  _inherits(Salicus, _Neume16);\n\t\n\t  function Salicus() {\n\t    _classCallCheck(this, Salicus);\n\t\n\t    return _possibleConstructorReturn(this, (Salicus.__proto__ || Object.getPrototypeOf(Salicus)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(Salicus, [{\n\t    key: \"positionMarkings\",\n\t    value: function positionMarkings() {\n\t      // by default place episema below\n\t      // fixme: is this correct?\n\t      for (var i = 0; i < this.notes.length; i++) {\n\t        this.positionEpisemataBelow(this.notes[i]);\n\t      }\n\t    }\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(Salicus.prototype.__proto__ || Object.getPrototypeOf(Salicus.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      var first = this.notes[0];\n\t      var second = this.notes[1];\n\t      var third = this.notes[2];\n\t\n\t      var builder = this.build(ctxt).noteAt(first, _ExsurgeDrawing.GlyphCode.PunctumQuadratum);\n\t\n\t      // if the next note doesn't require a stem connector, then add a tad bit\n\t      // of spacing here\n\t      if (!(second.shapeModifiers & _ExsurgeChant.NoteShapeModifiers.Stemmed)) builder.advanceBy(ctxt.intraNeumeSpacing);\n\t\n\t      // second note is always an oriscus, which may or may not be stemmed\n\t      // to the first\n\t      builder.noteAt(second, _ExsurgeDrawing.GlyphCode.OriscusAsc);\n\t\n\t      // third note can be a punctum quadratum or various liquescent forms\n\t      if (third.liquescent & _ExsurgeChant.LiquescentType.Small) builder.noteAt(third, _ExsurgeDrawing.GlyphCode.TerminatingAscLiquescent);else if (third.liquescent === _ExsurgeChant.LiquescentType.Ascending) builder.noteAt(third, _ExsurgeDrawing.GlyphCode.PunctumQuadratumAscLiquescent);else if (third.liquescent === _ExsurgeChant.LiquescentType.Descending) builder.noteAt(third, _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent);else builder.virgaAt(third);\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return Salicus;\n\t}(Neume);\n\t\n\t/*\n\t * Salicus Flexus\n\t */\n\t\n\t\n\tvar SalicusFlexus = exports.SalicusFlexus = function (_Neume17) {\n\t  _inherits(SalicusFlexus, _Neume17);\n\t\n\t  function SalicusFlexus() {\n\t    _classCallCheck(this, SalicusFlexus);\n\t\n\t    return _possibleConstructorReturn(this, (SalicusFlexus.__proto__ || Object.getPrototypeOf(SalicusFlexus)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(SalicusFlexus, [{\n\t    key: \"positionMarkings\",\n\t    value: function positionMarkings() {\n\t      var hasTopEpisema = this.positionTorculusMarkings(this.notes[1], this.notes[2], this.notes[3]);\n\t      this.positionEpisemata(this.notes[0], hasTopEpisema ? _ExsurgeDrawing.MarkingPositionHint.Above : _ExsurgeDrawing.MarkingPositionHint.Below);\n\t    }\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(SalicusFlexus.prototype.__proto__ || Object.getPrototypeOf(SalicusFlexus.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      var first = this.notes[0];\n\t      var second = this.notes[1];\n\t      var third = this.notes[2];\n\t      var fourth = this.notes[3];\n\t\n\t      var builder = this.build(ctxt).noteAt(first, _ExsurgeDrawing.GlyphCode.PunctumQuadratum);\n\t\n\t      // if the next note doesn't require a stem connector, then add a tad bit\n\t      // of spacing here\n\t      if (!(second.shapeModifiers & _ExsurgeChant.NoteShapeModifiers.Stemmed)) builder.advanceBy(ctxt.intraNeumeSpacing);\n\t\n\t      // second note is always an oriscus, which may or may not be stemmed\n\t      // to the first\n\t      builder.noteAt(second, _ExsurgeDrawing.GlyphCode.OriscusAsc);\n\t\n\t      // third note can be a punctum quadratum or various liquescent forms,\n\t      // ...based on note four though!\n\t      if (fourth.liquescent & _ExsurgeChant.LiquescentType.Small) builder.noteAt(third, _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent);else builder.noteAt(third, _ExsurgeDrawing.GlyphCode.PunctumQuadratum);\n\t\n\t      // finally, do the fourth note\n\t      if (fourth.liquescent & _ExsurgeChant.LiquescentType.Small) builder.noteAt(fourth, _ExsurgeDrawing.GlyphCode.TerminatingDesLiquescent);else if (fourth.liquescent & _ExsurgeChant.LiquescentType.Ascending) builder.noteAt(fourth, _ExsurgeDrawing.GlyphCode.PunctumQuadratumAscLiquescent);else if (fourth.liquescent & _ExsurgeChant.LiquescentType.Descending) builder.noteAt(fourth, _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent);else builder.noteAt(fourth, _ExsurgeDrawing.GlyphCode.PunctumQuadratum);\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return SalicusFlexus;\n\t}(Neume);\n\t\n\t/*\n\t * Scandicus\n\t */\n\t\n\t\n\tvar Scandicus = exports.Scandicus = function (_Neume18) {\n\t  _inherits(Scandicus, _Neume18);\n\t\n\t  function Scandicus() {\n\t    _classCallCheck(this, Scandicus);\n\t\n\t    return _possibleConstructorReturn(this, (Scandicus.__proto__ || Object.getPrototypeOf(Scandicus)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(Scandicus, [{\n\t    key: \"positionMarkings\",\n\t    value: function positionMarkings() {\n\t      if (this.notes[2].shape === _ExsurgeChant.NoteShape.Virga) {\n\t        this.positionPodatusMarkings(this.notes[0], this.notes[1]);\n\t        this.positionEpisemataAbove(this.notes[2]);\n\t      } else {\n\t        this.positionEpisemataBelow(this.notes[0]);\n\t        this.positionPodatusMarkings(this.notes[1], this.notes[2]);\n\t      }\n\t    }\n\t\n\t    // if the third note shape is a virga, then the scadicus is rendered\n\t    // as a podatus followed by a virga. Otherwise, it's rendered as a\n\t    // punctum followed by a podatus...\n\t\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(Scandicus.prototype.__proto__ || Object.getPrototypeOf(Scandicus.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      var first = this.notes[0];\n\t      var second = this.notes[1];\n\t      var third = this.notes[2];\n\t\n\t      if (third.shape === _ExsurgeChant.NoteShape.Virga) {\n\t        this.build(ctxt).withPodatus(first, second).virgaAt(third);\n\t      } else {\n\t        this.build(ctxt).noteAt(first, first.shape === _ExsurgeChant.NoteShape.Quilisma ? _ExsurgeDrawing.GlyphCode.Quilisma : _ExsurgeDrawing.GlyphCode.PunctumQuadratum).withPodatus(second, third);\n\t      }\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return Scandicus;\n\t}(Neume);\n\t\n\t/*\n\t * Scandicus Flexus\n\t */\n\t\n\t\n\tvar ScandicusFlexus = exports.ScandicusFlexus = function (_Neume19) {\n\t  _inherits(ScandicusFlexus, _Neume19);\n\t\n\t  function ScandicusFlexus() {\n\t    _classCallCheck(this, ScandicusFlexus);\n\t\n\t    return _possibleConstructorReturn(this, (ScandicusFlexus.__proto__ || Object.getPrototypeOf(ScandicusFlexus)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(ScandicusFlexus, [{\n\t    key: \"positionMarkings\",\n\t    value: function positionMarkings() {\n\t      if (this.notes[2].shape === _ExsurgeChant.NoteShape.Virga) {\n\t        this.positionPodatusMarkings(this.notes[0], this.notes[1]);\n\t        this.positionClivisMarkings(this.notes[2], this.notes[3]);\n\t      } else {\n\t        this.positionEpisemataBelow(this.notes[0]);\n\t        this.positionPodatusMarkings(this.notes[1], this.notes[2]);\n\t        this.positionEpisemataAbove(this.notes[3]);\n\t      }\n\t    }\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(ScandicusFlexus.prototype.__proto__ || Object.getPrototypeOf(ScandicusFlexus.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      var first = this.notes[0];\n\t      var second = this.notes[1];\n\t      var third = this.notes[2];\n\t      var fourth = this.notes[3];\n\t\n\t      if (third.shape === _ExsurgeChant.NoteShape.Virga) {\n\t        this.build(ctxt).withPodatus(first, second).advanceBy(ctxt.intraNeumeSpacing).withClivis(third, fourth);\n\t      } else {\n\t        var fourthGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratum;\n\t\n\t        if (fourth.liquescent & _ExsurgeChant.LiquescentType.Ascending) fourthGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumAscLiquescent;else if (fourth.liquescent & _ExsurgeChant.LiquescentType.Descending) fourthGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent;\n\t\n\t        this.build(ctxt).noteAt(first, _ExsurgeDrawing.GlyphCode.PunctumQuadratum).withPodatus(second, third).advanceBy(ctxt.intraNeumeSpacing).noteAt(fourth, fourthGlyph);\n\t      }\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return ScandicusFlexus;\n\t}(Neume);\n\t\n\t/*\n\t * Torculus\n\t */\n\t\n\t\n\tvar Torculus = exports.Torculus = function (_Neume20) {\n\t  _inherits(Torculus, _Neume20);\n\t\n\t  function Torculus() {\n\t    _classCallCheck(this, Torculus);\n\t\n\t    return _possibleConstructorReturn(this, (Torculus.__proto__ || Object.getPrototypeOf(Torculus)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(Torculus, [{\n\t    key: \"positionMarkings\",\n\t    value: function positionMarkings() {\n\t      this.positionTorculusMarkings(this.notes[0], this.notes[1], this.notes[2]);\n\t    }\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(Torculus.prototype.__proto__ || Object.getPrototypeOf(Torculus.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      var note1 = this.notes[0];\n\t      var note2 = this.notes[1];\n\t      var note3 = this.notes[2];\n\t\n\t      var glyph1, glyph3;\n\t\n\t      if (note1.liquescent === _ExsurgeChant.LiquescentType.InitioDebilis) glyph1 = _ExsurgeDrawing.GlyphCode.TerminatingDesLiquescent;else if (note1.shape === _ExsurgeChant.NoteShape.Quilisma) glyph1 = _ExsurgeDrawing.GlyphCode.Quilisma;else glyph1 = _ExsurgeDrawing.GlyphCode.PunctumQuadratum;\n\t\n\t      if (note3.liquescent & _ExsurgeChant.LiquescentType.Small) glyph3 = _ExsurgeDrawing.GlyphCode.TerminatingDesLiquescent;else if (note3.liquescent & _ExsurgeChant.LiquescentType.Ascending) glyph3 = _ExsurgeDrawing.GlyphCode.PunctumQuadratumAscLiquescent;else if (note3.liquescent & _ExsurgeChant.LiquescentType.Descending) glyph3 = _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent;else glyph3 = _ExsurgeDrawing.GlyphCode.PunctumQuadratum;\n\t\n\t      this.build(ctxt).noteAt(note1, glyph1).noteAt(note2, _ExsurgeDrawing.GlyphCode.PunctumQuadratum).noteAt(note3, glyph3);\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return Torculus;\n\t}(Neume);\n\t\n\t/*\n\t * TorculusResupinus\n\t */\n\t\n\t\n\tvar TorculusResupinus = exports.TorculusResupinus = function (_Neume21) {\n\t  _inherits(TorculusResupinus, _Neume21);\n\t\n\t  function TorculusResupinus() {\n\t    _classCallCheck(this, TorculusResupinus);\n\t\n\t    return _possibleConstructorReturn(this, (TorculusResupinus.__proto__ || Object.getPrototypeOf(TorculusResupinus)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(TorculusResupinus, [{\n\t    key: \"positionMarkings\",\n\t    value: function positionMarkings() {\n\t      this.positionPorrectusMarkings(this.notes[1], this.notes[2], this.notes[3]);\n\t      this.positionClivisEpisemata(this.notes[1], this.notes[0]);\n\t    }\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(TorculusResupinus.prototype.__proto__ || Object.getPrototypeOf(TorculusResupinus.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      var first = this.notes[0];\n\t      var second = this.notes[1];\n\t      var third = this.notes[2];\n\t      var fourth = this.notes[3];\n\t\n\t      var firstGlyph, fourthGlyph;\n\t\n\t      if (first.liquescent === _ExsurgeChant.LiquescentType.InitioDebilis) {\n\t        firstGlyph = _ExsurgeDrawing.GlyphCode.TerminatingDesLiquescent;\n\t      } else if (first.shape === _ExsurgeChant.NoteShape.Quilisma) firstGlyph = _ExsurgeDrawing.GlyphCode.Quilisma;else firstGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratum;\n\t\n\t      if (fourth.liquescent & _ExsurgeChant.LiquescentType.Small) fourthGlyph = _ExsurgeDrawing.GlyphCode.TerminatingAscLiquescent;else if (third.liquescent & _ExsurgeChant.LiquescentType.Descending) fourthGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent;else fourthGlyph = _ExsurgeDrawing.GlyphCode.PodatusUpper;\n\t\n\t      this.build(ctxt).noteAt(first, firstGlyph).withPorrectusSwash(second, third).noteAt(fourth, fourthGlyph);\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return TorculusResupinus;\n\t}(Neume);\n\t\n\t/*\n\t * TorculusResupinusFlexus\n\t */\n\t\n\t\n\tvar TorculusResupinusFlexus = exports.TorculusResupinusFlexus = function (_Neume22) {\n\t  _inherits(TorculusResupinusFlexus, _Neume22);\n\t\n\t  function TorculusResupinusFlexus() {\n\t    _classCallCheck(this, TorculusResupinusFlexus);\n\t\n\t    return _possibleConstructorReturn(this, (TorculusResupinusFlexus.__proto__ || Object.getPrototypeOf(TorculusResupinusFlexus)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(TorculusResupinusFlexus, [{\n\t    key: \"positionMarkings\",\n\t    value: function positionMarkings() {\n\t      this.positionPorrectusFlexusMarkings(this.notes[1], this.notes[2], this.notes[3], this.notes[4]);\n\t      this.positionClivisEpisemata(this.notes[1], this.notes[0]);\n\t    }\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(TorculusResupinusFlexus.prototype.__proto__ || Object.getPrototypeOf(TorculusResupinusFlexus.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      var first = this.notes[0];\n\t      var second = this.notes[1];\n\t      var third = this.notes[2];\n\t      var fourth = this.notes[3];\n\t      var fifth = this.notes[4];\n\t\n\t      var firstGlyph,\n\t          fourthGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratum,\n\t          fifthGlyph;\n\t\n\t      if (first.liquescent === _ExsurgeChant.LiquescentType.InitioDebilis) {\n\t        firstGlyph = _ExsurgeDrawing.GlyphCode.TerminatingDesLiquescent;\n\t      } else if (first.shape === _ExsurgeChant.NoteShape.Quilisma) firstGlyph = _ExsurgeDrawing.GlyphCode.Quilisma;else firstGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratum;\n\t\n\t      if (fifth.liquescent & _ExsurgeChant.LiquescentType.Small) {\n\t        fourthGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent;\n\t        fifthGlyph = _ExsurgeDrawing.GlyphCode.TerminatingDesLiquescent;\n\t      } else if (fifth.liquescent & _ExsurgeChant.LiquescentType.Ascending) fifthGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumAscLiquescent;else if (fifth.liquescent & _ExsurgeChant.LiquescentType.Descending) fifthGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent;else fifthGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratum;\n\t\n\t      this.build(ctxt).noteAt(first, firstGlyph).withPorrectusSwash(second, third).noteAt(fourth, fourthGlyph).noteAt(fifth, fifthGlyph);\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return TorculusResupinusFlexus;\n\t}(Neume);\n\t\n\t/*\n\t * Tristropha\n\t *\n\t * For simplicity in implementation, Tristropha's have three notes in the object\n\t * structure. These technically must be the same pitch though (like the\n\t * Distropha and Bivirga).\n\t */\n\t\n\t\n\tvar Tristropha = exports.Tristropha = function (_Neume23) {\n\t  _inherits(Tristropha, _Neume23);\n\t\n\t  function Tristropha() {\n\t    _classCallCheck(this, Tristropha);\n\t\n\t    return _possibleConstructorReturn(this, (Tristropha.__proto__ || Object.getPrototypeOf(Tristropha)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(Tristropha, [{\n\t    key: \"positionMarkings\",\n\t    value: function positionMarkings() {\n\t      this.positionEpisemataAbove(this.notes[0]);\n\t      this.positionEpisemataAbove(this.notes[1]);\n\t      this.positionEpisemataAbove(this.notes[2]);\n\t    }\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(Tristropha.prototype.__proto__ || Object.getPrototypeOf(Tristropha.prototype), \"performLayout\", this).call(this, ctxt);\n\t      var glyphCodes = this.notes.map(function (note) {\n\t        return Apostropha.getNoteGlyphCode(note);\n\t      });\n\t      var glyphAdvance = glyphCodes[0] === _ExsurgeDrawing.GlyphCode.Stropha ? ctxt.intraNeumeSpacing / 2 : ctxt.intraNeumeSpacing;\n\t\n\t      this.build(ctxt).noteAt(this.notes[0], glyphCodes[0]).advanceBy(glyphAdvance).noteAt(this.notes[1], glyphCodes[1]).advanceBy(glyphAdvance).noteAt(this.notes[2], glyphCodes[2]);\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return Tristropha;\n\t}(Neume);\n\t\n\t/*\n\t * Virga\n\t */\n\t\n\t\n\tvar Virga = exports.Virga = function (_Neume24) {\n\t  _inherits(Virga, _Neume24);\n\t\n\t  function Virga() {\n\t    _classCallCheck(this, Virga);\n\t\n\t    return _possibleConstructorReturn(this, (Virga.__proto__ || Object.getPrototypeOf(Virga)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(Virga, [{\n\t    key: \"positionMarkings\",\n\t    value: function positionMarkings() {\n\t      this.positionEpisemataAbove(this.notes[0]);\n\t    }\n\t  }, {\n\t    key: \"performLayout\",\n\t    value: function performLayout(ctxt) {\n\t      _get(Virga.prototype.__proto__ || Object.getPrototypeOf(Virga.prototype), \"performLayout\", this).call(this, ctxt);\n\t\n\t      this.build(ctxt).virgaAt(this.notes[0]);\n\t\n\t      this.finishLayout(ctxt);\n\t    }\n\t  }]);\n\t\n\t  return Virga;\n\t}(Neume);\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Titles = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _ExsurgeCore = __webpack_require__(1);\n\t\n\tvar _ExsurgeDrawing = __webpack_require__(4);\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //\n\t// Author(s):\n\t// Benjamin Bloomfield <benjamin@sourceandsummit.com>\n\t//\n\t// Copyright (c) 2019\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a copy\n\t// of this software and associated documentation files (the \"Software\"), to deal\n\t// in the Software without restriction, including without limitation the rights\n\t// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\t// copies of the Software, and to permit persons to whom the Software is\n\t// furnished to do so, subject to the following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included in\n\t// all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\t// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\t// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\t// THE SOFTWARE.\n\t//\n\t\n\tvar Titles = exports.Titles = function (_ChantLayoutElement) {\n\t  _inherits(Titles, _ChantLayoutElement);\n\t\n\t  function Titles(ctxt, score) {\n\t    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n\t        supertitle = _ref.supertitle,\n\t        title = _ref.title,\n\t        subtitle = _ref.subtitle,\n\t        textLeft = _ref.textLeft,\n\t        textRight = _ref.textRight;\n\t\n\t    _classCallCheck(this, Titles);\n\t\n\t    var _this = _possibleConstructorReturn(this, (Titles.__proto__ || Object.getPrototypeOf(Titles)).call(this));\n\t\n\t    _this.score = score;\n\t    _this.setSupertitle(ctxt, supertitle);\n\t    _this.setTitle(ctxt, title);\n\t    _this.setSubtitle(ctxt, subtitle);\n\t    _this.setTextLeft(ctxt, textLeft);\n\t    _this.setTextRight(ctxt, textRight);\n\t    return _this;\n\t  }\n\t\n\t  _createClass(Titles, [{\n\t    key: \"setBoundsX\",\n\t    value: function setBoundsX(ctxt, elementName, width) {\n\t      var element = this[elementName];\n\t      switch (ctxt.textStyles[elementName].alignment) {\n\t        case \"left\":\n\t          element.textAnchor = \"start\";\n\t          element.bounds.x = 0;\n\t          break;\n\t        case \"right\":\n\t          element.textAnchor = \"end\";\n\t          element.bounds.x = width;\n\t          break;\n\t        case \"center\":\n\t        default:\n\t          element.textAnchor = \"middle\";\n\t          element.bounds.x = width / 2;\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Lays out the titles, and returns their total height\n\t     * @param  {ChantContext} ctxt\n\t     * @return {number}      the tottal height of titles laid out\n\t     */\n\t\n\t  }, {\n\t    key: \"layoutTitles\",\n\t    value: function layoutTitles(ctxt, width) {\n\t      this.bounds = new _ExsurgeCore.Rect(0, 0, 0, 0);\n\t      var y = 0;\n\t      if (this.supertitle) {\n\t        this.supertitle.recalculateMetrics(ctxt);\n\t        this.supertitle.setMaxWidth(ctxt, width);\n\t\n\t        this.setBoundsX(ctxt, \"supertitle\", width);\n\t        this.supertitle.bounds.y = y;\n\t        this.bounds.union(this.supertitle.bounds);\n\t        this.supertitle.bounds.y += this.supertitle.origin.y;\n\t        y += this.supertitle.bounds.height + this.supertitle.padding(ctxt);\n\t      }\n\t      if (this.title) {\n\t        if (y) y += this.title.padding(ctxt);\n\t        this.title.recalculateMetrics(ctxt);\n\t        this.title.setMaxWidth(ctxt, width);\n\t        this.setBoundsX(ctxt, \"title\", width);\n\t        this.title.bounds.y = y;\n\t        this.bounds.union(this.title.bounds);\n\t        this.title.bounds.y += this.title.origin.y;\n\t        y += this.title.bounds.height + this.title.padding(ctxt);\n\t      }\n\t      if (this.subtitle) {\n\t        if (y) y += this.subtitle.padding(ctxt);\n\t        this.subtitle.recalculateMetrics(ctxt);\n\t        this.subtitle.setMaxWidth(ctxt, width);\n\t        this.setBoundsX(ctxt, \"subtitle\", width);\n\t        this.subtitle.bounds.y = y;\n\t        this.bounds.union(this.subtitle.bounds);\n\t        this.subtitle.bounds.y += this.subtitle.origin.y;\n\t        y += this.subtitle.bounds.height + this.subtitle.padding(ctxt);\n\t      }\n\t      var finalY = y,\n\t          textLeft = this.score.overrideTextLeft || this.textLeft;\n\t      if (textLeft) {\n\t        textLeft.recalculateMetrics(ctxt);\n\t        textLeft.bounds.y = y;\n\t        this.bounds.union(textLeft.bounds);\n\t        textLeft.bounds.y += textLeft.origin.y;\n\t        finalY = y + textLeft.bounds.height + textLeft.padding(ctxt);\n\t      }\n\t      if (this.textRight) {\n\t        this.textRight.recalculateMetrics(ctxt);\n\t        this.textRight.bounds.x = width;\n\t        this.textRight.bounds.y = y;\n\t        this.bounds.union(this.textRight.bounds);\n\t        this.textRight.bounds.y += this.textRight.origin.y;\n\t        finalY = Math.max(finalY, y + this.textRight.bounds.height + this.textRight.padding(ctxt));\n\t      }\n\t      return finalY;\n\t    }\n\t  }, {\n\t    key: \"setSupertitle\",\n\t    value: function setSupertitle(ctxt, supertitle) {\n\t      this.supertitle = supertitle ? new _ExsurgeDrawing.Supertitle(ctxt, supertitle) : null;\n\t    }\n\t  }, {\n\t    key: \"setTitle\",\n\t    value: function setTitle(ctxt, title) {\n\t      this.title = title ? new _ExsurgeDrawing.Title(ctxt, title) : null;\n\t    }\n\t  }, {\n\t    key: \"setSubtitle\",\n\t    value: function setSubtitle(ctxt, subtitle) {\n\t      this.subtitle = subtitle ? new _ExsurgeDrawing.Subtitle(ctxt, subtitle) : null;\n\t    }\n\t  }, {\n\t    key: \"setTextLeft\",\n\t    value: function setTextLeft(ctxt, textLeft) {\n\t      this.textLeft = textLeft ? new _ExsurgeDrawing.TextLeftRight(ctxt, textLeft, \"textLeft\") : null;\n\t    }\n\t  }, {\n\t    key: \"setTextRight\",\n\t    value: function setTextRight(ctxt, textRight) {\n\t      this.textRight = textRight ? new _ExsurgeDrawing.TextLeftRight(ctxt, textRight, \"textRight\") : null;\n\t    }\n\t  }, {\n\t    key: \"hasSupertitle\",\n\t    value: function hasSupertitle(ctxt, supertitle) {\n\t      return !!this.supertitle;\n\t    }\n\t  }, {\n\t    key: \"hasTitle\",\n\t    value: function hasTitle(ctxt, title) {\n\t      return !!this.title;\n\t    }\n\t  }, {\n\t    key: \"hasSubtitle\",\n\t    value: function hasSubtitle(ctxt, subtitle) {\n\t      return !!this.subtitle;\n\t    }\n\t  }, {\n\t    key: \"hasTextLeft\",\n\t    value: function hasTextLeft(ctxt, textLeft) {\n\t      return !!this.textLeft;\n\t    }\n\t  }, {\n\t    key: \"hasTextRight\",\n\t    value: function hasTextRight(ctxt, textRight) {\n\t      return !!this.textRight;\n\t    }\n\t  }, {\n\t    key: \"draw\",\n\t    value: function draw(ctxt) {\n\t      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\t\n\t      var canvasCtxt = ctxt.canvasCtxt;\n\t      canvasCtxt.translate(this.bounds.x, this.bounds.y);\n\t\n\t      var _arr = [this.supertitle, this.title, this.subtitle, this.score.overrideTextLeft || this.textLeft, this.textRight];\n\t      for (var _i = 0; _i < _arr.length; _i++) {\n\t        var el = _arr[_i];\n\t        if (el) el.draw(ctxt, scale);\n\t      }\n\t\n\t      canvasCtxt.translate(-this.bounds.x, -this.bounds.y);\n\t    }\n\t  }, {\n\t    key: \"getInnerNodes\",\n\t    value: function getInnerNodes(ctxt) {\n\t      var functionName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"createSvgNode\";\n\t\n\t      var nodes = [];\n\t\n\t      var _arr2 = [this.supertitle, this.title, this.subtitle, this.score.overrideTextLeft || this.textLeft, this.textRight];\n\t      for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n\t        var el = _arr2[_i2];\n\t        if (el) nodes.push(el[functionName](ctxt));\n\t      }\n\t      return nodes;\n\t    }\n\t  }, {\n\t    key: \"createSvgNode\",\n\t    value: function createSvgNode(ctxt) {\n\t      var nodes = this.getInnerNodes(ctxt, \"createSvgNode\");\n\t\n\t      var node = _ExsurgeDrawing.QuickSvg.createNode(\"g\", { class: \"Titles\" }, nodes);\n\t\n\t      node.source = this;\n\t      this.svg = node;\n\t\n\t      return node;\n\t    }\n\t  }, {\n\t    key: \"createSvgTree\",\n\t    value: function createSvgTree(ctxt) {\n\t      var nodes = this.getInnerNodes(ctxt, \"createSvgTree\");\n\t\n\t      return _ExsurgeDrawing.QuickSvg.createSvgTree.apply(_ExsurgeDrawing.QuickSvg, [\"g\", { class: \"Titles\", source: this }].concat(_toConsumableArray(nodes)));\n\t    }\n\t  }, {\n\t    key: \"createSvgFragment\",\n\t    value: function createSvgFragment(ctxt) {\n\t      var fragment = \"\";\n\t\n\t      var _arr3 = [this.supertitle, this.title, this.subtitle, this.score.overrideTextLeft || this.textLeft, this.textRight];\n\t      for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n\t        var el = _arr3[_i3];\n\t        if (el) fragment += el.createSvgFragment(ctxt);\n\t      }\n\t\n\t      fragment = _ExsurgeDrawing.QuickSvg.createFragment(\"g\", { class: \"Titles\" }, fragment);\n\t      return fragment;\n\t    }\n\t  }]);\n\t\n\t  return Titles;\n\t}(_ExsurgeDrawing.ChantLayoutElement);\n\n/***/ })\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// exsurge.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8075a7bf4bf4cb707836","//\n// Author(s):\n// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>\n//\n// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n//\n\n'use strict';\n\n// import { Annotation, ChantContext } from './Exsurge.Drawing.js'\n// import { Gabc } from './Exsurge.Gabc.js'\n//\n// // client side support\n//\n// if (typeof document !== 'undefined' && document.registerElement) {\n//   var ChantVisualElementPrototype = Object.create(HTMLElement.prototype);\n//\n//   ChantVisualElementPrototype.createdCallback = function() {\n//     var ctxt = new ChantContext();\n//\n//     ctxt.setFont(\"'Crimson Text', serif\", 19.2);\n//\n//     var useDropCap = true;\n//     var useDropCapAttr = this.getAttribute(\"use-drop-cap\");\n//     if (useDropCapAttr === 'false')\n//       useDropCap = false;\n//\n//     var score = Gabc.loadChantScore(ctxt, this.innerText, useDropCap);\n//\n//     var annotationAttr = this.getAttribute(\"annotation\");\n//     if (annotationAttr) {\n//       // add an annotation\n//       score.annotation = new Annotation(ctxt, annotationAttr);\n//     }\n//\n//     var _element = this;\n//\n//     var width = 0;\n//     var doLayout = function() {\n//       var newWidth = _element.parentElement.clientWidth;\n//       if(width === newWidth) return;\n//       width = newWidth;\n//       // perform layout on the chant\n//       score.performLayout(ctxt, function() {\n//         score.layoutChantLines(ctxt, width, function() {\n//           // render the score to svg code\n//           _element.appendElement(score.createSvgNode(ctxt));\n//         });\n//       });\n//     }\n//     doLayout();\n//     if (window.addEventListener)\n//       window.addEventListener('resize',doLayout,false);\n//     else if (window.attachEvent)\n//       window.attachEvent('onresize',doLayout);\n//   }\n//\n//   ChantVisualElementPrototype.attachedCallback = function() {\n//\n//   }\n//\n//   // register the custom element\n//   // if(window.customElements && window.customElements.define) {\n//   //   window.customElements.define('chant-visual', ChantVisualElementPrototype);\n//   // } else {\n//     document.registerElement('chant-visual', {\n//       prototype: ChantVisualElementPrototype\n//     });\n//   // }\n// }\n\nexport * from './Exsurge.Core.js'\nexport * from './Exsurge.Text.js'\nexport * from './Exsurge.Glyphs.js'\nexport * from './Exsurge.Drawing.js'\nexport * from './Exsurge.Chant.js'\nexport * from './Exsurge.Chant.ChantLine.js'\nexport * from './Exsurge.Chant.Markings.js'\nexport * from './Exsurge.Chant.Signs.js'\nexport * from './Exsurge.Chant.Neumes.js'\nexport * from './Exsurge.Gabc.js'\nexport * from './Exsurge.Titles.js'\nexport * from './greextraGlyphs.js'\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","//\n// Author(s):\n// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>\n//\n// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n//\n\nexport var Units = {\n  // enums\n  DeviceIndepenedent: 0, // device independent units: 96/inch\n  Centimeters: 1,\n  Millimeters: 2,\n  Inches: 3,\n\n  // constants for device independent units (diu)\n  DIU_PER_INCH: 96,\n  DIU_PER_CENTIMETER: 96 / 2.54,\n\n  ToDeviceIndependent: function (n, inputUnits) {\n    switch (inputUnits) {\n      case Centimeters:\n        return n * Units.DIU_PER_CENTIMETER;\n      case Millimeters:\n        return n * Units.DIU_PER_CENTIMETER / 10;\n      case Inches:\n        return n * Units.DIU_PER_INCH;\n      default:\n        return n;\n    }\n  },\n\n  FromDeviceIndependent: function (n, outputUnits) {\n    switch (outputUnits) {\n      case Centimeters:\n        return n / Units.DIU_PER_CENTIMETER;\n      case Millimeters:\n        return n / Units.DIU_PER_CENTIMETER * 10;\n      case Inches:\n        return n / Units.DIU_PER_INCH;\n      default:\n        return n;\n    }\n  },\n\n\n  StringToUnitsType: function(s) {\n    switch (s.ToLower()) {\n      case \"in\":\n      case \"inches\":\n        return Units.Inches;\n\n      case \"cm\":\n      case \"centimeters\":\n        return Units.Centimeters;\n\n      case \"mm\":\n      case \"millimeters\":\n        return Units.Millimeters;\n\n      case \"di\":\n      case \"device-independent\":\n        return Units.DeviceIndepenedent;\n\n      default:\n        return Units.DeviceIndepenedent;\n    }\n  },\n\n  UnitsTypeToString: function(units) {\n    switch (units) {\n      case Units.Inches: return \"in\";\n      case Units.Centimeters: return \"cm\";\n      case Units.Millimeters: return \"mm\";\n      case Units.DeviceIndepenedent: return \"device-independent\";\n      default: return \"device-independent\";\n    }\n  }\n}\n\nexport function DeviceIndependent(n) {\n  return n;\n}\n\nexport function Centimeters(n) {\n  return Units.ToDeviceIndependent(n, Units.Centimeters);\n}\n\nexport function Millimeters(n) {\n  return Units.ToDeviceIndependent(n, Units.Millimeters);\n}\n\nexport function Inches(n) {\n  return Units.ToDeviceIndependent(n, Units.Inches);\n}\n\nexport function ToCentimeters(n) {\n  return Units.FromDeviceIndependent(n, Units.Centimeters);\n}\n\nexport function ToMillimeters(n) {\n  return Units.FromDeviceIndependent(n, Units.Millimeters);\n}\n\nexport function ToInches(n) {\n  return Units.FromDeviceIndependent(n, Units.Inches);\n}\n\n\n/*\n * Point\n */\nexport class Point {\n  constructor(x, y) {\n    this.x = (typeof x !== 'undefined') ? x : 0;\n    this.y = (typeof y !== 'undefined') ? y : 0;\n  }\n\n  clone() {\n    return new Point(this.x, this.y);\n  }\n\n  equals(point) {\n    return this.x === point.x && this.y === point.y;\n  }\n}\n\n/*\n * Rect\n */\nexport class Rect {\n  constructor(x, y, width, height) {\n    this.x = (typeof x !== 'undefined') ? x : Infinity;\n    this.y = (typeof y !== 'undefined') ? y : Infinity;\n    this.width = (typeof width !== 'undefined') ? width : -Infinity;\n    this.height = (typeof height !== 'undefined') ? height : -Infinity;\n  }\n\n  clone() {\n    return new Rect(this.x, this.y, this.width, this.height);\n  }\n\n  isEmpty() {\n    return (this.x === Infinity &&\n            this.y === Infinity &&\n            this.width === -Infinity &&\n            this.height === -Infinity);\n  }\n\n  // convenience method\n  right() {\n    return this.x + this.width;\n  }\n\n  bottom() {\n    return this.y + this.height;\n  }\n\n  equals(rect) {\n    return this.x === rect.x && this.y === rect.y &&\n           this.width === rect.width && this.height === rect.height;\n  }\n\n  // other can be a Point or a Rect\n  contains(other) {\n    if (other instanceof Point) {\n      return other.x >= this.x &&\n              other.x <= this.x + this.width &&\n              other.y >= this.y &&\n              other.y <= this.y + this.height;\n    } else { // better be instance of Rect\n      return this.x <= other.x &&\n              this.x + this.width >= other.x + other.width &&\n              this.y <= other.y &&\n              this.y + this.height >= other.y + other.height;\n    }\n  }\n\n  union(rect) {\n\n    var right = Math.max(this.x + this.width, rect.x + rect.width);\n    var bottom = Math.max(this.y + this.height, rect.y + rect.height);\n\n    this.x = Math.min(this.x, rect.x);\n    this.y = Math.min(this.y, rect.y);\n\n    this.width = right - this.x;\n    this.height = bottom - this.y;\n  }\n}\n\n/**\n * Margins\n *\n * @class\n */\nexport class Margins {\n  constructor(left, top, right, bottom) {\n    this.left = (typeof left !== 'undefined') ? left : 0;\n    this.top = (typeof top !== 'undefined') ? top : 0;\n    this.right = (typeof right !== 'undefined') ? right : 0;\n    this.bottom = (typeof bottom !== 'undefined') ? bottom : 0;\n  }\n\n  clone() {\n    return new Margins(this.left, this.top, this.right, this.bottom);\n  }\n\n  equals(margins) {\n    return this.left === margins.left &&\n        this.top === margins.top &&\n        this.right === margins.right &&\n        this.bottom === margins.bottom;\n  }\n}\n\n/**\n * Size\n *\n * @class\n */\nexport class Size {\n  constructor(width, height) {\n    this.width = (typeof width !== 'undefined') ? width : 0;\n    this.height = (typeof height !== 'undefined') ? height : 0;\n  }\n\n  clone() {\n    return new Size(this.width, this.height);\n  }\n\n  equals(size) {\n    return this.width === size.width && this.height === size.height;\n  }\n}\n\n\n/*\n * Pitches, notes\n */\nexport var Step = {\n  Do: 0,\n  Du: 1,\n  Re: 2,\n  Me: 3,\n  Mi: 4,\n  Fa: 5,\n  Fu: 6,\n  So: 7,\n  La: 9,\n  Te: 10,\n  Ti: 11\n};\n\n  // this little array helps map step values to staff positions. The numeric values of steps\n  // correspond to whole step increments (2) or half step increments (1). This gives us the ability\n  // to compare pitches precisely, but makes it challenging to place steps on the staff. this little\n  // array maps the steps to an incremental position the steps take on the staff line. This works\n  // so simply because chant only uses do and fa clefs, and only has a flatted ti (te), making\n  // for relatively easy mapping to staff line locations.\n  //                         Do Du Re Me Mi Fa Fu So    La Te Ti\nvar __StepToStaffPosition = [0, 0, 1, 1, 2, 3, 3, 4, 4, 5, 6, 6];\nvar __StaffOffsetToStep = [Step.Do, Step.Re, Step.Mi, Step.Fa, Step.So, Step.La, Step.Ti]; // no accidentals in this one\n\n\nexport class Pitch {\n  constructor(step, octave) {\n    if(typeof octave === 'undefined') {\n      octave = Math.floor(step / 12)\n      step = step % 12;\n    }\n    this.step = step;\n    this.octave = octave;\n  }\n\n  toInt() {\n    return this.octave * 12 + this.step;\n  }\n\n  transpose(step) {\n    return new Pitch(this.toInt() + step);\n  }\n\n  isHigherThan(pitch) {\n    return this.toInt() > pitch.toInt();\n  }\n\n  isLowerThan(pitch) {\n    return this.toInt() < pitch.toInt();\n  }\n\n  equals(pitch) {\n    return this.toInt() === pitch.toInt();\n  }\n\n  static stepToStaffOffset(step) {\n    return __StepToStaffPosition[step];\n  }\n\n  static staffOffsetToStep(offset) {\n    while (offset < 0)\n      offset = __StaffOffsetToStep.length + offset;\n\n    return __StaffOffsetToStep[offset % __StaffOffsetToStep.length];\n  }\n}\n\nexport function generateRandomGuid() {\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000)\n      .toString(16)\n      .substring(1);\n  }\n  return s4() + s4();\n}\n\nexport function getCssForProperties(properties) {\n  return Object.entries(properties)\n    .map(([key, val]) =>\n      key && val && key !== \"class\" ? `${key}: ${val};` : \"\"\n    )\n    .join(\"\");\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Exsurge.Core.js","//\n\n/**\n * @class\n */\nexport class Language {\n  constructor(name) {\n    this.name = typeof name !== \"undefined\" ? name : \"<unknown>\";\n    this.centerNeume = false;\n  }\n\n  /**\n   * @param {String} text The string to parsed into words.\n   * @return {Word[]} the resulting parsed words from syllabification\n   */\n  syllabify(text) {\n    var parsedWords = [];\n\n    if (typeof text === \"undefined\" || text === \"\") return parsedWords;\n\n    // Divide the text into words separated by whitespace\n    var words = text.split(/[\\s]+/);\n\n    for (var i = 0, end = words.length; i < end; i++)\n      parsedWords.push(this.syllabifyWord(words[i]));\n\n    return parsedWords;\n  }\n}\n\nexport class English extends Language {\n  constructor() {\n    super(\"English\");\n    this.centerNeume = true;\n    this.regexLetter = /[a-z\\u00c0-\\u02af\\u0300-\\u036f\\u1e00-\\u1eff‿]+/i;\n  }\n\n  /**\n   * @param {String} s the string to search\n   * @param {Number} startIndex The index at which to start searching for a vowel in the string\n   * @retuns a custom class with three properties: {found: (true/false) startIndex: (start index in s of vowel segment) length ()}\n   */\n  findVowelSegment(s, startIndex) {\n    var match = this.regexLetter.exec(s.slice(startIndex));\n    if (match)\n      return {\n        found: true,\n        startIndex: startIndex + match.index,\n        length: match[0].length\n      };\n\n    // no vowels sets found after startIndex!\n    return { found: false, startIndex: -1, length: -1 };\n  }\n}\n\n/**\n * @class\n */\nexport class Latin extends Language {\n  /**\n   * @constructs\n   */\n  constructor() {\n    super(\"Latin\");\n\n    // fixme: ui is only diphthong in the exceptional cases below (according to Wheelock's Latin)\n    this.diphthongs = [\"ae\", \"au\", \"oe\", \"aé\", \"áu\", \"oé\"];\n    // for centering over the vowel, we will need to know any combinations that might be diphthongs:\n    this.possibleDiphthongs = this.diphthongs.concat([\n      \"ei\",\n      \"eu\",\n      \"ui\",\n      \"éi\",\n      \"éu\",\n      \"úi\"\n    ]);\n    this.regexVowel = /(i|(?:[qg]|^)u)?([eé][iu]|[uú]i|[ao][eé]|[aá]u|[aeiouáéíóúäëïöüāēīōūăĕĭŏŭåe̊o̊ůæœǽyýÿ])/gi;\n\n    // some words that are simply exceptions to standard syllabification rules!\n    var wordExceptions = new Object();\n\n    // ui combos pronounced as diphthongs\n    wordExceptions[\"huius\"] = [\"hui\", \"us\"];\n    wordExceptions[\"cuius\"] = [\"cui\", \"us\"];\n    wordExceptions[\"huic\"] = [\"huic\"];\n    wordExceptions[\"cui\"] = [\"cui\"];\n    wordExceptions[\"hui\"] = [\"hui\"];\n\n    // eu combos pronounced as diphthongs\n    wordExceptions[\"euge\"] = [\"eu\", \"ge\"];\n    wordExceptions[\"seu\"] = [\"seu\"];\n\n    this.vowels = [\n      \"a\",\n      \"e\",\n      \"i\",\n      \"o\",\n      \"u\",\n      \"á\",\n      \"é\",\n      \"í\",\n      \"ó\",\n      \"ú\",\n      \"ä\",\n      \"ë\",\n      \"ï\",\n      \"ö\",\n      \"ü\",\n      \"ā\",\n      \"ē\",\n      \"ī\",\n      \"ō\",\n      \"ū\",\n      \"ă\",\n      \"ĕ\",\n      \"ĭ\",\n      \"ŏ\",\n      \"ŭ\",\n      \"å\",\n      \"e̊\",\n      \"o̊\",\n      \"ů\",\n      \"æ\",\n      \"œ\",\n      \"ǽ\", // no accented œ in unicode?\n      \"y\",\n      \"ý\",\n      \"ÿ\"\n    ]; // y is treated as a vowel; not native to Latin but useful for words borrowed from Greek\n\n    this.vowelsThatMightBeConsonants = [\"i\", \"u\"];\n\n    this.muteConsonantsAndF = [\"b\", \"c\", \"d\", \"g\", \"p\", \"t\", \"f\"];\n\n    this.liquidConsonants = [\"l\", \"r\"];\n  }\n\n  // c must be lowercase!\n  isVowel(c) {\n    for (var i = 0, end = this.vowels.length; i < end; i++)\n      if (this.vowels[i] === c) return true;\n\n    return false;\n  }\n\n  isVowelThatMightBeConsonant(c) {\n    for (var i = 0, end = this.vowelsThatMightBeConsonants.length; i < end; i++)\n      if (this.vowelsThatMightBeConsonants[i] === c) return true;\n\n    return false;\n  }\n\n  // substring should be a vowel and the character following\n  isVowelActingAsConsonant(substring) {\n    return (\n      this.isVowelThatMightBeConsonant(substring[0]) &&\n      this.isVowel(substring[1])\n    );\n  }\n\n  /**\n   * f is not a mute consonant, but we lump it together for syllabification\n   * since it is syntactically treated the same way\n   *\n   * @param {String} c The character to test; must be lowercase\n   * @return {boolean} true if c is an f or a mute consonant\n   */\n  isMuteConsonantOrF(c) {\n    for (var i = 0, end = this.muteConsonantsAndF.length; i < end; i++)\n      if (this.muteConsonantsAndF[i] === c) return true;\n\n    return false;\n  }\n\n  /**\n   *\n   * @param {String} c The character to test; must be lowercase\n   * @return {boolean} true if c is a liquid consonant\n   */\n  isLiquidConsonant(c) {\n    for (var i = 0, end = this.liquidConsonants.length; i < end; i++)\n      if (this.liquidConsonants[i] === c) return true;\n\n    return false;\n  }\n\n  /**\n   *\n   * @param {String} s The string to test; must be lowercase\n   * @return {boolean} true if s is a diphthong\n   */\n  isDiphthong(s) {\n    for (var i = 0, end = this.diphthongs.length; i < end; i++)\n      if (this.diphthongs[i] === s) return true;\n\n    return false;\n  }\n\n  /**\n   *\n   * @param {String} s The string to test; must be lowercase\n   * @return {boolean} true if s is a diphthong\n   */\n  isPossibleDiphthong(s) {\n    for (var i = 0, end = this.possibleDiphthongs.length; i < end; i++)\n      if (this.possibleDiphthongs[i] === s) return true;\n\n    return false;\n  }\n\n  /**\n   * Rules for Latin syllabification (from Collins, \"A Primer on Ecclesiastical Latin\")\n   *\n   * Divisions occur when:\n   *   1. After open vowels (those not followed by a consonant) (e.g., \"pi-us\" and \"De-us\")\n   *   2. After vowels followed by a single consonant (e.g., \"vi-ta\" and \"ho-ra\")\n   *   3. After the first consonant when two or more consonants follow a vowel\n   *      (e.g., \"mis-sa\", \"minis-ter\", and \"san-ctus\").\n   *\n   * Exceptions:\n   *   1. In compound words the consonants stay together (e.g., \"de-scribo\").\n   *   2. A mute consonant (b, c, d, g, p, t) or f followed by a liquid consonant (l, r)\n   *      go with the succeeding vowel: \"la-crima\", \"pa-tris\"\n   *\n   * In addition to these rules, Wheelock's Latin provides this sound exception:\n   *   -  Also counted as single consonants are qu and the aspirates ch, ph,\n   *      th, which should never be separated in syllabification:\n   *      architectus, ar-chi-tec-tus; loquacem, lo-qua-cem.\n   *\n   */\n  syllabifyWord(word) {\n    var syllables = [];\n    var haveCompleteSyllable = false;\n    var previousWasVowel = false;\n    var workingString = word.toLowerCase();\n    var startSyllable = 0;\n\n    var c, lookahead, haveLookahead;\n\n    // a helper function to create syllables\n    var makeSyllable = function(length) {\n      if (haveCompleteSyllable) {\n        syllables.push(word.substr(startSyllable, length));\n        startSyllable += length;\n      }\n\n      haveCompleteSyllable = false;\n    };\n\n    for (var i = 0, wordLength = workingString.length; i < wordLength; i++) {\n      c = workingString[i];\n\n      // get our lookahead in case we need them...\n      lookahead = \"*\";\n      haveLookahead = i + 1 < wordLength;\n\n      if (haveLookahead) lookahead = workingString[i + 1];\n\n      var cIsVowel = this.isVowel(c);\n\n      // i is a special case for a vowel. when i is at the beginning\n      // of the word (Iesu) or i is between vowels (alleluia),\n      // then the i is treated as a consonant (y)\n      if (c === \"i\") {\n        if (i === 0 && haveLookahead && this.isVowel(lookahead))\n          cIsVowel = false;\n        else if (previousWasVowel && haveLookahead && this.isVowel(lookahead)) {\n          cIsVowel = false;\n        }\n      }\n\n      if (c === \"-\") {\n        // a hyphen forces a syllable break, which effectively resets\n        // the logic...\n\n        haveCompleteSyllable = true;\n        previousWasVowel = false;\n        makeSyllable(i - startSyllable);\n        startSyllable++;\n      } else if (cIsVowel) {\n        // once we get a vowel, we have a complete syllable\n        haveCompleteSyllable = true;\n\n        if (\n          previousWasVowel &&\n          !this.isDiphthong(workingString[i - 1] + \"\" + c)\n        ) {\n          makeSyllable(i - startSyllable);\n          haveCompleteSyllable = true;\n        }\n\n        previousWasVowel = true;\n      } else if (haveLookahead) {\n        if (\n          (c === \"q\" && lookahead === \"u\") ||\n          (lookahead === \"h\" && (c === \"c\" || c === \"p\" || c === \"t\"))\n        ) {\n          // handle wheelock's exceptions for qu, ch, ph and th\n          makeSyllable(i - startSyllable);\n          i++; // skip over the 'h' or 'u'\n        } else if (previousWasVowel && this.isVowel(lookahead)) {\n          // handle division rule 2\n          makeSyllable(i - startSyllable);\n        } else if (\n          this.isMuteConsonantOrF(c) &&\n          this.isLiquidConsonant(lookahead)\n        ) {\n          // handle exception 2\n          makeSyllable(i - startSyllable);\n        } else if (haveCompleteSyllable) {\n          // handle division rule 3\n          makeSyllable(i + 1 - startSyllable);\n        }\n\n        previousWasVowel = false;\n      }\n    }\n\n    // if we have a complete syllable, we can add it as a new one. Otherwise\n    // we tack the remaining characters onto the last syllable.\n    if (haveCompleteSyllable) syllables.push(word.substr(startSyllable));\n    else if (startSyllable > 0)\n      syllables[syllables.length - 1] += word.substr(startSyllable);\n\n    return syllables;\n  }\n\n  /**\n   * @param {String} s the string to search\n   * @param {Number} startIndex The index at which to start searching for a vowel in the string\n   * @retuns a custom class with three properties: {found: (true/false) startIndex: (start index in s of vowel segment) length ()}\n   */\n  findVowelSegment(s, startIndex, ignore) {\n    this.regexVowel.lastIndex = 0;\n    let stringSlice = s.slice(startIndex);\n    var match = this.regexVowel.exec(stringSlice);\n    var isIgnoredMatch = ({ index, endIndex }) => (index <= match.index && endIndex > match.index) || (index < this.regexVowel.lastIndex && endIndex >= this.regexVowel.lastIndex);\n    let inIgnore = match && ignore && ignore.length && ignore.find(isIgnoredMatch);\n    while (inIgnore) {\n      match = this.regexVowel.exec(stringSlice);\n      inIgnore = match && ignore.find(isIgnoredMatch);\n    }\n    if (match) {\n      if (match[1]) {\n        // the first group should be ignored, as it is to separate an i or u that is used as a consonant.\n        match.index += match[1].length;\n      }\n      return {\n        found: true,\n        startIndex: startIndex + match.index,\n        length: match[2].length\n      };\n    }\n\n    // no vowels sets found after startIndex!\n    return { found: false, startIndex: -1, length: -1 };\n  }\n}\n\n/**\n * @class\n */\nexport class Spanish extends Language {\n  constructor() {\n    super(\"Spanish\");\n\n    this.vowels = [\"a\", \"e\", \"i\", \"o\", \"u\", \"y\", \"á\", \"é\", \"í\", \"ó\", \"ú\", \"ü\"];\n\n    this.weakVowels = [\"i\", \"u\", \"ü\", \"y\"];\n\n    this.strongVowels = [\"a\", \"e\", \"o\", \"á\", \"é\", \"í\", \"ó\", \"ú\"];\n\n    this.diphthongs = [\n      \"ai\",\n      \"ei\",\n      \"oi\",\n      \"ui\",\n      \"ia\",\n      \"ie\",\n      \"io\",\n      \"iu\",\n      \"au\",\n      \"eu\",\n      \"ou\",\n      \"ua\",\n      \"ue\",\n      \"uo\",\n      \"ái\",\n      \"éi\",\n      \"ói\",\n      \"úi\",\n      \"iá\",\n      \"ié\",\n      \"ió\",\n      \"iú\",\n      \"áu\",\n      \"éu\",\n      \"óu\",\n      \"uá\",\n      \"ué\",\n      \"uó\",\n      \"üe\",\n      \"üi\"\n    ];\n\n    this.uDiphthongExceptions = [\"gue\", \"gui\", \"qua\", \"que\", \"qui\", \"quo\"];\n  }\n\n  // c must be lowercase!\n  isVowel(c) {\n    for (var i = 0, end = this.vowels.length; i < end; i++)\n      if (this.vowels[i] === c) return true;\n\n    return false;\n  }\n\n  /**\n   * @param {String} c The character to test; must be lowercase\n   * @return {boolean} true if c is an f or a mute consonant\n   */\n  isWeakVowel(c) {\n    for (var i = 0, end = this.weakVowels.length; i < end; i++)\n      if (this.weakVowels[i] === c) return true;\n\n    return false;\n  }\n\n  /**\n   * @param {String} c The character to test; must be lowercase\n   * @return {boolean} true if c is an f or a mute consonant\n   */\n  isStrongVowel(c) {\n    for (var i = 0, end = this.strongVowels.length; i < end; i++)\n      if (this.strongVowels[i] === c) return true;\n\n    return false;\n  }\n\n  /**\n   *\n   * @param {String} s The string to test; must be lowercase\n   * @return {boolean} true if s is a diphthong\n   */\n  isDiphthong(s) {\n    for (var i = 0, end = this.diphthongs.length; i < end; i++)\n      if (this.diphthongs[i] === s) return true;\n\n    return false;\n  }\n\n  createSyllable(text) {\n    /*\n    var accented = false;\n    var ellidesToNext = false;\n\n    if (text.length > 0) {\n\n        if (text[0] == '`') {\n            accented = true;\n            text = text.substr(1);\n        }\n\n        if (text[text.length - 1] == '_') {\n            ellidesToNext = true;\n            text = text.substr(0, text.length - 1);\n        }\n    }\n\n    var s = new Syllable(text);\n\n    s.isMusicalAccent = accented;\n    s.elidesToNext = ellidesToNext;*/\n\n    return text;\n  }\n\n  /**\n   */\n  syllabifyWord(word) {\n    var syllables = [];\n\n    var haveCompleteSyllable = false;\n    var previousIsVowel = false;\n    var previousIsStrongVowel = false; // only valid if previousIsVowel == true\n    var startSyllable = 0;\n\n    // fixme: first check for prefixes\n\n    for (var i = 0; i < word.length; i++) {\n      var c = word[i].toLowerCase();\n\n      if (this.isVowel(c)) {\n        // we have a complete syllable as soon as we have a vowel\n        haveCompleteSyllable = true;\n\n        var cIsStrongVowel = this.isStrongVowel(c);\n\n        if (previousIsVowel) {\n          // if we're at a strong vowel, then we finish out the last syllable\n          if (cIsStrongVowel) {\n            if (previousIsStrongVowel) {\n              syllables.push(\n                this.createSyllable(\n                  word.substr(startSyllable, i - startSyllable)\n                )\n              );\n              startSyllable = i;\n            }\n          }\n        }\n\n        previousIsVowel = true;\n        previousIsStrongVowel = cIsStrongVowel;\n      } else {\n        if (!haveCompleteSyllable) {\n          // do nothing since we don't have a complete syllable yet...\n        } else {\n          // handle explicit syllable breaks\n          if (word[i] === \"-\") {\n            // start new syllable\n            syllables.push(\n              this.createSyllable(word.substr(startSyllable, i - startSyllable))\n            );\n            startSyllable = ++i;\n          } else {\n            var numberOfConsonants = 1,\n              consonant2;\n\n            // count how many more consonants there are\n            for (var j = i + 1; j < word.length; j++) {\n              if (this.isVowel(word[j])) break;\n              numberOfConsonants++;\n            }\n\n            if (numberOfConsonants === 1) {\n              // start new syllable\n              syllables.push(\n                this.createSyllable(\n                  word.substr(startSyllable, i - startSyllable)\n                )\n              );\n              startSyllable = i;\n            } else if (numberOfConsonants === 2) {\n              consonant2 = word[i + 1].toLowerCase();\n              if (\n                consonant2 === \"l\" ||\n                consonant2 === \"r\" ||\n                (c === \"c\" && consonant2 === \"h\")\n              ) {\n                // split before the consonant pair\n                syllables.push(\n                  this.createSyllable(\n                    word.substr(startSyllable, i - startSyllable)\n                  )\n                );\n                startSyllable = i++;\n              } else {\n                //split the consonants\n                syllables.push(\n                  this.createSyllable(\n                    word.substr(startSyllable, ++i - startSyllable)\n                  )\n                );\n                startSyllable = i;\n              }\n            } else if (numberOfConsonants === 3) {\n              consonant2 = word[i + 1].toLowerCase();\n\n              // if second consonant is s, divide cc-c, otherwise divide c-cc\n              if (consonant2 === \"s\") {\n                i += 2;\n                syllables.push(\n                  this.createSyllable(\n                    word.substr(startSyllable, i - startSyllable)\n                  )\n                );\n              } else\n                syllables.push(\n                  this.createSyllable(\n                    word.substr(startSyllable, ++i - startSyllable)\n                  )\n                );\n\n              startSyllable = i;\n            } else if (numberOfConsonants === 4) {\n              // four always get split cc-cc\n              syllables.push(\n                this.createSyllable(\n                  word.substr(startSyllable, i - startSyllable + 2)\n                )\n              );\n              startSyllable = i + 2;\n              i += 3;\n            }\n          }\n\n          haveCompleteSyllable = false;\n        }\n\n        previousIsVowel = false;\n      }\n    }\n\n    // if we have a complete syllable, we can add it as a new one. Otherwise\n    // we tack the remaining characters onto the last syllable.\n    if (haveCompleteSyllable) syllables.push(word.substr(startSyllable));\n    else if (startSyllable > 0)\n      syllables[syllables.length - 1] += word.substr(startSyllable);\n    else if (syllables.length === 0) syllables.push(this.createSyllable(word));\n\n    return syllables;\n  }\n\n  /**\n   * @param {String} s the string to search\n   * @param {Number} startIndex The index at which to start searching for a vowel in the string\n   * @retuns a custom class with three properties: {found: (true/false) startIndex: (start index in s of vowel segment) length ()}\n   */\n  findVowelSegment(s, startIndex) {\n    var i, end, index;\n    var workingString = s.toLowerCase();\n\n    // do we have a diphthongs?\n    for (i = 0, end = this.diphthongs.length; i < end; i++) {\n      var d = this.diphthongs[i];\n      index = workingString.indexOf(d, startIndex);\n\n      if (index >= 0) {\n        // check the exceptions...\n        if (d[0] === \"u\" && index > 0) {\n          var tripthong = s.substr(index - 1, 3).toLowerCase();\n\n          for (\n            let j = 0, endj = this.uDiphthongExceptions.length;\n            i < endj;\n            j++\n          ) {\n            if (tripthong === this.uDiphthongExceptions[j]) {\n              // search from after the u...\n              return this.findVowelSegment(s, index + 1);\n            }\n          }\n        }\n\n        return { found: true, startIndex: index, length: d.length };\n      }\n    }\n\n    // no diphthongs. Let's look for single vowels then...\n    for (i = 0, end = this.vowels.length; i < end; i++) {\n      index = workingString.indexOf(this.vowels[i], startIndex);\n\n      if (index >= 0) return { found: true, startIndex: index, length: 1 };\n    }\n\n    // no vowels sets found after startIndex!\n    return { found: false, startIndex: -1, length: -1 };\n  }\n}\n\nexport const language = {\n  english: new English(),\n  latin: new Latin(),\n  spanish: new Spanish()\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/Exsurge.Text.js","//\n// Author(s):\n// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>\n//\n// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n//\n\n// generated based on the svg data\nexport let Glyphs = {\n  None: {\n    paths: [\n      {\n        type: \"positive\",\n        data: \"\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    },\n    origin: {\n      x: 0,\n      y: 0\n    },\n    align: \"left\"\n  },\n  AcuteAccent: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M4 0C-.614.52-.614.52-.803-3.182l60.768-108.422c4.52-7.182 10.543-13.67 18.075-13.67 5.27 0 14.31 1.264 23.346 7.793 7.53 5.223 8.803 11.752 8.803 16.975 0 3.917-.52 11.1-8.05 17.628L4 0z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 0, // TODO: figure out a better way to align this horizontally.  width should be 110.992,\n      height: 125.794\n    },\n    origin: {\n      x: 0.803,\n      y: 125.274\n    },\n    align: \"left\"\n  },\n  GraveAccent: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M105.386.26C110 .78 110 .78 110.189-2.922l-60.768-108.422c-4.52-7.182-10.543-13.67-18.075-13.67-5.27 0-14.31 1.264-23.346 7.793-7.53 5.223-8.803 11.752-8.803 16.975 0 3.917.52 11.1 8.05 17.628L105.386.26z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 0, //110.992,\n      height: 125.794\n    },\n    origin: {\n      x: 0, // -110.992,\n      y: 125.274\n    },\n    align: \"left\"\n  },\n  Circle: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M0 -50A50 50 0 0 0 100 -50 50 50 0 0 0 0 -50M10 -50A40 40 0 0 1 90 -50 40 40 0 0 1 10 -50\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 100,\n      height: 100\n    },\n    origin: {\n      x: -50,\n      y: 100\n    }\n  },\n  Semicircle: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M0 -50A50 50 0 0 0 100 -50 5 5 0 0 0 90 -50 40 40 0 0 1 10 -50 5 5 0 0 0 0 -50\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 100,\n      height: 55\n    },\n    origin: {\n      x: -50,\n      y: 50\n    }\n  },\n  ReversedSemicircle: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M0 0A50 50 0 0 1 100 0 5 5 0 0 1 90 0 40 40 0 0 0 10 0 5 5 0 0 1 0 0\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 100,\n      height: 55\n    },\n    origin: {\n      x: -50,\n      y: 50\n    }\n  },\n  Stropha: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M1.22-73.438c4.165 13.02 12.238 27.084 24.217 42.188L49.657 0 34.812 27.344C18.666 55.47-.084 72.396-21.438 78.124c4.687-3.645 7.03-8.593 7.03-14.843 0-8.853-4.947-20.572-14.843-35.155L-48 0 1.22-73.438z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 97.657,\n      height: 151.562\n    },\n    origin: {\n      x: 48,\n      y: 73.438\n    },\n    align: \"left\"\n  },\n  BeginningAscLiquescent: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M-50 43.688V-61c4.167 7.292 12.76 10.938 25.78 10.938 9.376 0 20.053-1.563 32.032-4.688C31.773-60.48 45.833-71.677 50-88.344v117.97C43.75 42.645 32.812 51.5 17.187 56.186-.52 61.398-15.886 64-28.906 64-42.97 64-50 57.23-50 43.687z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 100,\n      height: 152.344\n    },\n    origin: {\n      x: 50,\n      y: 88.344\n    },\n    align: \"left\"\n  },\n  BeginningDesLiquescent: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M-50-56.03c0-13.022 7.03-19.532 21.094-19.532 13.02 0 28.385 2.604 46.093 7.812C32.813-63.583 43.75-54.73 50-41.187V76C45.833 59.854 31.77 48.656 7.812 42.406c-11.98-3.125-22.656-4.687-32.03-4.687-13.022 0-21.615 3.905-25.782 11.718v-105.47z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 100,\n      height: 151.562\n    },\n    origin: {\n      x: 50,\n      y: 75.562\n    },\n    align: \"left\"\n  },\n  CustosDescLong: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M39.063 273.472c5.73.52 7.29-6.25 4.687-20.312V-65.59c-13.542 2.083-24.22 5.468-32.03 10.156C3.905-50.226 0-43.714 0-35.904V71.91c5.73-5.21 10.677-8.594 14.844-10.157 5.73-1.562 12.24-2.343 19.53-2.343v196.875c0 11.458 1.563 17.187 4.688 17.187\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 46.353,\n      height: 339.582\n    },\n    origin: {\n      x: 0,\n      y: 65.59\n    },\n    align: \"left\"\n  },\n  CustosDescShort: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M34.375 191.923c0 8.333 1.563 12.24 4.688 11.72 3.125-.522 4.687-7.033 4.687-19.533v-250c-13.542 2.084-24.22 5.47-32.03 10.157C3.905-50.525 0-44.015 0-36.203V71.61c5.73-5.208 10.677-8.593 14.844-10.156 5.73-1.562 12.24-2.344 19.53-2.344v132.813z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 43.75,\n      height: 270.053\n    },\n    origin: {\n      x: 0,\n      y: 65.89\n    },\n    align: \"left\"\n  },\n  CustosLong: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M39.063-269.562c5.73-.52 7.29 6.25 4.687 20.312V69.5c-13.542-2.083-24.22-5.47-32.03-10.156C3.905 54.134 0 47.624 0 39.812V-68c5.73 5.208 10.677 8.594 14.844 10.156 5.73 1.563 12.24 2.344 19.53 2.344v-196.875c0-11.458 1.563-17.187 4.688-17.187z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 46.353,\n      height: 339.582\n    },\n    origin: {\n      x: 0,\n      y: 270.082\n    },\n    align: \"left\"\n  },\n  CustosShort: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M34.375-188.125c0-8.333 1.563-12.24 4.688-11.72 3.125.522 4.687 7.033 4.687 19.532v250c-13.542-2.083-24.22-5.468-32.03-10.156C3.905 54.324 0 47.813 0 40V-67.813c5.73 5.21 10.677 8.594 14.844 10.157 5.73 1.562 12.24 2.344 19.53 2.343v-132.812z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 43.75,\n      height: 270.052\n    },\n    origin: {\n      x: 0,\n      y: 200.365\n    },\n    align: \"left\"\n  },\n  DoClef: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M0 98.406V-97.688C0-118 5.99-134.275 17.97-146.516c11.978-12.24 27.603-18.36 46.874-18.36 10.937 0 19.53 3.126 25.78 9.376s9.376 14.583 9.376 25v107.813l-6.25-5.47c-4.167-3.645-10.287-7.42-18.36-11.327-8.072-3.907-16.796-5.86-26.17-5.86-11.46 0-21.486 4.427-30.08 13.282-8.593 8.854-12.89 19.53-12.89 32.03s4.297 23.308 12.89 32.423c8.594 9.115 18.62 13.672 30.08 13.672 9.374 0 18.098-1.822 26.17-5.468 8.073-3.646 14.193-7.292 18.36-10.938l6.25-6.25V132c0 9.896-3.125 18.1-9.375 24.61-6.25 6.51-14.844 9.765-25.78 9.765-19.272 0-34.897-6.25-46.876-18.75C5.99 135.125 0 118.72 0 98.405z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 100,\n      height: 331.251\n    },\n    origin: {\n      x: 0,\n      y: 164.876\n    },\n    align: \"left\"\n  },\n  FaClef: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M85.156-32v193.75c0 9.375-1.562 14.323-4.687 14.844-1.564 0-2.605-.52-3.126-1.563-.52-1.04-.782-2.603-.78-4.686V56.28c-8.335-8.332-19.793-12.5-34.376-12.5-17.71 0-31.77 3.907-42.188 11.72V-32c0-18.23 14.193-27.344 42.578-27.344 28.385 0 42.578 9.115 42.578 27.344zM98.438 93V-92.156c0-19.27 5.73-34.896 17.187-46.875 11.458-11.98 26.562-17.97 45.313-17.97 10.937 0 19.14 2.865 24.61 8.594 5.467 5.73 8.202 13.542 8.202 23.437v103.126l-5.47-4.687c-3.645-3.647-9.374-7.293-17.186-10.94-7.813-3.645-15.886-5.467-24.22-5.468-11.978 0-22.004 4.167-30.077 12.5-8.073 8.334-12.11 18.36-12.11 30.08 0 11.717 4.037 22.004 12.11 30.858s18.1 13.28 30.078 13.28c8.333 0 16.406-1.822 24.22-5.468 7.81-3.645 13.54-7.03 17.186-10.156l5.47-5.468V125.81c0 9.896-2.865 17.84-8.594 23.83-5.73 5.988-13.802 8.983-24.22 8.983-18.75 0-33.853-6.12-45.31-18.36-11.46-12.24-17.19-27.994-17.19-47.265z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 193.752,\n      height: 333.595\n    },\n    origin: {\n      x: 0.001,\n      y: 157.001\n    },\n    align: \"left\"\n  },\n  TrebleClef: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M291 202C95 202 0 70 0-70c0-161 122-276 238-371 9-8 8-9 7-19-6-33-11-85-11-131 0-83 19-183 78-249 16-18 41-38 52-38 9 0 30 22 42 40 32 48 52 116 52 186 0 122-66 224-152 305-5 5-7 5-5 15l20 116c2 14 2 14 23 14 118 0 193 91 193 193 0 91-54 159-135 191-11 4-12 4-10 13 9 50 23 126 23 171 0 136-104 160-157 160-121 0-152-78-152-130 0-50 32-92 85-92 49 0 77 38 77 82 0 46-29 68-54 75-18 5-25 8-25 13 0 11 21 24 64 24 47 0 127-15 127-133 0-38-12-107-22-161-1-10-3-9-12-7-16 3-36 5-55 5ZM64-16c0 111 90 189 230 189 16 0 32-2 45-4 12-3 13-3 11-11L310-81c-1-9-3-9-16-6-48 13-80 48-80 93 0 37 24 72 58 86 6 2 12 5 12 10s-3 9-10 9c-5 0-15-2-21-5-55-18-92-69-92-141 0-68 45-131 116-155 14-5 14-4 12-20l-17-102c-2-9-3-10-11-3-38 30-75 60-123 113C72-126 64-63 64-16Zm312-738c-49 0-106 76-106 201 0 26 1 53 4 74 2 10 5 11 11 6 63-55 139-127 139-216 0-44-22-65-48-65ZM353-94c-10 0-11 2-9 12l39 228c2 9 3 9 13 4 45-22 75-63 75-113 0-71-53-125-118-131Z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 671 * 0.8,\n      height: 1756 * 0.8\n    },\n    origin: {\n      x: 0,\n      y: 1098 * 0.8\n    },\n    align: \"left\"\n  },\n  TrebleClefSmall: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M218 151C71 151 0 52 0-52c0-121 92-207 178-279 7-6 7-7 6-14-5-25-9-64-9-98 0-63 15-138 59-187 12-13 31-29 39-29 7 0 22 17 31 30 25 36 39 88 39 140 0 92-49 168-114 229-3 3-5 4-3 11l15 87c1 11 1 11 17 11 88 0 145 68 145 144 0 68-41 119-101 143-9 4-9 3-8 10 7 38 17 95 17 129 0 102-78 120-118 120-90 0-114-59-114-98 0-37 24-69 64-69 37 0 58 28 58 61 0 35-22 51-40 57-14 4-19 6-19 10 0 8 15 17 48 17 35 0 95-11 95-99 0-29-9-81-16-121-1-7-3-7-9-5-12 2-28 3-42 3ZM48-12c0 83 68 142 173 142 12 0 24-2 33-3 9-2 10-2 9-9L233-61c-1-6-3-7-12-4-37 10-60 36-60 70 0 27 18 53 43 64 4 2 9 4 9 8 0 3-2 6-7 6-4 0-12-1-16-3-41-14-69-52-69-106 0-51 34-99 87-117 10-3 10-3 9-14l-13-77c-1-7-2-7-8-2-29 22-56 45-92 85C54-95 48-47 48-12Zm234-554c-37 0-80 58-80 151 0 20 1 40 4 56 1 7 3 8 8 4 47-41 104-95 104-162 0-33-16-49-36-49ZM265-70c-8-1-8 1-7 8l29 171c2 7 3 7 10 4 34-17 56-48 56-85 0-53-40-94-88-98Z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 671 * 0.6,\n      height: 1756 * 0.6\n    },\n    origin: {\n      x: 0,\n      y: 1098 * 0.6\n    },\n    align: \"left\"\n  },\n  Flat: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M7.813-204.406c4.166 0 6.25 5.208 6.25 15.625L12.5-10.657C33.854 13.302 54.167 25.28 73.438 25.28c9.374 0 14.062-4.686 14.062-14.06 0-6.25-1.042-11.72-3.125-16.407-2.083-4.688-7.03-9.766-14.844-15.235-7.81-5.47-13.02-8.984-15.624-10.547L27.344-45.81V-80.97c17.187 0 33.073 4.82 47.656 14.454C89.583-56.88 96.875-47.376 96.875-38c0 67.708-.26 101.562-.78 101.563-38.543 0-69.532-12.24-92.97-36.72C0-52.322-1.042-123.936 0-188c0-10.937 2.604-16.406 7.813-16.406z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 97.917,\n      height: 267.969\n    },\n    origin: {\n      x: 1.042,\n      y: 204.406\n    },\n    align: \"left\"\n  },\n  Mora: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M47.478-24c6.957 0 12.793 2.288 17.49 6.883C69.662-12.52 72-6.904 72-.267c0 6.64-2.337 12.352-7.033 17.118C60.27 21.618 54.435 24 47.477 24c-6.26 0-11.748-2.383-16.444-7.15C26.337 12.086 24 6.374 24-.265c0-6.638 2.337-12.255 7.033-16.85C35.73-21.713 41.217-24 47.478-24z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 48,\n      height: 48\n    },\n    origin: {\n      x: -24,\n      y: 24\n    },\n    align: \"left\"\n  },\n  Natural: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M7.906-166.563c-2.864 0-5.614.52-8.218 1.563v13.28l.78 56.25.782 78.907v85.157c.52 3.646 2.604 5.73 6.25 6.25l23.438-3.906 23.437-3.907v29.69c0 42.186-.26 63.54-.78 64.06l6.25 2.345c1.04.52 2.082.78 3.124.78 2.603 0 4.947-1.3 7.03-3.905L67.656-71.25c-.52-2.604-2.083-3.906-4.687-3.906-7.814 0-17.19 1.04-28.126 3.125l-19.53 3.124.78-38.28V-165c-2.604-1.042-5.323-1.562-8.188-1.563zM55.938-40v71.875l-41.407 7.03c0-48.436.262-72.655.783-72.655L55.938-40z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 70.311,\n      height: 330.469\n    },\n    origin: {\n      x: 0.312,\n      y: 166.563\n    },\n    align: \"left\"\n  },\n  Sharp: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"m41.725,-73.773c-5.421,-0.241-10.878,5.856-6.549,12.357L67.061,-20.473 61.264,-12.5 13.436,-71.199c-5.634,-5.934-16.988,1.032-11.232,9.783L50.756,0.182 2.203,61.416c-6.745,7.984 3.442,17.859 11.232,9.783L61.264,12.5l5.797,7.973-31.885,40.943c-5.578,6.844 5.588,16.005 11.594,9.783L77.568,33.154 108.367,71.199c4.894,6.717 17.343,-1.575 11.232,-9.783L87.715,20.473 93.873,12.5 141.34,71.199c6.725,7.67 17.509,-2.248 11.596,-9.783L104.02,0.182 152.936,-61.416c5.52,-7.02-5.541,-16.309-11.596,-9.783L93.873,-12.5l-6.158,-7.973 31.884766,-40.943c5.407,-7.045-5.505,-15.924-11.232,-9.783L77.568,-33.154 46.77,-71.199c-1.435,-1.708-3.238,-2.494-5.044922,-2.574zM77.568,-8.516 84.09,0.182 77.568,8.516 70.684,0.182Z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 154.646,\n      height: 147.987\n    },\n    origin: {\n      x: 0,\n      y: 74.098\n    },\n    align: \"left\"\n  },\n  OriscusAsc: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M50 30.25c0 12.5-3.125 21.354-9.375 26.562-3.125 2.605-7.813 3.907-14.063 3.907-3.125 0-5.99-.522-8.593-1.564-2.605-1.04-5.6-2.474-8.986-4.297C5.6 53.035 2.734 51.603.39 50.56c-2.343-1.04-5.338-2.474-8.984-4.296-3.646-1.823-6.77-3.256-9.375-4.297-2.603-1.043-5.468-1.564-8.593-1.564-6.25 0-10.937 1.563-14.062 4.688C-46.875 50.824-50 59.677-50 71.656v-106.25c0-13.02 3.125-21.875 9.375-26.562 3.125-2.604 7.813-3.906 14.063-3.907 3.125 0 5.99.52 8.593 1.563 2.605 1.042 5.73 2.474 9.376 4.297 3.646 1.823 6.51 2.995 8.594 3.516l10.938 5.468c6.25 3.126 11.458 4.69 15.624 4.69 6.25 0 10.938-1.564 14.063-4.69C46.875-55.426 50-64.02 50-76V30.25z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 100,\n      height: 147.656\n    },\n    origin: {\n      x: 50,\n      y: 76\n    },\n    align: \"left\"\n  },\n  OriscusDes: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M-50 30.844v-106.25c0 11.458 3.125 20.052 9.375 25.78 3.125 3.126 7.813 4.69 14.063 4.688 4.687 0 13.41-3.255 26.17-9.765 12.762-6.51 21.746-9.766 26.954-9.766 6.25 0 10.938 1.303 14.063 3.907C46.875-55.874 50-47.02 50-34V72.25c0-11.98-3.125-20.833-9.375-26.563C37.5 42.563 32.812 41 26.562 41 21.875 41 13.023 44.385 0 51.156c-4.167 2.604-8.594 4.948-13.28 7.032-4.69 2.083-9.116 3.124-13.283 3.124-6.25 0-10.937-1.302-14.062-3.906C-46.875 52.198-50 43.344-50 30.844z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 100,\n      height: 147.656\n    },\n    origin: {\n      x: 50,\n      y: 75.406\n    },\n    align: \"left\"\n  },\n  OriscusLiquescent: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M 19.055,78.887 C 20.242,78.487 21.532,77.890 22.925,77.097 24.318,76.304 26.700882,74.417 30.074,71.438 33.447,68.458 36.524,64.985 39.303,61.019 42.083,57.052 44.563,51.396 46.743,44.05 48.923,36.704 50.013,28.671 50.013,19.950525 L 50.013,-34.226 C 50.013,-54.464 42.074,-64.584 26.195,-64.584 20.248,-64.584 11.519,-61.410 0.007,-55.064 -11.506,-48.717 -20.235,-45.544 -26.182,-45.544 -34.515,-45.544 -40.568,-48.520 -44.340791,-54.473 -48.114,-60.426 -50.000,-67.369 -50.000,-75.303 L -50.000,30.07 C -50.000,49.909 -42.060754,59.829 -26.182,59.829 -21.023,59.829 -12.39,56.455 -0.284,49.709 11.822,42.963 20.648,39.59 26.195,39.59 29.369,40.777 30.362,44.25 29.17479,50.009 27.988,55.768 26.001,62.020829 23.216,68.767 z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 100,\n      height: 147.656\n    },\n    origin: {\n      x: 50,\n      y: 75.406\n    },\n    align: \"left\"\n  },\n  PodatusLower: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M-4.688-30.28c22.396 0 34.636-.262 36.72-.782 5.728-1.563 8.593-5.21 8.593-10.938H50v97.656c0 2.604-1.302 4.167-3.906 4.688-5.21.52-21.355.78-48.438.78-23.958 0-38.54-.26-43.75-.78-2.604 0-3.906-1.302-3.906-3.906v-82.032c0-3.646 1.302-5.468 3.906-5.468h2.344c2.604.52 15.625.78 39.063.78z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 100,\n      height: 103.124\n    },\n    origin: {\n      x: 50,\n      y: 42\n    },\n    align: \"left\"\n  },\n  PodatusUpper: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M-46.094-63.78c13.542 0 24.61 2.473 33.203 7.42C-4.298-51.41 0-43.99 0-34.093V62h-9.375c0-10.938-2.604-19.14-7.812-24.61-5.21-5.468-14.844-8.203-28.907-8.202-18.23 0-33.333 4.166-45.312 12.5v-75.782c0-19.79 15.104-29.687 45.312-29.687z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 91.406,\n      height: 125.781\n    },\n    origin: {\n      x: 91.406,\n      y: 63.781\n    },\n    align: \"right\"\n  },\n  Porrectus1: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M233.594 162.875c-58.855 0-107.032-6.25-144.53-18.75C34.895 125.895-11.46 99.855-50 66V-52.75C-21.354-24.625 26.302 6.885 92.97 41.78 123.697 57.928 163.54 66 212.5 66c21.354 0 34.635-9.896 39.844-29.688V151.94c0 7.29-6.25 10.937-18.75 10.937z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 302.344,\n      height: 215.627\n    },\n    origin: {\n      x: 50,\n      y: 52.75\n    },\n    align: \"left\"\n  },\n  Porrectus2: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M309.375 259.375c-50.52 0-110.938-22.396-181.25-67.188C48.437 141.667-10.938 94.272-50 50V-68.75C0-3.125 60.417 52.083 131.25 96.875c58.333 36.98 110.677 58.854 157.03 65.625h7.033c16.145 0 26.822-9.896 32.03-29.688v114.844c0 7.812-5.99 11.72-17.968 11.72z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 377.343,\n      height: 328.126\n    },\n    origin: {\n      x: 50,\n      y: 68.75\n    },\n    align: \"left\"\n  },\n  Porrectus3: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M309.375 355.78c-48.96-16.666-109.115-55.468-180.47-116.405C79.428 198.23 19.793 134.687-50 48.75V-70C20 40 94.104 103.79 135.25 148.063 190 200 230 230 288.28 258.906c4.168 2.083 8.334 3.125 12.5 3.125 12.5 0 21.355-10.937 26.564-32.81v114.06c0 9.376-3.386 14.063-10.156 14.064-2.084 0-4.688-.522-7.813-1.563z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 377.344,\n      height: 427.345\n    },\n    origin: {\n      x: 50,\n      y: 70\n    },\n    align: \"left\"\n  },\n  Porrectus4: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M350 453.438c-52.754-22.397-120-77.345-201.74-164.844C90.87 227.656 24.784 147.708-50 48.75V-70C-8.84-1.25 58.406 86.51 151.74 193.28c60.868 69.793 119.13 124.22 174.782 163.282 5.797 3.646 11.014 5.47 15.652 5.47 12.173 0 21.45-11.72 27.826-35.157V441.72c0 9.373-3.19 14.06-9.565 14.06-2.9 0-6.377-.78-10.435-2.342z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 420,\n      height: 525.78\n    },\n    origin: {\n      x: 50,\n      y: 70\n    },\n    align: \"left\"\n  },\n  PunctumCavum: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M0-60.906c33.333 0 50 9.635 50 28.906v94.53C39.062 51.595 22.396 46.126 0 46.126s-39.063 5.47-50 16.406V-32c0-19.27 16.667-28.906 50-28.906z\"\n      },\n      {\n        type: \"negative\",\n        data:\n          \"M.08-42.56c9.585.206 20.126.53 27.954 6.822 4.96 3.9 4.71 10.792 4.574 16.482v51.278C22.09 27.066 7.283 26.072.168 26.01c-7.72.23-21.895.935-32.616 4.674.04-19.197-.083-38.395.064-57.59.567-7.5 7.834-12.33 14.62-13.774 5.818-1.498 11.857-1.86 17.844-1.88z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 100,\n      height: 123.438\n    },\n    origin: {\n      x: 50,\n      y: 60.906\n    },\n    align: \"left\"\n  },\n  PunctumQuadratum: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M0-60.906c33.333 0 50 9.635 50 28.906v94.53C39.062 51.595 22.396 46.126 0 46.126s-39.063 5.47-50 16.406V-32c0-19.27 16.667-28.906 50-28.906z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 100,\n      height: 123.438\n    },\n    origin: {\n      x: 50,\n      y: 60.906\n    },\n    align: \"left\"\n  },\n  PunctumQuadratumLiquescent: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M0-36.5436c19.999799999999997 0 30 5.781 30 17.3436v56.717999999999996C23.437199999999997 30.956999999999997 13.4376 27.6756 0 27.6756s-23.4378 3.2819999999999996-30 9.843599999999999V-19.2c0-11.562 10.000200000000001-17.3436 30-17.3436z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 100,\n      height: 123.438\n    },\n    origin: {\n      x: 50,\n      y: 60.906\n    },\n    align: \"left\"\n  },\n  PunctumQuadratumAscLiquescent: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M-50 43.688V-61c4.167 7.292 12.76 10.938 25.78 10.938 9.376 0 20.053-1.563 32.032-4.688C31.773-60.48 45.833-71.677 50-88.344v117.97C43.75 42.645 32.812 51.5 17.187 56.186-.52 61.398-15.886 64-28.906 64-42.97 64-50 57.23-50 43.687z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 100,\n      height: 152.344\n    },\n    origin: {\n      x: 50,\n      y: 88.344\n    },\n    align: \"left\"\n  },\n  PunctumQuadratumDesLiquescent: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M-50-56.03c0-13.022 7.03-19.532 21.094-19.532 13.02 0 28.385 2.604 46.093 7.812C32.813-63.583 43.75-54.73 50-41.187V76C45.833 59.854 31.77 48.656 7.812 42.406c-11.98-3.125-22.656-4.687-32.03-4.687-13.022 0-21.615 3.905-25.782 11.718v-105.47z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 100,\n      height: 151.562\n    },\n    origin: {\n      x: 50,\n      y: 75.562\n    },\n    align: \"left\"\n  },\n  PunctumInclinatum: {\n    paths: [\n      {\n        type: \"positive\",\n        data: \"M0-75.78L50 0 0 75-50 0 0-75.78z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 100,\n      height: 150.78\n    },\n    origin: {\n      x: 50,\n      y: 75.78\n    },\n    align: \"left\"\n  },\n  PunctumInclinatumLiquescent: {\n    paths: [\n      {\n        type: \"positive\",\n        data: \"M 0,-53.164 35,-0.117 0,52.383 -35,-0.117 0,-53.164 z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 100,\n      height: 105.546\n    },\n    origin: {\n      x: 50,\n      y: 53.164\n    },\n    align: \"left\"\n  },\n  Quilisma: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M-50 34.938V-51c5.73 20.833 13.02 31.25 21.875 31.25 7.813 0 12.5-15.625 14.063-46.875 3.645 12.5 6.9 21.224 9.765 26.172s6.9 7.422 12.11 7.422c5.208 0 9.374-14.324 12.5-42.97 5.73 22.917 10.677 34.375 14.843 34.375 5.73 0 10.677-15.885 14.844-47.656v100c0 17.707-3.125 26.56-9.375 26.56-4.688 0-9.115-5.988-13.28-17.968-2.085 21.875-8.074 32.813-17.97 32.813-7.813 0-16.146-7.292-25-21.875-4.688 20.312-10.677 30.47-17.97 30.47-5.207 0-9.244-2.605-12.108-7.814C-48.568 47.698-50 41.708-50 34.938z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 100,\n      height: 150\n    },\n    origin: {\n      x: 50,\n      y: 89.282\n    },\n    align: \"left\"\n  },\n  TerminatingAscLiquescent: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M-9.375 40.22c0-11.98-4.948-17.97-14.844-17.97-10.936 0-19.53 3.646-25.78 10.938v-53.126c0-6.77 2.604-12.76 7.813-17.968 5.208-5.21 10.677-8.594 16.406-10.157 2.603-.52 5.207-.78 7.81-.78 3.647 0 7.032.78 10.157 2.343C-2.603-43.896 0-39.73 0-34V73.03h-9.375V40.22z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 49.999,\n      height: 121.873\n    },\n    origin: {\n      x: 49.999,\n      y: 48.843\n    },\n    align: \"right\"\n  },\n  TerminatingDesLiquescent: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M-9.375-48.156V-80.97H0V26.845c0 5.73-2.604 9.896-7.813 12.5-3.125 1.562-6.51 2.343-10.156 2.343-2.603 0-5.207-.26-7.81-.78-5.73-1.563-11.2-4.95-16.407-10.157C-47.398 25.542-50 19.292-50 12v-52.344c6.25 7.292 14.844 10.938 25.78 10.938 9.897 0 14.845-6.25 14.845-18.75z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 50,\n      height: 122.658\n    },\n    origin: {\n      x: 50,\n      y: 80.97\n    },\n    align: \"right\"\n  },\n  VerticalEpisemaAbove: {\n    paths: [\n      {\n        type: \"positive\",\n        data: \"M-8-4c2 3 6 4 8 4s6-1 8-4v-52c-2-3-6-4-8-4s-6 1-8 4z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 16,\n      height: 60\n    },\n    origin: {\n      x: 8,\n      y: 60\n    },\n    align: \"left\"\n  },\n  VerticalEpisemaBelow: {\n    paths: [\n      {\n        type: \"positive\",\n        data: \"M-8 56c2 3 6 4 8 4s6-1 8-4v-52c-2-3-6-4-8-4s-6 1-8 4z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 16,\n      height: 60\n    },\n    origin: {\n      x: 8,\n      y: 0\n    },\n    align: \"left\"\n  },\n  VirgaLong: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M50-38v285.156c0 6.77-2.344 10.937-7.03 12.5-1.564 0-2.605-.78-3.126-2.344-.52-1.562-.782-10.156-.782-25.78V54.186C29.168 45.334 16.146 40.907 0 40.907c-22.917 0-39.583 5.208-50 15.624V-38c0-19.27 16.667-28.906 50-28.906S50-57.27 50-38z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 100,\n      height: 326.562\n    },\n    origin: {\n      x: 50,\n      y: 66.906\n    },\n    align: \"left\"\n  },\n  VirgaShort: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M50-38v211.72c0 7.29-2.344 11.457-7.03 12.5-1.564 0-2.606-.783-3.126-2.345-.52-1.563-.782-10.156-.782-25.78V54.187C29.167 45.332 16.146 40.906 0 40.906c-22.917 0-39.583 5.21-50 15.625V-38c0-19.27 16.667-28.906 50-28.906S50-57.27 50-38z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 100,\n      height: 253.126\n    },\n    origin: {\n      x: 50,\n      y: 66.906\n    },\n    align: \"left\"\n  },\n  Virgula: {\n    paths: [\n      {\n        type: \"positive\",\n        data:\n          \"M8.178-55.66c0-22.137 12.092-33.2 36.287-33.2 11.835 0 23.53 5.66 35.108 16.98C91.15-60.547 96.94-41.766 96.94-15.534c0 53.515-31.646 87.487-94.937 101.895-2.048-2.06-3.077-5.146-3.077-9.273 0-1.03.247-1.8.76-2.316 42.71-19.027 64.075-41.678 64.075-67.92 0-11.322-2.325-20.326-6.945-27.016-4.62-6.69-9.52-11.052-14.676-13.11-5.147-2.048-11.836-3.85-20.07-5.403C12.81-39.707 8.18-45.37 8.18-55.66z\"\n      }\n    ],\n    bounds: {\n      x: 0,\n      y: 0,\n      width: 98.014,\n      height: 175.221\n    },\n    origin: {\n      x: 1.074 - 98.014 / 2, // centered\n      y: 88.86\n    },\n    align: \"left\"\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/Exsurge.Glyphs.js","//\n// Author(s):\n// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>\n//\n// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n//\n\nimport {\n  getCssForProperties, Point,\n  Rect\n} from \"./Exsurge.Core.js\";\nimport { Glyphs } from \"./Exsurge.Glyphs.js\";\nimport { language } from \"./Exsurge.Text.js\";\nimport { addAccent } from \"./addAccent.js\";\nimport { makeLigature } from \"./makeLigature.js\";\nimport { greextraGlyphs } from \"./greextraGlyphs.js\";\n\nfunction getFontFilenameForProperties(properties = {}, url = \"{}\") {\n  var italic = properties[\"font-style\"] === \"italic\" ? \"Italic\" : \"\",\n    bold = properties[\"font-weight\"] === \"bold\" ? \"Bold\" : \"\";\n  return url.replace(\n    \"{}\",\n    `${italic || bold ? `${bold}${italic}` : `Regular`}`\n  );\n}\n\n// load in the web font for special chant characters here:\n// var __exsurgeCharactersFont = require(\"url?limit=30000!../assets/fonts/ExsurgeChar.otf\")\n\nconst canAccessDOM = typeof document !== \"undefined\";\n\nconst __getNeumeFromSvgElem = (score, elem) => {\n  let note =\n    score.notes[\n      elem.parentElement\n        .querySelector(\"[element-index]\")\n        .getAttribute(\"element-index\")\n    ];\n  return note.neume || note;\n};\n\n// for positioning markings on notes\nexport var MarkingPositionHint = {\n  Default: 0,\n  Above: 1,\n  Below: 2\n};\n\n/**\n * List of types of text and their defaults relative to lyrics\n * @type Array\n */\nexport const TextTypes = {\n  supertitle: {\n    display: \"Supertitle\",\n    defaultSize: (size) => (size * 7) / 6, // 14pt\n    containedInScore: (score) => score.titles.hasSupertitle(),\n    getFromScore: (score) => score.titles.supertitle\n  },\n  title: {\n    display: \"Title\",\n    defaultSize: (size) => (size * 3) / 2, // 18pt\n    containedInScore: (score) => score.titles.hasTitle(),\n    getFromScore: (score) => score.titles.title\n  },\n  subtitle: {\n    display: \"Subtitle\",\n    defaultSize: (size) => size, // 12pt\n    containedInScore: (score) => score.titles.hasSubtitle(),\n    getFromScore: (score) => score.titles.subtitle\n  },\n  leftRight: {\n    display: \"Left / Right Text\",\n    cssClass: \"textLeftRight\",\n    defaultSize: (size) => size * 0.9,\n    containedInScore: (score) =>\n      score.titles.hasTextLeft() || score.titles.hasTextRight(),\n    getFromScore: (score, elem) => score.titles[elem.extraClass],\n    getFromSvgElem: (score, elem) =>\n      score.titles[\n        elem.classList.contains(\"textRight\") ? \"textRight\" : \"textLeft\"\n      ]\n  },\n  annotation: {\n    display: \"Annotation\",\n    defaultSize: (size) => (size * 2) / 3,\n    containedInScore: (score) =>\n      !!score.annotation,\n    getFromScore: (score, { elementIndex = 0 }) =>\n      score.annotation &&\n      (score.annotation.annotations\n        ? score.annotation.annotations[elementIndex]\n        : score.annotation),\n    getFromSvgElem: (score, elem) =>\n      score.annotation &&\n      (score.annotation.annotations\n        ? score.annotation.annotations[Array.from(elem.parentElement.querySelectorAll(\"text.annotation\")).indexOf(elem)]\n        : score.annotation)\n  },\n  dropCap: {\n    display: \"Drop Cap\",\n    defaultSize: (size) => size * 4,\n    containedInScore: (score) => !!score.dropCap,\n    getFromScore: (score) => score.dropCap\n  },\n  al: {\n    display: \"Above Staff\",\n    cssClass: \"aboveLinesText\",\n    defaultSize: (size) => size,\n    containedInScore: (score) => score.hasAboveLinesText,\n    getFromScore: (score, elem) =>\n      score.notations[elem.notation.notationIndex].alText[elem.alIndex],\n    getFromSvgElem: (score, elem) =>\n      __getNeumeFromSvgElem(score, elem).alText[\n        elem.getAttribute(\"al-index\") || 0\n      ]\n  },\n  choralSign: {\n    display: \"Choral Sign\",\n    size: (ctxt) => ctxt.staffInterval * 1.5,\n    containedInScore: (score) => false,\n    getFromScore: (score, elem) =>\n      score.notes[elem.note.elementIndex].choralSign\n  },\n  lyric: {\n    display: \"Lyric\",\n    defaultSize: (size) => size * 0.9,\n    containedInScore: (score) => score.hasLyrics,\n    getFromScore: (score, elem) =>\n      score.notations[elem.notation.notationIndex].lyrics[elem.lyricIndex],\n    getFromSvgElem: (score, elem) =>\n      __getNeumeFromSvgElem(score, elem).lyrics[\n        elem.getAttribute(\"lyric-index\") || 0\n      ]\n  },\n  translation: {\n    display: \"Translation\",\n    defaultSize: (size) => size * 0.75,\n    containedInScore: (score) => score.hasTranslations,\n    getFromScore: (score, elem) =>\n      score.notations[elem.notation.notationIndex].translationText[\n        elem.translationIndex\n      ],\n    getFromSvgElem: (score, elem) =>\n      __getNeumeFromSvgElem(score, elem).translationText[\n        elem.getAttribute(\"translation-index\") || 0\n      ]\n  }\n};\nexport const TextTypesByClass = {};\nObject.entries(TextTypes).forEach(([key, entry]) => {\n  let cssClass = (entry.cssClass = entry.cssClass || key);\n  entry.key = key;\n  TextTypesByClass[cssClass] = entry;\n});\n\nexport const DefaultTrailingSpace = (ctxt) =>\n  ctxt.intraNeumeSpacing * ctxt.interSyllabicMultiplier;\nDefaultTrailingSpace.isDefault = true;\n\nexport let GlyphCode = {\n  None: \"None\",\n\n  AcuteAccent: \"AcuteAccent\",\n  GraveAccent: \"GraveAccent\",\n  Circle: \"Circle\",\n  Semicircle: \"Semicircle\",\n  ReversedSemicircle: \"ReversedSemicircle\",\n  Stropha: \"Stropha\",\n  StrophaLiquescent: \"StrophaLiquescent\",\n\n  BeginningAscLiquescent: \"BeginningAscLiquescent\",\n  BeginningDesLiquescent: \"BeginningDesLiquescent\",\n\n  CustosDescLong: \"CustosDescLong\",\n  CustosDescShort: \"CustosDescShort\",\n  CustosLong: \"CustosLong\",\n  CustosShort: \"CustosShort\",\n\n  // clefs and other markings\n  DoClef: \"DoClef\",\n  FaClef: \"FaClef\",\n  TrebleClef: \"TrebleClef\",\n  TrebleClefSmall: \"TrebleClefSmall\",\n  Flat: \"Flat\",\n  Mora: \"Mora\",\n  Natural: \"Natural\",\n  OriscusAsc: \"OriscusAsc\",\n  OriscusDes: \"OriscusDes\",\n  OriscusLiquescent: \"OriscusLiquescent\",\n\n  PodatusLower: \"PodatusLower\",\n  PodatusUpper: \"PodatusUpper\",\n\n  Porrectus1: \"Porrectus1\", // 1 staff line difference,\n  Porrectus2: \"Porrectus2\", // 2 lines difference, etc...\n  Porrectus3: \"Porrectus3\",\n  Porrectus4: \"Porrectus4\",\n\n  PunctumCavum: \"PunctumCavum\",\n  PunctumQuadratum: \"PunctumQuadratum\",\n  PunctumQuadratumLiquescent: \"PunctumQuadratumLiquescent\",\n  PunctumQuadratumAscLiquescent: \"PunctumQuadratumAscLiquescent\",\n  PunctumQuadratumDesLiquescent: \"PunctumQuadratumDesLiquescent\",\n  PunctumInclinatum: \"PunctumInclinatum\",\n  PunctumInclinatumLiquescent: \"PunctumInclinatumLiquescent\",\n  Quilisma: \"Quilisma\",\n\n  Sharp: \"Sharp\",\n  TerminatingAscLiquescent: \"TerminatingAscLiquescent\",\n  TerminatingDesLiquescent: \"TerminatingDesLiquescent\",\n  VerticalEpisemaAbove: \"VerticalEpisemaAbove\",\n  VerticalEpisemaBelow: \"VerticalEpisemaBelow\",\n  VirgaLong: \"VirgaLong\",\n  VirgaShort: \"VirgaShort\",\n  Virgula: \"Virgula\",\n\n  UpperBrace: \"UpperBrace\"\n}; // GlyphCode\n\nexport var QuickSvg = {\n  // namespaces\n  ns: \"http://www.w3.org/2000/svg\",\n  xmlns: \"https://www.w3.org/2000/xmlns/\",\n  xlink: \"http://www.w3.org/1999/xlink\",\n\n  hasDOMAccess: function () {\n    return canAccessDOM;\n  },\n\n  // create the root level svg object\n  svg: function (width, height) {\n    var node = document.createElementNS(this.ns, \"svg\");\n\n    node.setAttribute(\"xmlns\", this.ns);\n    node.setAttribute(\"version\", \"1.1\");\n    node.setAttributeNS(this.xmlns, \"xmlns:xlink\", this.xlink);\n\n    node.setAttribute(\"width\", width);\n    node.setAttribute(\"height\", height);\n\n    // create the defs element\n    var defs = document.createElementNS(this.ns, \"defs\");\n    node.appendChild(defs);\n\n    node.defs = defs;\n\n    node.clearNotations = function () {\n      // clear out all children except defs\n      node.removeChild(defs);\n\n      while (node.hasChildNodes()) node.removeChild(node.lastChild);\n\n      node.appendChild(defs);\n    };\n\n    return node;\n  },\n\n  rect: function (width, height) {\n    var node = document.createElementNS(this.ns, \"rect\");\n\n    node.setAttribute(\"width\", width);\n    node.setAttribute(\"height\", height);\n\n    return node;\n  },\n\n  line: function (x1, y1, x2, y2) {\n    var node = document.createElementNS(this.ns, \"line\");\n\n    node.setAttribute(\"x1\", x1);\n    node.setAttribute(\"y1\", y1);\n    node.setAttribute(\"x2\", x2);\n    node.setAttribute(\"y2\", y2);\n\n    return node;\n  },\n\n  g: function () {\n    var node = document.createElementNS(this.ns, \"g\");\n\n    return node;\n  },\n\n  text: function () {\n    var node = document.createElementNS(this.ns, \"text\");\n\n    return node;\n  },\n\n  tspan: function (str) {\n    var node = document.createElementNS(this.ns, \"tspan\");\n    node.textContent = str;\n\n    return node;\n  },\n\n  // nodeRef should be the id of the object in defs (without the #)\n  use: function (nodeRef) {\n    var node = document.createElementNS(this.ns, \"use\");\n    node.setAttributeNS(this.xlink, \"xlink:href\", \"#\" + nodeRef);\n\n    return node;\n  },\n\n  svgFragmentForGlyph: function (glyph, fillColor = \"#000\") {\n    var svgSrc = \"\";\n    for (var i = 0; i < glyph.paths.length; ++i) {\n      var path = glyph.paths[i];\n      svgSrc += QuickSvg.createFragment(path.data ? \"path\" : \"g\", {\n        d: path.data || undefined,\n        fill: path.type === \"negative\" ? \"#fff\" : fillColor\n      });\n    }\n    return svgSrc;\n  },\n\n  nodesForGlyph: function (glyph, functionName = \"createNode\", fillColor = \"#000\") {\n    var nodes = [];\n    for (var i = 0; i < glyph.paths.length; ++i) {\n      var path = glyph.paths[i];\n      let props = {};\n      if (path.data) props.d = path.data;\n      //if (path.type === \"negative\") props.fill = \"#fff\";\n      props.fill = path.type === \"negative\" ? \"#fff\" : fillColor;\n      nodes.push(QuickSvg[functionName](path.data ? \"path\" : \"g\", props));\n    }\n    return nodes;\n  },\n\n  createNode: function (name, attributes, children) {\n    var node = document.createElementNS(this.ns, name);\n    if (attributes && attributes.source) {\n      node.source = attributes.source;\n      delete attributes.source;\n    }\n    for (var attr in attributes) {\n      if (\n        attributes.hasOwnProperty(attr) &&\n        typeof attributes[attr] !== \"undefined\"\n      ) {\n        var val = attributes[attr];\n        var match = attr.match(/^([^:]+):([^:]+)$/);\n        if (match) {\n          node.setAttributeNS(this[match[1]], match[2], val);\n        } else {\n          node.setAttribute(attr, val);\n        }\n      }\n    }\n    if (children) {\n      if (typeof children === \"string\") {\n        node.textContent = children;\n      } else if (children.constructor === [].constructor) {\n        for (var i = 0; i < children.length; ++i) {\n          node.appendChild(children[i]);\n        }\n      } else {\n        node.appendChild(children);\n      }\n    }\n    return node;\n  },\n\n  createSvgTree(name, props, ...children) {\n    if (\"class\" in props) {\n      props.className = props.class;\n      delete props.class;\n    }\n    if (children.length === 1 && children[0] instanceof Array) {\n      children = children[0];\n    }\n    const convertKeysToCamelCase = (obj) => {\n      for (let key of Object.keys(obj)) {\n        if (/[-:][a-z]/.test(key)) {\n          if (/^\\w+-index$/.test(key)) continue;\n          let camelCase = key.replace(/[-:]([a-z])/g, (whole, letter) =>\n            letter.toUpperCase()\n          );\n          obj[camelCase] = obj[key];\n          delete obj[key];\n        }\n      }\n    };\n    convertKeysToCamelCase(props);\n    if (props.style) convertKeysToCamelCase(props.style);\n    let source = props.source;\n    if (source && source.sourceGabc) {\n      props[\"source-gabc\"] = source.sourceGabc;\n    }\n    return { name, props, children };\n  },\n\n  createFragment: function (name, attributes, child) {\n    if (child === undefined || child === null) child = \"\";\n\n    var fragment = \"<\" + name + \" \";\n\n    for (var attr in attributes) {\n      if (\n        attributes.hasOwnProperty(attr) &&\n        typeof attributes[attr] !== \"undefined\"\n      )\n        fragment += attr + '=\"' + attributes[attr] + '\" ';\n    }\n\n    fragment += \">\" + child + \"</\" + name + \">\";\n\n    return fragment;\n  },\n\n  parseFragment: function (fragment) {\n    // create temporary holder\n    var well = document.createElement(\"svg\");\n\n    // act as a setter if svg is given\n    if (fragment) {\n      var container = this.g();\n\n      // dump raw svg\n      // do this to allow the browser to automatically create svg nodes?\n      well.innerHTML =\n        \"<svg>\" +\n        fragment\n          .replace(/\\n/, \"\")\n          .replace(/<(\\w+)([^<]+?)\\/>/g, \"<$1$2></$1>\") +\n        \"</svg>\";\n\n      // transplant nodes\n      for (var i = 0, il = well.firstChild.childNodes.length; i < il; i++)\n        container.appendChild(well.firstChild.firstChild);\n\n      return container;\n    }\n  },\n\n  translate: function (node, x, y) {\n    node.setAttribute(\"transform\", \"translate(\" + x + \",\" + y + \")\");\n    return node;\n  },\n\n  scale: function (node, sx, sy) {\n    node.setAttribute(\"transform\", \"scale(\" + sx + \",\" + sy + \")\");\n    return node;\n  }\n};\n\nexport var TextMeasuringStrategy = {\n  // shapes\n  Svg: 0,\n  Canvas: 1,\n  OpenTypeJS: 2\n};\n\n/*\n * ChantContext\n */\nexport class ChantContext {\n  constructor(\n    textMeasuringStrategy = QuickSvg.hasDOMAccess()\n      ? TextMeasuringStrategy.Canvas\n      : TextMeasuringStrategy.OpenTypeJS\n  ) {\n    /**\n     * font dictionary\n     * @type {{ [key: string]: import('opentype.js').Font }}\n     */\n    this.fontDictionary = undefined;\n    this.staffLineCount = 4;\n    this.textMeasuringStrategy = textMeasuringStrategy;\n    this.getFontFilenameForProperties = getFontFilenameForProperties;\n    this.defs = {};\n    this.makeDefs = [];\n    if (QuickSvg.hasDOMAccess()) {\n      this.defsNode = QuickSvg.createNode(\"defs\");\n    }\n\n    // font styles\n    this.textStyles = {};\n    this.textColor = \"#0d0\";\n    this.setFont(\"'Palatino Linotype', 'Book Antiqua', Palatino, serif\", 16);\n\n    this.rubricColor = \"#d00\";\n    this.specialCharProperties = {\n      \"font-family\": \"'Exsurge Characters'\",\n      fill: this.rubricColor,\n      class: 'rubric'\n    };\n    this.textBeforeSpecialChar = \"\";\n    this.textAfterSpecialChar = \".\";\n    this.specialCharMap = {\n      \"℣\": 'v',\n      \"℟\": 'r',\n      \"+\": \"+\",\n      \"*\": \"*\"\n    };\n    this.plusProperties = {};\n    this.asteriskProperties = {};\n    this.specialCharText = (char) => this.specialCharMap[char] || char;\n\n    this.fontStyleDictionary = {\n      b: { \"font-weight\": \"bold\" },\n      i: { \"font-style\": \"italic\" },\n      u: { \"text-decoration\": \"underline\" },\n      ul: { \"text-decoration\": \"underline\" },\n      c: { fill: this.rubricColor, class: 'rubric' },\n      sc: { \"font-variant\": \"small-caps\" },\n      v: {},\n      e: { \"font-style\": \"italic\", \"font-size\": \"90%\" }\n    };\n\n    this.markupSymbolDictionary = {\n      \"*\": \"b\",\n      \"_\": \"i\",\n      \"^\": \"c\",\n      \"%\": \"sc\"\n    };\n\n    this.textStyles.al.prefix = \"<i>\";\n\n    this.textStyles.translation.prefix = \"<i>\";\n\n    this.textStyles.dropCap.padding = 1; // minimum padding on either side of drop cap in staffIntervals\n\n    this.textStyles.annotation.padding = 1; // minimum padding on either side of annotation in staffIntervals\n\n    this.minLedgerSeparation = 2; // multiple of staffInterval\n    this.minSpaceAboveStaff = 2; // multiple of staffInterval\n    this.minSpaceBelowStaff = 1; // multiple of staffInterval\n    this.spaceBetweenSystems = 1.5; // multiple of staffInterval\n\n    // everything depends on the scale of the punctum\n    this.glyphPunctumWidth = Glyphs.PunctumQuadratum.bounds.width;\n    this.glyphPunctumHeight = Glyphs.PunctumQuadratum.bounds.height;\n\n    // max space to add between notations when justifying, in multiples of this.staffInterval\n    this.maxExtraSpaceInStaffIntervals = 0.5;\n\n    // for keeping track of the clef\n    this.activeClef = null;\n\n    this.neumeLineColor = \"#000\";\n    this.staffLineColor = \"#000\";\n    this.dividerLineColor = \"#000\";\n\n    this.defaultLanguage = language.latin;\n\n    // calculate the pixel ratio for drawing to a canvas\n    this.pixelRatio =\n      typeof window === 'undefined'\n        ? 1.0\n        : (window.devicePixelRatio || 1.0);\n\n    //this.canvasCtxt.scale(this.pixelRatio, this.pixelRatio);\n\n    if (textMeasuringStrategy === TextMeasuringStrategy.Svg) {\n      this.svgTextMeasurer = QuickSvg.svg(0, 0);\n      this.svgTextMeasurer.setAttribute(\"id\", \"TextMeasurer\");\n      this.svgTextMeasurer.setAttribute(\"style\", \"position:absolute\");\n      document.body.insertBefore(\n        this.svgTextMeasurer,\n        document.body.firstChild\n      );\n    } else if (textMeasuringStrategy === TextMeasuringStrategy.Canvas) {\n      this.makeCanvasIfNeeded();\n    }\n\n    // for connecting neume syllables...\n    this.syllableConnector = \"-\";\n\n    // set whether to scale the def tags (scaleDefs = true) or the use tags.\n    this.scaleDefs = true;\n\n    // fixme: for now, we just set these using the glyph scales as noted above, presuming a\n    // staff line size of 0.5 in. Really what we should do is scale the punctum size based\n    // on the text metrics, right? 1 punctum ~ x height size?\n    this.setGlyphScaling(1.0 / 16.0);\n\n    // minimum space between puncta of different syllables, in multiples of this.intraNeumeSpacing\n    this.interSyllabicMultiplier = 2.5;\n\n    // space between an accidental and the following note, in multiples of this.intraNeumeSpacing\n    this.accidentalSpaceMultiplier = 2;\n\n    // space added between puncta of different words, in multiples of this.intraNeumeSpacing\n    this.interVerbalMultiplier = 1;\n\n    this.drawGuides = false;\n    this.drawDebuggingBounds = true;\n\n    // we keep track of where we are in processing notations, so that\n    // we can maintain the context for notations to know about.\n    //\n    // these are only gauranteed to be valid during the performLayout phase!\n    this.activeNotations = null;\n    this.currNotationIndex = -1;\n\n    this.minSyllablesLastLine = 0;\n    this.minNotesLastLine = 0;\n\n    // chant notation elements are normally separated by a minimum fixed amount of space\n    // on the staff line. It can happen, however, that two text elements are almost close\n    // enough to merge, only to be separated much more by the required hyphen (or other\n    // connecting string).\n    //\n    // This tolerance value allows a little bit of flexibility to merge two close lyrical\n    // elements, thus bringing the chant notation elements a bit closer than otherwise\n    // would be normally allowed.\n    //\n    // condensing tolerance is a percentage value (0.0-1.0, inclusive) that indicates\n    // how much the default spacing can shrink. E.g., a value of 0.20 allows the layout\n    // engine to separate two glyphs by only 80% of the normal inter-neume spacing value.\n    this.condensingTolerance = 0.3;\n\n    // if auto color is true, then exsurge tries to automatically colorize\n    // some elements of the chant (directives become rubric color, etc.)\n    this.autoColor = true;\n\n    this.useExtraTextOnly = true;\n\n    this.noteIdPrefix = 'note-';\n\n    this.insertFontsInDoc();\n    this.setMergeAnnotationWithTextLeft(true);\n  }\n\n  /**\n   * convert a staff position counting from the first space below the staff (gabc notation \"c\")\n   * into a position counting from the middle space (variable based on how many staff lines there are)\n   * @param {number} staffPosition \n   * @returns {number}\n   */\n  convertStaffPositionToSymmetric(staffPosition) {\n    return staffPosition - this.staffLineCount;\n  }\n\n  convertSymmetricStaffPosition(staffPositionSymmetric) {\n    return staffPositionSymmetric + this.staffLineCount;\n  }\n\n  /**\n   * \n   * @param {*} properties \n   * @param {string} fontFamily \n   * @returns {import('opentype.js').Font | undefined}\n   */\n  getFontForProperties(properties = {}, fontFamily) {\n    let key = this.getFontFilenameForProperties(properties),\n      keyWithFontFamily = this.getFontFilenameForProperties(properties, fontFamily);\n    return (\n      this.fontDictionary &&\n      (this.fontDictionary[keyWithFontFamily] ||\n        this.fontDictionary[fontFamily] ||\n        this.fontDictionary.Regular)\n    );\n  }\n\n  /**\n   * \n   * @param {string} font : ;\n   * @param {number} size \n   * @param {any} baseStyle \n   * @param {{ [key: string]: import('opentype.js').Font }} fontDictionary \n   */\n  setFont(font, size = 16, baseStyle = {}, fontDictionary) {\n    for (let [key, textType] of Object.entries(TextTypes)) {\n      let textStyle = (this.textStyles[key] = this.textStyles[key] || {});\n      textStyle.size = textType.defaultSize\n        ? textType.defaultSize(size, this)\n        : textType.size(this);\n      textStyle.font = font;\n      textStyle.color = this.textColor || \"#000\";\n    }\n\n    this.baseTextStyle = baseStyle;\n\n    if (fontDictionary) {\n      this.textMeasuringStrategy = TextMeasuringStrategy.OpenTypeJS;\n      this.fontDictionary = fontDictionary;\n    }\n  }\n\n  setRubricColor(color) {\n    this.rubricColor = color;\n    this.specialCharProperties.fill = color;\n    this.fontStyleDictionary.c.fill = color;\n  }\n\n  setMergeAnnotationWithTextLeft(merge) {\n    this.mergeAnnotationWithTextLeft = merge ? __mergeAnnotationWithTextLeft : undefined;\n  }\n\n  setScaleDefs(scaleDefs) {\n    scaleDefs = !!scaleDefs;\n    if (this.scaleDefs !== scaleDefs) {\n      this.scaleDefs = scaleDefs;\n      this.setGlyphScaling(this.glyphScaling);\n    }\n  }\n\n  createStyleCss() {\n    var style = \"\";\n    for (let [key, textType] of Object.entries(TextTypes)) {\n      var cssClass = textType.cssClass,\n        { color, font, size } = this.textStyles[key];\n      style += `svg.Exsurge .${cssClass}{fill:${color};font-family:${font};font-size:${size}px;font-kerning:normal}`;\n    }\n    return style;\n  }\n\n  createStyleNode() {\n    var node = QuickSvg.createNode(\"style\", {});\n    node.textContent = this.createStyleCss();\n    return node;\n  }\n\n  createStyleTree() {\n    return { name: \"style\", props: {}, children: [this.createStyleCss()] };\n  }\n\n  createStyle() {\n    return \"<style>\" + this.createStyleCss() + \"</style>\";\n  }\n\n  updateHyphenWidth() {\n    // measure the size of a hyphen for the lyrics\n    var hyphen = new Lyric(\n      this,\n      this.syllableConnector,\n      LyricType.SingleSyllable\n    );\n    var multiplier =\n      this.minLyricWordSpacing /\n        (this.hyphenWidth || this.minLyricWordSpacing) || 1;\n    this.hyphenWidth = hyphen.bounds.width;\n\n    this.minLyricWordSpacing = multiplier * this.hyphenWidth;\n  }\n\n  setStaffHeight(staffHeight) {\n    this.setGlyphScaling(staffHeight / 600);\n  }\n\n  setGlyphScaling(glyphScaling) {\n    this.glyphScaling = glyphScaling;\n\n    this.staffInterval = this.glyphPunctumWidth * this.glyphScaling;\n\n    // setup the line weights for the various elements.\n    this.staffLineWeight = Math.ceil((5 * this.staffInterval) / 8) / 5;\n    this.neumeLineWeight = this.staffLineWeight; // the weight of connecting lines in the glyphs.\n    this.dividerLineWeight = this.neumeLineWeight; // of quarter bar, half bar, etc.\n    this.episemaLineWeight = this.neumeLineWeight * 1.25; // of horizontal episemata\n\n    this.intraNeumeSpacing = this.staffInterval / 2.0;\n\n    while (this.defsNode && this.defsNode.firstChild)\n      this.defsNode.removeChild(this.defsNode.firstChild);\n    for (var i = 0; i < this.makeDefs.length; ++i) {\n      this.makeDefs[i]();\n    }\n\n    this.updateHyphenWidth();\n  }\n\n  calculateHeightFromStaffPosition(staffPosition) {\n    return -staffPosition * this.staffInterval;\n  }\n\n  insertFontsInDoc() {\n    if (!canAccessDOM) return;\n\n    var styleElement = document.getElementById(\"exsurge-fonts\");\n\n    if (styleElement === null) {\n      // create it since it doesn't exist yet.\n      styleElement = document.createElement(\"style\");\n      styleElement.id = \"exsurge-fonts\";\n\n      // styleElement.appendChild(document.createTextNode(\"@font-face{font-family: 'Exsurge Characters';font-weight: normal;font-style: normal;src: url(\" + __exsurgeCharactersFont + \") format('opentype');}\"));\n\n      document.head.appendChild(styleElement);\n    }\n  }\n\n  // returns the next neume starting at this.currNotationIndex, or null\n  // if there isn't a neume after this one...\n  findNextNeume() {\n    if (typeof this.currNotationIndex === \"undefined\")\n      throw \"findNextNeume() called without a valid currNotationIndex set\";\n\n    for (var i = this.currNotationIndex + 1; i < this.notations.length; i++) {\n      var notation = this.notations[i];\n\n      if (notation.isNeume && !notation.hasNoWidth) return notation;\n    }\n\n    return null;\n  }\n\n  makeCanvasIfNeeded() {\n    if (!this.canvas) {\n      this.canvas = document.createElement(\"canvas\");\n      this.canvasCtxt = this.canvas.getContext(\"2d\");\n    }\n  }\n\n  setCanvasSize(width, height, scale = 1) {\n    this.makeCanvasIfNeeded();\n\n    this.canvas.style.width = width * scale + \"px\";\n    this.canvas.style.height = height * scale + \"px\";\n    scale *= this.pixelRatio;\n    this.canvas.width = width * scale;\n    this.canvas.height = height * scale;\n\n    this.canvasCtxt.setTransform(scale, 0, 0, scale, 0, 0);\n  }\n}\n\n/*\n * ChantLayoutElement\n */\nexport class ChantLayoutElement {\n  constructor() {\n    this.bounds = new Rect();\n    this.origin = new Point(0, 0);\n\n    this.selected = false;\n    this.highlighted = false;\n  }\n\n  // draws the element on an html5 canvas\n  draw(ctxt) {\n    throw \"ChantLayout Elements must implement draw(ctxt)\";\n  }\n\n  // returns svg element\n  createSvgNode(ctxt) {\n    throw \"ChantLayout Elements must implement createSvgNode(ctxt)\";\n  }\n\n  // returns svg code for the element, used for printing support\n  createSvgFragment(ctxt) {\n    throw \"ChantLayout Elements must implement createSvgFragment(ctxt)\";\n  }\n}\n\nexport class DividerLineVisualizer extends ChantLayoutElement {\n  constructor(ctxt, staffPosition0, staffPosition1, divider) {\n    super();\n\n    this.divider = divider;\n\n    var y0 = ctxt.calculateHeightFromStaffPosition(staffPosition0);\n    var y1 = ctxt.calculateHeightFromStaffPosition(staffPosition1);\n\n    if (y0 > y1) {\n      var temp = y0;\n      y0 = y1;\n      y1 = temp;\n    }\n\n    this.bounds.x = 0;\n    this.bounds.y = y0;\n    this.bounds.width = ctxt.dividerLineWeight;\n    this.bounds.height = y1 - y0;\n\n    this.origin.x = this.bounds.width / 2;\n    this.origin.y = y0;\n  }\n\n  draw(ctxt) {\n    var canvasCtxt = ctxt.canvasCtxt;\n\n    canvasCtxt.fillStyle = ctxt.dividerLineColor;\n\n    canvasCtxt.fillRect(\n      this.bounds.x,\n      this.bounds.y,\n      ctxt.dividerLineWeight,\n      this.bounds.height\n    );\n  }\n\n  getSvgProps(ctxt) {\n    let props = {\n      x: this.bounds.x,\n      y: this.bounds.y,\n      width: ctxt.dividerLineWeight,\n      height: this.bounds.height,\n      fill: ctxt.dividerLineColor,\n      class: \"dividerLine\"\n    };\n    if (this.divider) {\n      if (this.divider.selected) props.class += \" selected\";\n      props[\"source-index\"] = this.divider.sourceIndex;\n      props[\"element-index\"] = this.divider.elementIndex;\n      props.source = this.divider;\n    }\n    return props;\n  }\n\n  createSvgNode(ctxt) {\n    return QuickSvg.createNode(\"rect\", this.getSvgProps(ctxt));\n  }\n  createSvgTree(ctxt) {\n    return QuickSvg.createSvgTree(\"rect\", this.getSvgProps(ctxt));\n  }\n\n  createSvgFragment(ctxt) {\n    return QuickSvg.createFragment(\"rect\", this.getSvgProps(ctxt));\n  }\n}\n\nexport class NeumeLineVisualizer extends ChantLayoutElement {\n  constructor(ctxt, note0, note1, hanging) {\n    super();\n\n    var staffPosition0 = note0.staffPosition;\n    var staffPosition1 = note1.staffPosition;\n\n    // note0 should be the upper one for our calculations here\n    if (staffPosition0 < staffPosition1) {\n      var temp = staffPosition0;\n      staffPosition0 = staffPosition1;\n      staffPosition1 = temp;\n    }\n\n    if (hanging && staffPosition0 - staffPosition1 > 4) {\n      staffPosition1 = staffPosition0 - 4;\n    }\n\n    var y0 = ctxt.calculateHeightFromStaffPosition(staffPosition0);\n    var y1 = 0;\n\n    if (hanging) {\n      // if the difference between the notes is only one, and the upper\n      // note is on a line, and the lower note is within the four staff lines,\n      // then our hanging line goes past the lower note by a whole\n      // staff interval\n      if (\n        staffPosition0 - staffPosition1 === 1 &&\n        Math.abs(staffPosition0) % 2 === 1 &&\n        staffPosition1 > -3\n      )\n        staffPosition1--;\n\n      y1 += (ctxt.glyphPunctumHeight * ctxt.glyphScaling) / 2.2;\n    }\n\n    y1 += ctxt.calculateHeightFromStaffPosition(staffPosition1);\n\n    this.bounds.x = 0;\n    this.bounds.y = y0;\n    this.bounds.width = ctxt.neumeLineWeight;\n    this.bounds.height = y1 - y0;\n\n    this.origin.x = 0;\n    this.origin.y = 0;\n  }\n\n  draw(ctxt) {\n    var canvasCtxt = ctxt.canvasCtxt;\n\n    canvasCtxt.fillStyle = ctxt.neumeLineColor;\n\n    canvasCtxt.fillRect(\n      this.bounds.x,\n      this.bounds.y,\n      ctxt.neumeLineWeight,\n      this.bounds.height\n    );\n  }\n\n  getSvgProps(ctxt) {\n    return {\n      x: this.bounds.x,\n      y: this.bounds.y,\n      width: ctxt.neumeLineWeight,\n      height: this.bounds.height,\n      fill: ctxt.neumeLineColor,\n      class: \"neumeLine\"\n    };\n  }\n\n  createSvgNode(ctxt) {\n    return QuickSvg.createNode(\"rect\", this.getSvgProps(ctxt));\n  }\n  createSvgTree(ctxt) {\n    return QuickSvg.createSvgTree(\"rect\", this.getSvgProps(ctxt));\n  }\n\n  createSvgFragment(ctxt) {\n    return QuickSvg.createFragment(\"rect\", this.getSvgProps(ctxt));\n  }\n}\n\nexport class VirgaLineVisualizer extends ChantLayoutElement {\n  constructor(ctxt, note) {\n    super();\n\n    var staffPosition = note.staffPosition;\n\n    var y0 = ctxt.calculateHeightFromStaffPosition(staffPosition);\n    var y1;\n\n    if (Math.abs(staffPosition % 2) === 0) y1 = y0 + ctxt.staffInterval * 1.8;\n    else y1 = y0 + ctxt.staffInterval * 2.7;\n\n    this.bounds.x = 0;\n    this.bounds.y = y0;\n    this.bounds.width = ctxt.neumeLineWeight;\n    this.bounds.height = y1 - y0;\n\n    this.origin.x = 0;\n    this.origin.y = 0;\n  }\n\n  draw(ctxt) {\n    var canvasCtxt = ctxt.canvasCtxt;\n\n    canvasCtxt.fillStyle = ctxt.neumeLineColor;\n    canvasCtxt.fillRect(\n      this.bounds.x,\n      this.bounds.y,\n      ctxt.neumeLineWeight,\n      this.bounds.height\n    );\n  }\n\n  getSvgProps(ctxt) {\n    return {\n      x: this.bounds.x,\n      y: this.bounds.y,\n      width: ctxt.neumeLineWeight,\n      height: this.bounds.height,\n      fill: ctxt.neumeLineColor,\n      class: \"neumeLine\"\n    };\n  }\n\n  createSvgNode(ctxt) {\n    return QuickSvg.createNode(\"rect\", this.getSvgProps(ctxt));\n  }\n  createSvgTree(ctxt) {\n    return QuickSvg.createSvgTree(\"rect\", this.getSvgProps(ctxt));\n  }\n\n  createSvgFragment(ctxt) {\n    return QuickSvg.createFragment(\"rect\", this.getSvgProps(ctxt));\n  }\n}\n\nexport class LineaVisualizer extends ChantLayoutElement {\n  constructor(ctxt, note) {\n    super();\n\n    var staffPosition = note.staffPosition;\n\n    var y0 = ctxt.calculateHeightFromStaffPosition(staffPosition) - note.origin.y;\n    var y1 = y0 + note.bounds.height;\n\n    this.bounds.x = 0;\n    this.bounds.y = y0;\n    this.bounds.width = ctxt.neumeLineWeight * 5 + note.bounds.width;\n    this.bounds.height = y1 - y0;\n\n    this.origin.x = ctxt.neumeLineWeight * 2.5;\n    this.origin.y = 0;\n  }\n\n  draw(ctxt) {\n    var canvasCtxt = ctxt.canvasCtxt;\n\n    canvasCtxt.fillStyle = ctxt.neumeLineColor;\n    canvasCtxt.fillRect(\n      this.bounds.x,\n      this.bounds.y,\n      ctxt.neumeLineWeight,\n      this.bounds.height\n    );\n    canvasCtxt.fillRect(\n      this.bounds.x + this.bounds.width - ctxt.neumeLineWeight,\n      this.bounds.y,\n      ctxt.neumeLineWeight,\n      this.bounds.height\n    );\n  }\n\n  getSvgProps(ctxt, x) {\n    return {\n      x,\n      y: this.bounds.y,\n      width: ctxt.neumeLineWeight,\n      height: this.bounds.height,\n      fill: ctxt.neumeLineColor,\n      class: \"neumeLine\"\n    };\n  }\n\n  createSvgNode(ctxt) {\n    return QuickSvg.createNode(\"g\", null, [\n      this.bounds.x,\n      this.bounds.x + this.bounds.width - ctxt.neumeLineWeight\n    ].map(x => QuickSvg.createNode(\"rect\", this.getSvgProps(ctxt, x))));\n  }\n\n  createSvgTree(ctxt) {\n    return QuickSvg.createSvgTree(\"g\", {}, ...[\n      this.bounds.x,\n      this.bounds.x + this.bounds.width - ctxt.neumeLineWeight\n    ].map(x => QuickSvg.createSvgTree(\"rect\", this.getSvgProps(ctxt, x))));\n  }\n\n  createSvgFragment(ctxt) {\n    return QuickSvg.createFragment(\"g\", null, [\n      this.bounds.x,\n      this.bounds.x + this.bounds.width - ctxt.neumeLineWeight\n    ].map(x => QuickSvg.createFragment(\"rect\", this.getSvgProps(ctxt, x))).join(''));\n  }\n}\n\nexport class GlyphVisualizer extends ChantLayoutElement {\n  constructor(ctxt, glyphCode) {\n    super();\n\n    this.glyph = null;\n\n    this.setGlyph(ctxt, glyphCode);\n  }\n\n  setGlyph(ctxt, glyphCode) {\n    if (this.glyphCode !== glyphCode) {\n      if (\n        typeof glyphCode === \"undefined\" ||\n        glyphCode === null ||\n        glyphCode === \"\"\n      )\n        glyphCode = this.glyphCode = GlyphCode.None;\n      else this.glyphCode = glyphCode;\n\n      let glyph = this.glyph = Glyphs[glyphCode];\n\n      // if this glyph hasn't been used yet, then load it up in the defs section for sharing\n      if (!ctxt.defs.hasOwnProperty(glyphCode)) {\n        var getDefProps = () => {\n          var options = {\n            id: glyphCode,\n            class: \"glyph\"\n          };\n          if (ctxt.scaleDefs === true) {\n            options.transform = \"scale(\" + ctxt.glyphScaling + \")\";\n          }\n          return options;\n        };\n        var makeDef = () => {\n          let options = getDefProps();\n          // create the ref\n          ctxt.defs[glyphCode] = QuickSvg.createFragment(\n            \"g\",\n            options,\n            QuickSvg.svgFragmentForGlyph(glyph, ctxt.neumeLineColor)\n          ); //ctxt.neumeLineColor\n\n          if (ctxt.defsNode)\n            ctxt.defsNode.appendChild(\n              QuickSvg.createNode(\n                \"g\",\n                options,\n                QuickSvg.nodesForGlyph(glyph)\n              )\n            );\n        };\n        makeDef.makeSvgTree = () => {\n          return QuickSvg.createSvgTree(\n            \"g\",\n            getDefProps(),\n            ...QuickSvg.nodesForGlyph(glyph, \"createSvgTree\")\n          );\n        };\n        makeDef.glyphCode = glyphCode;\n        makeDef();\n        ctxt.makeDefs.push(makeDef);\n      }\n\n      this.align = this.glyph.align;\n    }\n\n    this.origin.x = this.glyph.origin.x * ctxt.glyphScaling;\n    this.origin.y = this.glyph.origin.y * ctxt.glyphScaling;\n\n    this.bounds.x = 0;\n    this.bounds.y = -this.origin.y;\n    this.bounds.width = this.glyph.bounds.width * ctxt.glyphScaling;\n    this.bounds.height = this.glyph.bounds.height * ctxt.glyphScaling;\n  }\n\n  setStaffPosition(ctxt, staffPosition) {\n    this.bounds.y =\n      ctxt.calculateHeightFromStaffPosition(staffPosition) - this.origin.y;\n  }\n\n  draw(ctxt) {\n    var canvasCtxt = ctxt.canvasCtxt;\n\n    var x = this.bounds.x + this.origin.x;\n    var y = this.bounds.y + this.origin.y;\n    canvasCtxt.translate(x, y);\n    canvasCtxt.scale(ctxt.glyphScaling, ctxt.glyphScaling);\n    for (var i = 0; i < this.glyph.paths.length; i++) {\n      var path = this.glyph.paths[i];\n      canvasCtxt.fillStyle =\n        path.type === \"negative\" ? \"#fff\" : ctxt.neumeLineColor;\n      canvasCtxt.fill(new Path2D(path.data));\n    }\n\n    canvasCtxt.scale(1.0 / ctxt.glyphScaling, 1.0 / ctxt.glyphScaling);\n    canvasCtxt.translate(-x, -y);\n  }\n\n  getSvgAttributes(ctxt, source) {\n    let className = \"\";\n    if (/^Porrectus\\d$/.test(this.glyphCode)) {\n      let notes = source.neume.notes,\n        noteIndex = notes.indexOf(source),\n        nextNote = notes[noteIndex + 1];\n      className = source.selected\n        ? nextNote.selected\n          ? \"selected\"\n          : \"selectedA\"\n        : nextNote.selected\n        ? \"selectedB\"\n        : \"\";\n    } else {\n      let isSelected =\n        source && (source.selected || (source.model && source.model.selected));\n      className = isSelected ? \"selected\" : \"\";\n    }\n    var result = {\n      \"xlink:href\": \"#\" + this.glyphCode,\n      class: className\n    };\n    if (source) {\n      result[\"source-index\"] = source.sourceIndex;\n      result[\"element-index\"] = source.elementIndex;\n      if ('noteIndex' in source) {\n        result.class += ' note';\n        result.id = ctxt.noteIdPrefix + (source.noteIndex + 1);\n        if (source.neume) {\n          const glyphCode = source.glyphVisualizer.glyphCode;\n          if (/^Porrectus/.test(glyphCode)) {\n            result.class += ' porrectus porrectus-start';\n          } else if (glyphCode === 'None') {\n            result.class += ' porrectus porrectus-end';\n          }\n        }\n      }\n    }\n    if (ctxt.scaleDefs === true) {\n      result.x = this.bounds.x + this.origin.x;\n      result.y = this.bounds.y + this.origin.y;\n    } else {\n      result.x = (this.bounds.x + this.origin.x) / ctxt.glyphScaling;\n      result.y = (this.bounds.y + this.origin.y) / ctxt.glyphScaling;\n      result.transform = \"scale(\" + ctxt.glyphScaling + \")\";\n    }\n    return result;\n  }\n\n  createSvgNode(ctxt, source) {\n    var attributes = this.getSvgAttributes(ctxt, source);\n    attributes.source = source;\n    return QuickSvg.createNode(\"use\", attributes);\n  }\n  createSvgTree(ctxt, source) {\n    var attributes = this.getSvgAttributes(ctxt, source);\n    if (source) attributes.source = source;\n    return QuickSvg.createSvgTree(\"use\", attributes);\n  }\n\n  createSvgFragment(ctxt, source) {\n    return QuickSvg.createFragment(\"use\", this.getSvgAttributes(ctxt, source));\n  }\n}\n\nexport class RoundBraceVisualizer extends ChantLayoutElement {\n  constructor(ctxt, x1, x2, y, isAbove) {\n    super();\n    this.ignoreBounds = true;\n\n    if (x1 > x2) {\n      // swap the xs\n      var temp = x1;\n      x1 = x2;\n      x2 = temp;\n    }\n\n    this.isAbove = isAbove;\n    this.braceHeight = (3 * ctxt.staffInterval) / 2;\n\n    this.bounds = new Rect(\n      x1,\n      isAbove ? y - this.braceHeight : y,\n      x2 - x1,\n      this.braceHeight\n    );\n\n    this.origin.x = 0;\n    this.origin.y = 0;\n  }\n\n  draw(ctxt) {\n    /**\n     * @type CanvasRenderingContext2D\n     */\n    var d = ctxt.canvasCtxt;\n\n    const { x1, x2, y, cx1, cx2, cy } = this.getPathPoints();\n    d.beginPath();\n    d.moveTo(x1, y);\n    d.bezierCurveTo(cx1, cy, cx2, cy, x2, y);\n    d.stroke();\n  }\n\n  getSvgPathProps(ctxt) {\n    return {\n      d: this.generatePathString(),\n      stroke: ctxt.neumeLineColor,\n      \"stroke-width\": ctxt.staffLineWeight + \"px\",\n      fill: \"none\",\n      class: \"brace\"\n    };\n  }\n\n  createSvgNode(ctxt) {\n    var node = QuickSvg.createNode(\"path\", this.getSvgPathProps(ctxt));\n    if (this.accent) {\n      return QuickSvg.createNode(\n        \"g\",\n        {\n          class: \"accentedBrace\"\n        },\n        [node, this.accent.createSvgNode(ctxt)]\n      );\n    } else return node;\n  }\n  createSvgTree(ctxt) {\n    var node = QuickSvg.createSvgTree(\"path\", this.getSvgPathProps(ctxt));\n    if (this.accent) {\n      return QuickSvg.createSvgTree(\n        \"g\",\n        {\n          class: \"accentedBrace\"\n        },\n        node,\n        this.accent.createSvgTree(ctxt)\n      );\n    } else return node;\n  }\n\n  createSvgFragment(ctxt) {\n    var fragment = QuickSvg.createFragment(\"path\", this.getSvgPathProps(ctxt));\n\n    if (this.accent) {\n      fragment += this.accent.createSvgFragment(ctxt);\n\n      return QuickSvg.createFragment(\n        \"g\",\n        {\n          class: \"accentedBrace\"\n        },\n        fragment\n      );\n    } else return fragment;\n  }\n\n  getPathPoints() {\n    var x1 = this.bounds.x;\n    var x2 = this.bounds.right();\n    var width = this.bounds.width;\n    var y, dx, dy;\n\n    dx = width / 6;\n    dy = this.bounds.height;\n    if (this.isAbove) {\n      y = this.bounds.bottom();\n      dy = -dy;\n    } else {\n      y = this.bounds.y;\n    }\n\n    //Calculate Control Points of path,\n    var cx1 = x1 + dx;\n    var cy = y + dy;\n    var cx2 = x2 - dx;\n\n    return { x1, x2, y, cx1, cx2, cy };\n  }\n\n  // returns svg path d string\n  generatePathString() {\n    const { x1, x2, y, cx1, cx2, cy } = this.getPathPoints();\n\n    // two decimal points should be enough, but if we need more precision, we can\n    // up it here.\n    var dp = 2;\n    return (\n      \"M \" +\n      x1.toFixed(dp) +\n      \" \" +\n      y.toFixed(dp) +\n      \" C \" +\n      cx1.toFixed(dp) +\n      \" \" +\n      cy.toFixed(dp) +\n      \" \" +\n      cx2.toFixed(dp) +\n      \" \" +\n      cy.toFixed(dp) +\n      \" \" +\n      x2.toFixed(dp) +\n      \" \" +\n      y.toFixed(dp)\n    );\n  }\n}\n\nexport class CurlyBraceVisualizer extends ChantLayoutElement {\n  constructor(ctxt, x1, x2, y, isAbove = true, addAcuteAccent = false) {\n    super();\n\n    if (x1 > x2) {\n      // swap the xs\n      var temp = x1;\n      x1 = x2;\n      x2 = temp;\n    }\n\n    this.isAbove = isAbove;\n    this.braceHeight = ctxt.staffInterval / 2;\n\n    // y is the actual vertical start of the brace (left hand side)\n    // thus for a brace over notes, bounds.y is the bottom of brace,\n    // but for a brace under the notes, y is simply the y passed in.\n    if (isAbove) y -= this.braceHeight;\n\n    var bounds = new Rect(x1, y, x2 - x1, this.braceHeight);\n\n    if (addAcuteAccent && isAbove) {\n      this.accent = new GlyphVisualizer(ctxt, GlyphCode.AcuteAccent);\n      this.accent.bounds.x += bounds.x + (x2 - x1) / 2;\n      this.accent.bounds.y += bounds.y - ctxt.staffInterval / 4;\n\n      bounds.union(this.accent.bounds);\n    }\n\n    this.bounds = bounds;\n\n    this.origin.x = 0;\n    this.origin.y = 0;\n  }\n\n  getSvgPathProps(ctxt) {\n    return {\n      d: this.generatePathString(),\n      stroke: ctxt.neumeLineColor,\n      \"stroke-width\": ctxt.staffLineWeight + \"px\",\n      fill: \"none\",\n      class: \"brace\"\n    };\n  }\n\n  createSvgNode(ctxt) {\n    var node = QuickSvg.createNode(\"path\", this.getSvgPathProps(ctxt));\n\n    if (this.accent) {\n      return QuickSvg.createNode(\n        \"g\",\n        {\n          class: \"accentedBrace\"\n        },\n        [node, this.accent.createSvgNode(ctxt)]\n      );\n    } else return node;\n  }\n  createSvgTree(ctxt) {\n    var node = QuickSvg.createSvgTree(\"path\", this.getSvgPathProps(ctxt));\n    if (this.accent) {\n      return QuickSvg.createSvgTree(\n        \"g\",\n        {\n          class: \"accentedBrace\"\n        },\n        node,\n        this.accent.createSvgTree(ctxt)\n      );\n    } else return node;\n  }\n\n  createSvgFragment(ctxt) {\n    var fragment = QuickSvg.createFragment(\"path\", this.getSvgPathProps(ctxt));\n\n    if (this.accent) {\n      fragment += this.accent.createSvgFragment(ctxt);\n\n      return QuickSvg.createFragment(\n        \"g\",\n        {\n          class: \"accentedBrace\"\n        },\n        fragment\n      );\n    } else return fragment;\n  }\n\n  // code below inspired by: https://gist.github.com/alexhornbake\n  // optimized for braces that are only drawn horizontally.\n  // returns svg path d string\n  generatePathString() {\n    var q = 0.6; // .5 is normal, higher q = more expressive bracket\n\n    var x1 = this.bounds.x;\n    var x2 = this.bounds.right();\n    var width = this.bounds.width;\n    var y, h;\n\n    if (this.isAbove) {\n      y = this.bounds.bottom();\n      h = -this.braceHeight;\n    } else {\n      y = this.bounds.y;\n      h = this.braceHeight;\n    }\n\n    // calculate Control Points of path\n    var qy1 = y + q * h;\n    var qx2 = x1 + 0.25 * width;\n    var qy2 = y + (1 - q) * h;\n    var tx1 = x1 + 0.5 * width;\n    var ty1 = y + h;\n    var qy3 = y + q * h;\n    var qx4 = x1 + 0.75 * width;\n    var qy4 = y + (1 - q) * h;\n\n    // two decimal points should be enough, but if we need more precision, we can\n    // up it here.\n    var dp = 2;\n    return (\n      \"M \" +\n      x1.toFixed(dp) +\n      \" \" +\n      y.toFixed(dp) +\n      \" Q \" +\n      x1.toFixed(dp) +\n      \" \" +\n      qy1.toFixed(dp) +\n      \" \" +\n      qx2.toFixed(dp) +\n      \" \" +\n      qy2.toFixed(dp) +\n      \" T \" +\n      tx1.toFixed(dp) +\n      \" \" +\n      ty1.toFixed(dp) +\n      \" M \" +\n      x2.toFixed(dp) +\n      \" \" +\n      y.toFixed(dp) +\n      \" Q \" +\n      x2.toFixed(dp) +\n      \" \" +\n      qy3.toFixed(dp) +\n      \" \" +\n      qx4.toFixed(dp) +\n      \" \" +\n      qy4.toFixed(dp) +\n      \" T \" +\n      tx1.toFixed(dp) +\n      \" \" +\n      ty1.toFixed(dp)\n    );\n  }\n}\n\nexport class TextSpan {\n  constructor(text, propertyArray, activeTags, index = 0, extraProps) {\n    if (typeof propertyArray === \"undefined\" || propertyArray === null)\n      propertyArray = [];\n\n    this.text = text;\n    this.propertyArray = propertyArray;\n    this.activeTags = activeTags || [];\n    this.index = index;\n    if (extraProps) {\n      if ('xOffset' in extraProps) this.xOffset = extraProps.xOffset;\n      if ('newLine' in extraProps) this.newLine = extraProps.newLine;\n    }\n  }\n\n  get properties() {\n    const result = Object.assign.apply(null, [{}].concat(this.propertyArray).concat());\n    if ('xOffset' in this) result.xOffset = this.xOffset;\n    if ('newLine' in this) result.newLine = this.newLine;\n    return result;\n  }\n\n  clone() {\n    const result = new TextSpan(\n      this.text,\n      this.propertyArray,\n      this.activeTags,\n      this.index\n    );\n    if ('xOffset' in this) result.xOffset = this.xOffset;\n    if ('newLine' in this) result.newLine = this.newLine;\n    return result;\n  }\n}\n\nclass MarkupStackFrame {\n  constructor(tagName, startIndex, propertyArray = [], symbol) {\n    this.tagName = tagName;\n    this.startIndex = startIndex;\n    this.propertyArray = propertyArray;\n    if (symbol) this.symbol = symbol;\n  }\n\n  get properties() {\n    return Object.assign.apply(null, [{}].concat(this.propertyArray));\n  }\n\n  static createStackFrame(ctxt, tagName, startIndex, extraProperties = {}, symbol = '') {\n    return new MarkupStackFrame(\n      tagName,\n      startIndex,\n      [ctxt.fontStyleDictionary[tagName], extraProperties],\n      symbol\n    );\n  }\n}\n\n// for escaping html strings before they go into the svgs\n// adapted from http://stackoverflow.com/a/12034334/5720160\nvar __subsForTspans = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\"\n};\n\nexport class TextElement extends ChantLayoutElement {\n  constructor(\n    ctxt,\n    text,\n    fontFamily,\n    fontSize,\n    textAnchor,\n    sourceIndex,\n    sourceGabc\n  ) {\n    super();\n\n    // set these to some sane values for now...\n    this.bounds.x = 0;\n    this.bounds.y = 0;\n    this.bounds.width = 0;\n    this.bounds.height = 0;\n    this.origin.x = 0;\n    this.origin.y = 0;\n\n    this.fontFamily = fontFamily;\n    this.fontSize = fontSize;\n    this.textAnchor = textAnchor;\n    this.sourceIndex = sourceIndex;\n    this.sourceGabc = sourceGabc;\n    this.dominantBaseline = \"baseline\"; // default placement\n\n    this.generateSpansFromText(ctxt, text);\n\n    this.recalculateMetrics(ctxt);\n  }\n\n  getFromScore(score) {\n    return this.textType.getFromScore(score, this);\n  }\n\n  generateSpansFromText(ctxt, text) {\n    text = text.replace(/\\s+/g, \" \");\n    this.text = \"\";\n    this.spans = [];\n\n    // save ourselves a lot of grief for a very common text:\n    if (text === \"*\" || text === \"+\" || text === \"†\") {\n      let properties =\n        text === \"*\"\n          ? [ctxt.asteriskProperties]\n          : text === \"+\"\n          ? [ctxt.plusProperties]\n          : null;\n      text = ctxt.specialCharText(text) || text;\n      this.spans.push(new TextSpan(text, properties));\n      return;\n    }\n\n    var markupStack = [];\n    var spanStartIndex = 0;\n    var newLineInNextSpan = 0;\n\n    var filterFrames = (frame, symbol) => frame.Symbol === symbol;\n\n    var closeSpan = (spanText, index, extraProperties) => {\n      if (spanText === \"\" && !this.dropCap) return;\n\n      this.text += spanText;\n\n      var properties = [];\n      for (var i = 0; i < markupStack.length; i++) {\n        properties.push.apply(properties, markupStack[i].propertyArray);\n      }\n\n      if (extraProperties) properties.push(extraProperties);\n      const span = new TextSpan(\n        spanText,\n        properties,\n        markupStack.map((frame) => frame.tagName),\n        index\n      );\n      this.spans.push(span);\n      if (newLineInNextSpan) {\n        span.newLine = newLineInNextSpan;\n        newLineInNextSpan = 0;\n      }\n\n    };\n\n    var markupRegex = /(<br\\/?>)|<v>([\\s\\S]*?)(?:<\\/v>|$)|(\\*)(?=\\s*\\*|[^*]*(?:$|<v>))|(\\+)|<sp>(?:(~)|(')?([ao]e|[æœaeiouy])|([arv])\\/)<\\/sp>|([arv])\\/\\.|([℣℟])\\.?|(?:([*_^%])|<(\\/)?([bceiuv]|ul|sc|font)(?:\\s+(?:family=\"([^\"]+)\"|fill=\"([^\"]+)\"|class=\"([^\"]+)\"))*>)(?=(?:(.+?)(?:\\11|<\\/\\13>))?)/gi;\n    var vTagRegex = /(\\\\grecross)|\\{greextra\\}\\{([^}]*)\\}|\\{?(\\\\?')?(?:\\\\([ao]e|æœaeiouy))\\}?/gi;\n    var match = null;\n    var openedAsterisk = false;\n    var closeCurrentSpan = () =>\n      closeSpan(text.substring(spanStartIndex, match.index), spanStartIndex);\n    while ((match = markupRegex.exec(text))) {\n      var [\n        ,\n        newLine,\n        vTag,\n        asterisk,\n        plus,\n        tilde,\n        accent,\n        vowelLigature,\n        specialChar,\n        specialChar2,\n        specialChar3,\n        markupSymbol,\n        closingTag,\n        tagName,\n        family,\n        fill,\n        cssClass,\n        enclosedText\n      ] = match;\n      specialChar = specialChar || specialChar2 || specialChar3;\n      // non-matching symbols first\n      if (newLine) {\n        // close the current span, if any:\n        if (match.index > spanStartIndex) {\n          closeCurrentSpan();\n        }\n        // add the newline span:\n        newLineInNextSpan++;\n      } else if (vTag) {\n        closeCurrentSpan();\n        let vMatch;\n        let lastIndex = 0;\n        let iOffset = 0;\n        while ((vMatch = vTagRegex.exec(vTag))) {\n          if (lastIndex < vMatch.index) {\n            closeSpan(vTag.slice(lastIndex, vMatch.index), match.index + lastIndex + iOffset);\n            iOffset = 3; // length of '<v>'\n          }\n          let [, grecross, greextra, accent, diphthong] = vMatch;\n          let char = '';\n          if (diphthong) {\n            char = makeLigature(diphthong);\n            if (accent) char = addAccent(char);\n            closeSpan(char, match.index + vMatch.index + iOffset)\n          } else {\n            if (grecross) {\n              // grecross is just the command for the Cross:\n              // set up greextra so it will get handled with it below:\n              greextra = 'Cross';\n            }    \n            char = greextraGlyphs[greextra];\n            if (char) {\n              closeSpan(char, match.index + vMatch.index + iOffset, { 'font-family': 'greextra' })\n            }\n          }\n          lastIndex = vTagRegex.lastIndex;\n          iOffset = 3; // length of '<v>'\n        }\n        if (lastIndex < vTag.length) {\n          closeSpan(vTag.slice(lastIndex), match.index + lastIndex + iOffset);\n        }\n      } else if (asterisk) {\n        closeCurrentSpan();\n        // first check if it is just a symbol to close:\n        if (\n          markupStack.length > 0 &&\n          markupStack[markupStack.length - 1].symbol === asterisk\n        ) {\n          // close asterisk tag\n          markupStack.pop();\n        } else {\n          // add special asterisk:\n          closeSpan(ctxt.specialCharText(asterisk) || '*', match.index, ctxt.asteriskProperties);\n        }\n      } else if (plus) {\n        closeCurrentSpan();\n        closeSpan(ctxt.specialCharText(plus) || '+', match.index, ctxt.plusProperties);\n      } else if (tilde) {\n        closeCurrentSpan();\n        closeSpan('∼', match.index);\n      } else if (vowelLigature) {\n        let vowel = makeLigature(vowelLigature);\n        if (accent) vowel = addAccent(vowel);\n        closeCurrentSpan();\n        closeSpan(vowel, match.index);\n      } else if (specialChar) {\n        closeCurrentSpan();\n        closeSpan(\n          ctxt.textBeforeSpecialChar +\n            ctxt.specialCharText(specialChar) +\n            ctxt.textAfterSpecialChar,\n          match.index,\n          ctxt.specialCharProperties\n        );\n      } else {\n        // otherwise we're dealing with matching markup delimeters\n        if (markupSymbol === \"*\") {\n          // we are only strict with the asterisk, because there are cases when it needs to be displayed rather than count as a markup symbol\n          if (enclosedText && /[^\\s*]/.test(enclosedText)) {\n            openedAsterisk = true;\n          } else if (openedAsterisk) {\n            openedAsterisk = false;\n          } else {\n            // actually use the asterisk, since it doesn't have a matching closing asterisk\n            continue;\n          }\n        }\n        if (markupSymbol) {\n          tagName = ctxt.markupSymbolDictionary[markupSymbol];\n          if (\n            markupStack.length > 0 &&\n            markupStack[markupStack.length - 1].tagName === tagName &&\n            markupStack[markupStack.length - 1].symbol === markupSymbol\n          ) {\n            closingTag = true;\n          }\n        }\n        if (\n          markupStack.length > 0 &&\n          markupStack[markupStack.length - 1].tagName === tagName\n        ) {\n          if (closingTag) {\n            // group close\n            closeCurrentSpan();\n            markupStack.pop();\n          }\n        } else if (markupStack.filter(filterFrames).length > 0) {\n          // trying to open a recursive group (or forgot to close a previous group)\n          // in either case, we just unwind to the previous stack frame\n          spanStartIndex = markupStack[markupStack.length - 1].startIndex;\n          markupStack.pop();\n          continue;\n        } else {\n          closeCurrentSpan();\n          if (closingTag) {\n            // out of order group close:\n            let index = markupStack.findIndex(\n              (frame) => frame.tagName === tagName\n            );\n            if (index >= 0) {\n              markupStack.splice(index, 1);\n            }\n          } else {\n            // group open\n            const extraProperties = {};\n            if (family) extraProperties['font-family'] = family;\n            if (fill) extraProperties.fill = fill;\n            if (cssClass) extraProperties.class = cssClass;\n            markupStack.push(\n              MarkupStackFrame.createStackFrame(ctxt, tagName, match.index, extraProperties, markupSymbol)\n            );\n          }\n        }\n      }\n\n      // advance the start index past the current markup\n      spanStartIndex = match.index + match[0].length;\n    }\n\n    // if we finished matches, and there is still some text left,\n    // or if we haven't generated any spans yet, create one final run\n    if (spanStartIndex < text.length || this.spans.length === 0)\n      closeSpan(text.slice(spanStartIndex), spanStartIndex);\n  }\n\n  getCanvasFontForProperties(ctxt, properties = {}) {\n    var font = \"\";\n    if (properties[\"font-style\"] === \"italic\") font += \"italic \";\n    if (properties[\"font-variant\"] === \"small-caps\") font += \"small-caps \";\n    if (properties[\"font-weight\"] === \"bold\") font += \"bold \";\n    let fontSize = parseFloat(properties[\"font-size\"]) || this.fontSize(ctxt);\n    if (/%$/.test(properties[\"font-size\"])) {\n      fontSize *= this.fontSize(ctxt) / 100;\n    }\n    font += `${fontSize * (this.resize || 1)}px `;\n    font += properties[\"font-family\"] || this.fontFamily(ctxt);\n    return font;\n  }\n\n  measureSubstringBBox(ctxt, length) {\n    return this.measureSubstring(ctxt, length, true);\n  }\n\n  /**\n   * if length is undefined and this.rightAligned === true, then offsets will be marked for each newLine span\n   * \n   * @param {ChantContext} ctxt \n   * @param {number} length \n   * @param {boolean} returnBBox \n   * @returns measured substring, as a simple width unless returnBBox == true\n   */\n  measureSubstring(ctxt, length, returnBBox = false) {\n    if (length === 0) return 0;\n    if (!length) length = Infinity;\n    if (length < 0) {\n      var lines = -length;\n      length = Infinity;\n    }\n    var canvasCtxt = ctxt.canvasCtxt;\n    var width = 0;\n    var widths = [];\n    var newLineSpans = [this.spans[0]];\n    var subStringLength = 0;\n    var numLines = 1;\n    var fontSize = this.fontSize(ctxt) * (this.resize || 1);\n    var bbox = new Rect(0, 0, 0, 0);\n    for (var i = 0; i < this.spans.length; i++) {\n      var span = this.spans[i],\n        myText = span.text.slice(0, length - subStringLength);\n      if (span.newLine) {\n        numLines += parseInt(span.newLine) || 1;\n        if (!lines && this.rightAligned === true && length === Infinity) {\n          newLineSpans[newLineSpans.length - 1].xOffset =\n            this.firstLineMaxWidth - width;\n          newLineSpans.push(span);\n        } else if (--lines === 0) break;\n        widths.push(width);\n        width = 0;\n      }\n      if (ctxt.textMeasuringStrategy === TextMeasuringStrategy.Canvas) {\n        canvasCtxt.font = this.getCanvasFontForProperties(\n          ctxt,\n          span.properties\n        );\n        let metrics = canvasCtxt.measureText(\n          myText,\n          width,\n          fontSize * (numLines - 1)\n        );\n        if (\"actualBoundingBoxAscent\" in metrics) {\n          let left = metrics.actualBoundingBoxLeft;\n          bbox.union(\n            new Rect(\n              width - left,\n              fontSize * (numLines - 1) - metrics.actualBoundingBoxAscent,\n              metrics.width + left,\n              metrics.actualBoundingBoxDescent + metrics.actualBoundingBoxAscent\n            )\n          );\n          if (this instanceof DropCap) {\n            width += Math.max(0, left);\n          }\n        } else {\n          bbox.union(\n            new Rect(width, fontSize * (numLines - 2), metrics.width, fontSize)\n          );\n        }\n        width += metrics.width;\n      } else if (\n        ctxt.textMeasuringStrategy === TextMeasuringStrategy.OpenTypeJS &&\n        ctxt.fontDictionary\n      ) {\n        // get the bounding box for the substring, placing it at x = width, y = fontSize * (numLines - 1)\n        let font = ctxt.getFontForProperties(\n          span.properties,\n          span.properties[\"font-family\"] || this.fontFamily(ctxt)\n        );\n        /**\n         * @type {{ features: { liga: boolean; smcp?: boolean; } }}\n         */\n        let options = { features: { liga: true } };\n        if (span.properties[\"font-variant\"] === \"small-caps\") {\n          options.features.smcp = true;\n        }\n        let spanFontSize = parseFloat(span.properties[\"font-size\"]) || fontSize;\n        if (/%$/.test(span.properties[\"font-size\"])) {\n          spanFontSize *= fontSize / 100;\n        }\n        let subBbox = font\n          .getPath(\n            myText,\n            width,\n            fontSize * (numLines - 1),\n            spanFontSize,\n            options\n          )\n          .getBoundingBox();\n        let subWidth = font.getAdvanceWidth(myText, spanFontSize, options);\n\n        bbox.union(\n          new Rect(\n            width + subBbox.x1,\n            subBbox.y1,\n            subWidth - subBbox.x1,\n            subBbox.y2 - subBbox.y1\n          )\n        );\n        width += subWidth;\n        if (this instanceof DropCap) {\n          width -= subBbox.x1;\n        }\n      }\n      subStringLength += myText.length;\n      if (subStringLength === length) break;\n    }\n    if (\n      !lines &&\n      width &&\n      newLineSpans.length &&\n      this.rightAligned === true &&\n      length === Infinity\n    ) {\n      newLineSpans[newLineSpans.length - 1].xOffset =\n        this.firstLineMaxWidth - width;\n    }\n    width = Math.max(width, ...widths);\n    if (returnBBox === true) {\n      let height = bbox.height;\n      let y = bbox.y,\n        x = bbox.x;\n      return { width, height, x, y };\n    } else {\n      return width;\n    }\n  }\n\n  recalculateMetrics(ctxt, resetNewLines = true) {\n    if (resetNewLines) {\n      delete this.maxWidth;\n      delete this.firstLineMaxWidth;\n      delete this.rightAligned;\n      delete this.resize;\n      delete this.numLines;\n      // replace newlines with spaces\n      this.spans.forEach((span) => {\n        delete span.xOffset;\n        if (span.newLine === true) {\n          delete span.newLine;\n          span.text = \" \" + span.text;\n        }\n      });\n    }\n\n    this.bounds.x = 0;\n    this.bounds.y = 0;\n\n    this.origin.x = 0;\n\n    if (ctxt.textMeasuringStrategy === TextMeasuringStrategy.Svg) {\n      while (ctxt.svgTextMeasurer.firstChild)\n        ctxt.svgTextMeasurer.removeChild(ctxt.svgTextMeasurer.firstChild);\n      ctxt.svgTextMeasurer.appendChild(this.createSvgNode(ctxt));\n      ctxt.svgTextMeasurer.appendChild(ctxt.createStyleNode());\n\n      var bbox = ctxt.svgTextMeasurer.firstChild.getBBox();\n      this.bounds.width = bbox.width;\n      this.bounds.height = bbox.height;\n      this.origin.y = -bbox.y; // offset to baseline from top\n      this.origin.x = -bbox.x;\n    } else {\n      let bbox = this.measureSubstringBBox(ctxt);\n      this.bounds.width = bbox.width;\n      this.bounds.height = bbox.height;\n      this.origin.y = -bbox.y;\n      this.origin.x = -bbox.x;\n    }\n    this.numLines = this.spans.reduce(\n      (result, span) =>\n        result +\n        (span.newLine ? parseInt(span.newLine) || 1 : 0),\n      1\n    );\n  }\n\n  setMaxWidth(ctxt, maxWidth, firstLineMaxWidth = maxWidth) {\n    if (this.spans.filter((s) => s.newLine === true).length) {\n      // first get rid of any new lines set from a previous maxWidth\n      this.recalculateMetrics(ctxt);\n    }\n    if (this.bounds.width > maxWidth) {\n      this.maxWidth = maxWidth;\n      var percentage = maxWidth / this.bounds.width;\n      if (this instanceof Lyric && percentage >= 0.85) {\n        this.resize = percentage;\n      } else {\n        if (firstLineMaxWidth < 0) firstLineMaxWidth = maxWidth;\n        this.firstLineMaxWidth = firstLineMaxWidth;\n        var lastWidth = 0,\n          lastMatch = null,\n          regex = /\\s+|$/g,\n          max = firstLineMaxWidth,\n          match;\n        while (\n          (match = regex.exec(this.text)) &&\n          (!lastMatch || match.index > lastMatch.index)\n        ) {\n          var width = this.measureSubstring(ctxt, match.index);\n          if (width > max && lastMatch) {\n            var spanIndex = 0,\n              length = 0;\n            while (length < lastMatch.index && spanIndex < this.spans.length) {\n              let span = this.spans[spanIndex++];\n              length += span.text.length + (span.newLine ? 1 : 0);\n            }\n            if (length > lastMatch.index || spanIndex >= this.spans.length) {\n              let span = this.spans[--spanIndex];\n              length -= span.text.length;\n            }\n            var splitSpan = this.spans[spanIndex],\n              textLeft = splitSpan.text.slice(0, lastMatch.index - length),\n              textRight = splitSpan.text.slice(\n                lastMatch.index + lastMatch[0].length - length\n              ),\n              newSpans = [];\n            this.rightAligned =\n              max === firstLineMaxWidth && firstLineMaxWidth !== maxWidth;\n            if (textLeft)\n              newSpans.push(\n                new TextSpan(\n                  textLeft,\n                  splitSpan.propertyArray,\n                  splitSpan.activeTags\n                )\n              );\n            if (textRight) {\n              newSpans.push(\n                new TextSpan(\n                  textRight,\n                  splitSpan.propertyArray,\n                  splitSpan.activeTags,\n                  undefined,\n                  { newLine: true }\n                )\n              );\n            } else if (this.spans[spanIndex + 1]) {\n              this.spans[spanIndex + 1].newLine = true;\n            }\n            this.spans.splice(spanIndex, 1, ...newSpans);\n            this.needsLayout = true;\n            max = maxWidth;\n            if (\n              match.index === this.text.length ||\n              this.measureSubstring(ctxt) <= maxWidth\n            )\n              break;\n            width = 0;\n            match = lastMatch = null;\n          }\n          lastWidth = width;\n          lastMatch = match;\n        }\n      }\n      this.recalculateMetrics(ctxt, false);\n    }\n  }\n\n  getCssClasses() {\n    return (this.textType && this.textType.cssClass) || \"\";\n  }\n\n  getExtraStyleProperties(ctxt) {\n    return ctxt.baseTextStyle || {};\n  }\n\n  static escapeForTspan(string) {\n    return String(string).replace(/[&<>]/g, function (s) {\n      return __subsForTspans[s];\n    });\n  }\n\n  draw(ctxt) {\n    var canvasCtxt = ctxt.canvasCtxt;\n\n    if (this.textAnchor === \"middle\") canvasCtxt.textAlign = \"center\";\n    else canvasCtxt.textAlign = \"start\";\n\n    var translateWidth = 0,\n      translateHeight = 0;\n    for (var i = 0; i < this.spans.length; i++) {\n      var span = this.spans[i];\n      var xOffset = span.xOffset || 0;\n      if (span.newLine) {\n        let count = parseInt(span.newLine) || 1;\n        canvasCtxt.translate(\n          translateWidth + xOffset,\n          this.fontSize(ctxt) * count\n        );\n        translateWidth = -xOffset;\n        translateHeight -= this.fontSize(ctxt);\n      } else if (xOffset) {\n        canvasCtxt.translate(translateWidth + xOffset, 0);\n        translateWidth = -xOffset;\n      }\n      var properties = Object.assign(\n        {},\n        this.getExtraStyleProperties(ctxt),\n        span.properties\n      );\n      canvasCtxt.font = this.getCanvasFontForProperties(ctxt, properties);\n      canvasCtxt.fillStyle = properties.fill || \"#000\";\n      canvasCtxt.fillText(\n        span.text,\n        this.bounds.x,\n        this.bounds.y,\n        span.textLength || undefined\n      );\n      var metrics = canvasCtxt.measureText(\n        span.text,\n        this.bounds.x,\n        this.bounds.y\n      );\n      translateWidth -= metrics.width;\n      canvasCtxt.translate(metrics.width, 0);\n    }\n    canvasCtxt.translate(translateWidth, translateHeight);\n  }\n\n  getSvgProps() {\n    return {\n      \"source-index\": this.sourceIndex,\n      x: this.bounds.x,\n      y: this.bounds.y,\n      class: this.getCssClasses().trim(),\n      \"text-anchor\": this.textAnchor\n      //'dominant-baseline': this.dominantBaseline, // hanging baseline doesn't work in Safari\n    };\n  }\n\n  getSpanOptions(span, ctxt, useStyleObject = false) {\n    var options = {\n      \"source-index\": span.index,\n      class: span.properties.class,\n      style: useStyleObject\n        ? Object.assign({}, span.properties)\n        : getCssForProperties(span.properties)\n    };\n\n    if (span.newLine) {\n      var xOffset = span.xOffset || 0;\n      options.dy = 1.1 * (parseInt(span.newLine) || 1) + \"em\";\n      options.x = this.bounds.x + xOffset;\n    } else if (span.xOffset) {\n      options.x = this.bounds.x + span.xOffset;\n    }\n    if (span.textLength) {\n      options.textLength = span.textLength;\n      options.lengthAdjust = \"spacingAndGlyphs\";\n      options.y = this.bounds.y;\n    }\n    if (this.resize) {\n      options[\"font-size\"] =\n        span.properties[\"font-size\"] || this.fontSize(ctxt) * this.resize;\n    }\n    // if (ctxt.setFontFamilyAttributes) {\n    //   options[\"font-family\"] =\n    //     span.properties[\"font-family\"] ||\n    //     getFontFilenameForProperties(span.properties, this.fontFamily(ctxt));\n    //   let properties = Object.assign({}, span.properties);\n    //   delete properties[\"font-weight\"];\n    //   delete properties[\"font-style\"];\n    //   options[\"style\"] = getCssForProperties(properties);\n    // } else {\n    //   options[\"style\"] = getCssForProperties(span.properties);\n    // }\n\n    return options;\n  }\n\n  createSvgNode(ctxt) {\n    var spans = [];\n\n    for (var i = 0; i < this.spans.length; i++) {\n      let span = this.spans[i];\n      let options = this.getSpanOptions(span, ctxt);\n\n      spans.push(QuickSvg.createNode(\"tspan\", options, span.text));\n    }\n\n    let options = this.getSvgProps();\n    const extraStyleProperties = this.getExtraStyleProperties(ctxt);\n    options.style = getCssForProperties(extraStyleProperties);\n    if (extraStyleProperties.class) {\n      options.class = extraStyleProperties.class + ' ' + options.class;\n    }\n    options.source = this;\n\n    return (this.svgNode = QuickSvg.createNode(\"text\", options, spans));\n  }\n  createSvgTree(ctxt) {\n    var spans = [];\n\n    for (var i = 0; i < this.spans.length; i++) {\n      let span = this.spans[i];\n      let options = this.getSpanOptions(span, ctxt, true);\n\n      spans.push(QuickSvg.createSvgTree(\"tspan\", options, span.text));\n    }\n\n    let options = this.getSvgProps();\n    options.style = this.getExtraStyleProperties(ctxt);\n    if (options.style.class) {\n      options.class = options.style.class + ' ' + options.class;\n    }\n    options.source = this;\n\n    return QuickSvg.createSvgTree(\"text\", options, ...spans);\n  }\n\n  createSvgFragment(ctxt) {\n    var spans = \"\";\n\n    for (var i = 0; i < this.spans.length; i++) {\n      let span = this.spans[i];\n      let options = this.getSpanOptions(span, ctxt);\n\n      spans += QuickSvg.createFragment(\n        \"tspan\",\n        options,\n        TextElement.escapeForTspan(span.text)\n      );\n    }\n\n    let options = this.getSvgProps();\n    const extraStyleProperties = this.getExtraStyleProperties(ctxt)\n    options.style = getCssForProperties(extraStyleProperties);\n    if (extraStyleProperties.class) {\n      options.class = extraStyleProperties.class + ' ' + options.class;\n    }\n    if (ctxt.setFontFamilyAttributes) {\n      options[\"font-size\"] = this.fontSize(ctxt);\n    }\n\n    return QuickSvg.createFragment(\"text\", options, spans);\n  }\n}\n\nexport var LyricType = {\n  SingleSyllable: 0,\n  BeginningSyllable: 1,\n  MiddleSyllable: 2,\n  EndingSyllable: 3,\n\n  Directive: 4 // for asterisks, \"ij.\" elements, or other performance notes.\n};\n\nexport var LyricArray = {\n  getLeft: function (lyricArray) {\n    if (lyricArray.length === 0) return NaN;\n\n    var x = Number.MAX_VALUE;\n    for (var i = 0; i < lyricArray.length; i++) {\n      if (lyricArray[i])\n        x = Math.min(\n          x,\n          lyricArray[i].notation.bounds.x + lyricArray[i].bounds.x\n        );\n    }\n\n    return x;\n  },\n\n  getRight: function (lyricArray, presumeConnectorNeeded) {\n    if (lyricArray.length === 0) return NaN;\n\n    var x = Number.MIN_VALUE;\n    for (var i = 0; i < lyricArray.length; i++) {\n      let l = lyricArray[i];\n      if (l)\n        x = Math.max(\n          x,\n          l.notation.bounds.x +\n            l.bounds.x +\n            l.bounds.width +\n            (presumeConnectorNeeded && l.allowsConnector() && !l.needsConnector\n              ? l.getConnectorWidth()\n              : 0)\n        );\n    }\n\n    return x;\n  },\n\n  hasOnlyOneLyric: function (lyricArray) {\n    return lyricArray.filter((l) => l.originalText).length === 1;\n  },\n\n  indexOfLyric: function (lyricArray) {\n    return lyricArray.indexOf(lyricArray.filter((l) => l.originalText)[0]);\n  },\n\n  mergeIn: function (lyricArray, newLyrics) {\n    for (var i = 0; i < newLyrics.length; ++i) {\n      if (newLyrics[i].originalText || !lyricArray[i])\n        lyricArray[i] = newLyrics[i];\n    }\n  },\n\n  mergeInArray: function (lyricArray, notations) {\n    for (var i = 0; i < notations.length; ++i) {\n      this.mergeIn(lyricArray, notations[i].lyrics);\n    }\n  },\n\n  setNotation: function (lyricArray, notation) {\n    notation.lyrics = lyricArray;\n    for (var i = 0; i < lyricArray.length; ++i) {\n      lyricArray[i].notation = notation;\n    }\n  }\n};\n\nexport class Lyric extends TextElement {\n  constructor(ctxt, text, lyricType, notation, notations, sourceIndex) {\n    super(\n      ctxt,\n      (ctxt.textStyles.lyric.prefix || \"\") + text,\n      (ctxt) => ctxt.textStyles.lyric.font,\n      (ctxt) => ctxt.textStyles.lyric.size,\n      \"start\",\n      sourceIndex,\n      text\n    );\n    this.textType = TextTypes.lyric;\n\n    // save the original text in case we need to later use the lyric\n    // in a dropcap...\n    this.originalText = text;\n\n    this.notation = notation;\n    this.notations = notations;\n\n    if (\n      typeof lyricType === \"undefined\" ||\n      lyricType === null ||\n      lyricType === \"\"\n    )\n      this.lyricType = LyricType.SingleSyllable;\n    else this.lyricType = lyricType;\n\n    // Lyrics keep track of how to center them on notation elements.\n    // centerTextIndex is the index in this.text where the centering starts,\n    // centerLength is how many characters comprise the center point.\n    // performLayout will do the processing\n    this.centerStartIndex = -1;\n    this.centerLength = text.length;\n\n    this.needsConnector = false;\n\n    // Lyrics can have their own language defined, which affects the alignment\n    // of the text with the notation element\n    this.language = null;\n\n    if (this.allowsConnector)\n      this.connectorSpan = new TextSpan(ctxt.syllableConnector);\n  }\n\n  allowsConnector() {\n    return (\n      this.lyricType === LyricType.BeginningSyllable ||\n      this.lyricType === LyricType.MiddleSyllable\n    );\n  }\n\n  setForceConnector(force) {\n    this.forceConnector = force && this.allowsConnector();\n  }\n\n  setNeedsConnector(needs, width) {\n    if (needs === true || this.forceConnector) {\n      this.needsConnector = true;\n      if (typeof width !== \"undefined\") {\n        this.setConnectorWidth(width);\n      } else {\n        this.bounds.width =\n          this.widthWithoutConnector + this.getConnectorWidth();\n      }\n\n      if (\n        this.spans.length > 0 &&\n        this.spans[this.spans.length - 1] !== this.connectorSpan\n      )\n        this.spans.push(this.connectorSpan);\n    } else {\n      this.connectorWidth = 0;\n      this.needsConnector = false;\n      this.bounds.width = this.widthWithoutConnector;\n\n      var span = this.spans.pop();\n      if (span && span !== this.connectorSpan) this.spans.push(span);\n    }\n  }\n\n  setConnectorWidth(width) {\n    this.connectorWidth = width;\n    this.connectorSpan.textLength = width;\n    if (this.needsConnector)\n      this.bounds.width = this.widthWithoutConnector + this.getConnectorWidth();\n  }\n\n  getConnectorWidth() {\n    return this.connectorWidth || this.defaultConnectorWidth;\n  }\n\n  getLeft() {\n    return this.notation.bounds.x + this.bounds.x;\n  }\n\n  getRight() {\n    return this.notation.bounds.x + this.bounds.x + this.bounds.width;\n  }\n\n  recalculateMetrics(ctxt, resetNewLines = true) {\n    this.setNeedsConnector();\n\n    super.recalculateMetrics(ctxt, resetNewLines);\n\n    this.widthWithoutConnector = this.bounds.width;\n\n    this.connectorWidth = 0;\n    this.defaultConnectorWidth = ctxt.hyphenWidth;\n\n    var activeLanguage = this.language || ctxt.defaultLanguage;\n\n    // calculate the point where the text lines up to the staff notation\n    // and offset the rect that much. By default we just center the text,\n    // but the logic below allows for smarter lyric alignment based\n    // on manual override or language control.\n    var offset = this.widthWithoutConnector / 2,\n      x1,\n      x2,\n      vowelSegmentWidth = this.widthWithoutConnector;\n\n    // some simple checks for sanity, and disable manual centering if the numbers are bad\n    if (\n      this.centerStartIndex >= 0 &&\n      (this.centerStartIndex >= this.text.length ||\n        this.centerLength < 0 ||\n        this.centerStartIndex + this.centerLength > this.text.length)\n    )\n      this.centerStartIndex = -1;\n\n    if (this.text.length === 0) {\n      // if we have no text to work with, then there's nothing to do!\n      // Unless it's a drop cap, in which case we center the connector:\n      if (this.dropCap && this.originalText) {\n        offset = ctxt.hyphenWidth / 2;\n        vowelSegmentWidth = ctxt.hyphenWidth;\n      }\n    } else if (this.centerStartIndex >= 0) {\n      // if we have manually overriden the centering logic for this lyric,\n      // then always use that.\n      if (ctxt.textMeasuringStrategy === TextMeasuringStrategy.Svg) {\n        // svgTextMeasurer still has the current lyric in it...\n        x1 = ctxt.svgTextMeasurer.firstChild.getSubStringLength(\n          0,\n          this.centerStartIndex\n        );\n        x2 = ctxt.svgTextMeasurer.firstChild.getSubStringLength(\n          0,\n          this.centerStartIndex + this.centerLength\n        );\n      } else {\n        x1 = this.measureSubstring(ctxt, this.centerStartIndex);\n        x2 = this.measureSubstring(\n          ctxt,\n          this.centerStartIndex + this.centerLength\n        );\n      }\n      offset = (x1 + x2) / 2;\n      vowelSegmentWidth = x2 - x1;\n    } else {\n      // if it's a directive with no manual centering override, then\n      // just center the text.\n      if (this.lyricType !== LyricType.Directive) {\n        // only consider text content after the last space (if any)\n        var startIndex = this.text.lastIndexOf(\" \") + 1;\n\n        // unless there are no text characters following the space:\n        if (\n          startIndex > 0 &&\n          !this.text\n            .slice(startIndex)\n            .match(/[a-záéíóúýäëïöüÿàèìòùỳāēīōūȳăĕĭŏŭ]/i)\n        ) {\n          startIndex = 0;\n        }\n\n        // find indices of e tags to ignore when finding vowel segment:\n        var ignore = [];\n        let index = 0;\n        let indexOffset = startIndex;\n        for (var span of this.spans) {\n          let endIndex = index + span.text.length;\n          if (span.activeTags.includes('e')) {\n            if (index <= startIndex) {\n              startIndex = endIndex;\n            } else {\n              ignore.push({ index: index - indexOffset, endIndex: endIndex - indexOffset });\n            }\n          }\n          index = endIndex;\n        }\n        // Non-directive elements are lined up to the chant notation based on vowel segments,\n        var result = activeLanguage.findVowelSegment(this.text, startIndex, ignore);\n\n        if (result.found !== true) {\n          var match = this.text.slice(startIndex).match(/[a-z]+/i);\n          if (match) {\n            result.startIndex = startIndex + match.index;\n            result.length = match[0].length;\n          } else {\n            result.startIndex = startIndex;\n            result.length = this.text.length - startIndex;\n          }\n        }\n        if (ctxt.textMeasuringStrategy === TextMeasuringStrategy.Svg) {\n          // svgTextMeasurer still has the current lyric in it...\n          x1 = ctxt.svgTextMeasurer.firstChild.getSubStringLength(\n            0,\n            result.startIndex\n          );\n          x2 = ctxt.svgTextMeasurer.firstChild.getSubStringLength(\n            0,\n            result.startIndex + result.length\n          );\n        } else {\n          x1 = this.measureSubstring(ctxt, result.startIndex);\n          x2 = this.measureSubstring(ctxt, result.startIndex + result.length);\n        }\n        offset = (x1 + x2) / 2;\n        vowelSegmentWidth = x2 - x1;\n      }\n    }\n\n    this.vowelSegmentWidth = vowelSegmentWidth;\n\n    this.bounds.x = -offset;\n    this.bounds.y = 0;\n\n    this.origin.x = offset;\n  }\n\n  generateDropCap(ctxt) {\n    if (this.dropCap) return this.dropCap;\n    // disallow special characters:\n    if (this.spans[0].properties['font-family'] === ctxt.specialCharProperties['font-family']) {\n      return null;\n    }\n    let dropCapSpan = this.spans[0].clone();\n    dropCapSpan.text = dropCapSpan.text.slice(0, 1).toUpperCase();\n    let dropCapLowerCase = dropCapSpan.text.toLowerCase();\n    // disallow any characters that do not change from .toUpperCase():\n    if (dropCapSpan.text === dropCapLowerCase) return null;\n\n    if (dropCapSpan.activeTags.indexOf(\"sc\") >= 0)\n      dropCapSpan.text = dropCapLowerCase;\n\n    var dropCap = (this.dropCap = new DropCap(ctxt, \"\", this.sourceIndex));\n    dropCap.spans = [dropCapSpan];\n    let dropCapSourceGabcLength = this.sourceGabc.match(\n      /^(?:<\\/?[^>]+>)*.?(?:<\\/[^>]+>)*/\n    )[0].length;\n    dropCap.sourceGabc = this.sourceGabc.slice(0, dropCapSourceGabcLength);\n    this.sourceIndex += dropCap.sourceGabc.length;\n    this.sourceGabc = this.sourceGabc.slice(dropCapSourceGabcLength);\n\n    this.spans[0].text = this.spans[0].text.slice(1);\n    this.text = this.text.slice(1);\n    this.centerStartIndex--; // lost a letter, so adjust centering accordingly\n\n    return dropCap;\n  }\n\n  getCssClasses() {\n    var classes = this.lyricType === LyricType.Directive ? \"directive \" : \"\";\n\n    return classes + super.getCssClasses();\n  }\n\n  getExtraStyleProperties(ctxt) {\n    var props = super.getExtraStyleProperties(ctxt);\n\n    if (this.lyricType === LyricType.Directive && ctxt.autoColor === true)\n      props = Object.assign({}, props, { fill: ctxt.rubricColor });\n\n    return props;\n  }\n}\n\nexport class ChoralSign extends TextElement {\n  constructor(ctxt, text, note, sourceIndex) {\n    super(\n      ctxt,\n      (ctxt.textStyles.choralSign.prefix || \"\") + text,\n      (ctxt) => ctxt.textStyles.choralSign.font,\n      TextTypes.choralSign.size,\n      \"start\",\n      sourceIndex,\n      text\n    );\n    this.positionHint = MarkingPositionHint.Default;\n    this.note = note;\n    this.textType = TextTypes.choralSign;\n  }\n\n  recalculateMetrics(ctxt) {\n    super.recalculateMetrics(ctxt);\n  }\n\n  performLayout(ctxt) {\n    this.recalculateMetrics(ctxt);\n    this.bounds.x =\n      this.note.bounds.x +\n      Math.max(0, (ctxt.staffInterval - this.bounds.width) / 2); // center on the note itself\n\n    let offset, staffPosition;\n    if (this.positionHint === MarkingPositionHint.Below) {\n      offset = -1;\n      staffPosition = this.note.staffPosition + 2 * offset;\n      staffPosition += staffPosition % 2 === 0 ? 0.3 : 1;\n    } else {\n      offset = 1;\n      staffPosition = this.note.staffPosition + 2 * offset;\n      staffPosition += staffPosition % 2 === 0 ? 0.3 : -0.4;\n    }\n    // if (staffPosition % 2 === 0) staffPosition += offset;\n    this.bounds.y =\n      ctxt.calculateHeightFromStaffPosition(staffPosition) + this.origin.y;\n  }\n}\n\nexport class AboveLinesText extends TextElement {\n  /**\n   * @param {String} text\n   */\n  constructor(ctxt, text, notation, sourceIndex) {\n    super(\n      ctxt,\n      (ctxt.textStyles.al.prefix || \"\") + text,\n      (ctxt) => ctxt.textStyles.al.font,\n      (ctxt) => ctxt.textStyles.al.size,\n      \"start\",\n      sourceIndex,\n      text\n    );\n    this.notation = notation;\n    this.textType = TextTypes.al;\n\n    this.padding = ctxt.staffInterval / 2;\n  }\n}\n\nexport class TranslationText extends TextElement {\n  /**\n   * @param {String} text\n   */\n  constructor(ctxt, text, notation, sourceIndex) {\n    var gabcSource = text;\n    var anchor = \"start\";\n    if (text === \"/\") {\n      text = \"\";\n      anchor = \"end\";\n    } else {\n      text = (ctxt.textStyles.translation.prefix || \"\") + text;\n    }\n    super(\n      ctxt,\n      text,\n      (ctxt) => ctxt.textStyles.translation.font,\n      (ctxt) => ctxt.textStyles.translation.size,\n      anchor,\n      sourceIndex,\n      gabcSource\n    );\n    this.notation = notation;\n    this.textType = TextTypes.translation;\n\n    this.padding = ctxt.staffInterval / 2;\n  }\n}\n\nexport class DropCap extends TextElement {\n  /**\n   * @param {String} text\n   */\n  constructor(ctxt, text, sourceIndex) {\n    super(\n      ctxt,\n      (ctxt.textStyles.dropCap.prefix || \"\") + text,\n      (ctxt) => ctxt.textStyles.dropCap.font,\n      (ctxt) => ctxt.textStyles.dropCap.size,\n      \"middle\",\n      sourceIndex,\n      text\n    );\n    this.textType = TextTypes.dropCap;\n\n    this.padding = ctxt.staffInterval * ctxt.textStyles.dropCap.padding;\n  }\n}\n\nexport class TitleTextElement extends TextElement {\n  constructor(\n    ctxt,\n    text,\n    fontFamily,\n    fontSize,\n    textAnchor,\n    sourceIndex,\n    sourceGabc\n  ) {\n    super(\n      ctxt,\n      text,\n      fontFamily,\n      fontSize,\n      textAnchor,\n      sourceIndex,\n      sourceGabc\n    );\n  }\n}\n\nexport class Supertitle extends TitleTextElement {\n  constructor(ctxt, text, sourceIndex) {\n    super(\n      ctxt,\n      (ctxt.textStyles.supertitle.prefix || \"\") + text,\n      (ctxt) => ctxt.textStyles.supertitle.font,\n      (ctxt) => ctxt.textStyles.supertitle.size,\n      \"middle\",\n      sourceIndex,\n      text\n    );\n    this.textType = TextTypes.supertitle;\n\n    this.padding = (ctxt) => (\n      (Number(ctxt.textStyles.supertitle.padding) || 1) * ctxt.textStyles.supertitle.size / 3\n    );\n  }\n}\n\nexport class Title extends TitleTextElement {\n  constructor(ctxt, text, sourceIndex) {\n    super(\n      ctxt,\n      (ctxt.textStyles.title.prefix || \"\") + text,\n      (ctxt) => ctxt.textStyles.title.font,\n      (ctxt) => ctxt.textStyles.title.size,\n      \"middle\",\n      sourceIndex,\n      text\n    );\n    this.textType = TextTypes.title;\n\n    this.padding = (ctxt) => (\n      (Number(ctxt.textStyles.title.padding) || 1) * ctxt.textStyles.title.size / 3\n    );\n  }\n}\n\nexport class Subtitle extends TitleTextElement {\n  constructor(ctxt, text, sourceIndex) {\n    super(\n      ctxt,\n      (ctxt.textStyles.subtitle.prefix || \"\") + text,\n      (ctxt) => ctxt.textStyles.subtitle.font,\n      (ctxt) => ctxt.textStyles.subtitle.size,\n      \"middle\",\n      sourceIndex,\n      text\n    );\n    this.textType = TextTypes.subtitle;\n\n    this.padding = (ctxt) => (\n      (Number(ctxt.textStyles.subtitle.padding) || 1) * ctxt.textStyles.subtitle.size / 3\n    );\n  }\n}\n\nexport class TextLeftRight extends TitleTextElement {\n  constructor(ctxt, text, type, sourceIndex) {\n    super(\n      ctxt,\n      (ctxt.textStyles.leftRight.prefix || \"\") + text,\n      (ctxt) => ctxt.textStyles.leftRight.font,\n      (ctxt) => ctxt.textStyles.leftRight.size,\n      type === \"textLeft\" ? \"start\" : \"end\",\n      sourceIndex,\n      text\n    );\n    this.textType = TextTypes.leftRight;\n    this.extraClass = type === \"textLeft\" ? \"textLeft\" : \"textRight\";\n    this.headerKey = type === \"textLeft\" ? \"text-left\" : \"text-right\";\n    this.padding = (ctxt) => (\n      (Number(ctxt.textStyles.leftRight.padding) || 1) * ctxt.textStyles.leftRight.size / 5\n    );\n  }\n\n  getCssClasses() {\n    return this.extraClass + \" \" + super.getCssClasses();\n  }\n}\n\nexport class Annotation extends TextElement {\n  /**\n   * @param {String} text\n   */\n  constructor(ctxt, text, elementIndex) {\n    super(\n      ctxt,\n      (ctxt.textStyles.annotation.prefix || \"\") + text,\n      (ctxt) => ctxt.textStyles.annotation.font,\n      (ctxt) => ctxt.textStyles.annotation.size,\n      \"middle\"\n    );\n    this.sourceGabc = text;\n    if (typeof elementIndex === 'number') this.elementIndex = elementIndex;\n    this.textType = TextTypes.annotation;\n    this.padding = ctxt.staffInterval * ctxt.textStyles.annotation.padding;\n    this.dominantBaseline = \"hanging\"; // so that annotations can be aligned at the top.\n  }\n}\n\nexport class Annotations extends ChantLayoutElement {\n  /**\n   * @param {String} text\n   */\n  constructor(ctxt, ...texts) {\n    super();\n\n    this.lineHeight = 1.1;\n    this.annotations = texts.map(function (text, i) {\n      return new Annotation(ctxt, text, i);\n    });\n    this.padding = Math.max.apply(\n      null,\n      this.annotations.map(function (annotation) {\n        return annotation.padding;\n      })\n    );\n  }\n\n  updateBounds(multiplier) {\n    if (!multiplier) multiplier = 1;\n    for (var i = 0; i < this.annotations.length; ++i) {\n      var annotation = this.annotations[i];\n      annotation.bounds.x += this.bounds.x * multiplier;\n      annotation.bounds.y += this.bounds.y * multiplier;\n    }\n  }\n\n  recalculateMetrics(ctxt) {\n    this.bounds.x = 0;\n    this.bounds.y = 0;\n\n    this.bounds.width = 0;\n    this.bounds.height = 0;\n\n    this.origin.x = 0;\n    this.origin.y = 0;\n\n    let y = 0;\n    for (var i = 0; i < this.annotations.length; ++i) {\n      var annotation = this.annotations[i];\n      annotation.recalculateMetrics(ctxt);\n      this.bounds.width = Math.max(this.bounds.width, annotation.bounds.width);\n      annotation.bounds.y += y;\n      this.bounds.height = annotation.bounds.bottom();\n      this.origin.y = this.origin.y || annotation.origin.y;\n      y += annotation.fontSize(ctxt) * (annotation.resize || 1) * this.lineHeight;\n    }\n  }\n\n  draw(ctxt) {\n    this.updateBounds();\n    this.annotations.forEach(function (annotation) {\n      annotation.draw(ctxt);\n    });\n    this.updateBounds(-1);\n  }\n\n  createSvgNode(ctxt) {\n    this.updateBounds();\n    var result = this.annotations.map(function (annotation) {\n      return annotation.createSvgNode(ctxt);\n    });\n    this.updateBounds(-1);\n    return result;\n  }\n  createSvgTree(ctxt) {\n    this.updateBounds();\n    var result = this.annotations.map(function (annotation) {\n      return annotation.createSvgTree(ctxt);\n    });\n    this.updateBounds(-1);\n    return { children: result };\n  }\n\n  createSvgFragment(ctxt) {\n    this.updateBounds();\n    var result = this.annotations\n      .map(function (annotation) {\n        return annotation.createSvgFragment(ctxt);\n      })\n      .join(\"\");\n    this.updateBounds(-1);\n    return result;\n  }\n}\n\nexport class ChantNotationElement extends ChantLayoutElement {\n  constructor() {\n    super();\n\n    //double\n    this.leadingSpace = 0.0;\n    this.trailingSpace = DefaultTrailingSpace;\n    this.keepWithNext = false;\n    this.needsLayout = true;\n\n    this.lyrics = [];\n\n    /**\n     * @type {ChantScore}\n     */\n    this.score = null; // the ChantScore\n\n    /**\n     * @type {ChantLine}\n     */\n    this.line = null; // the ChantLine\n\n    this.visualizers = [];\n  }\n\n  hasLyrics() {\n    return this.lyrics.length !== 0;\n  }\n\n  getAllLyricsLeft() {\n    if (this.lyrics.length === 0) return this.bounds.right();\n\n    var x = Number.MAX_VALUE;\n    for (var i = 0; i < this.lyrics.length; i++) {\n      if (this.lyrics[i]) x = Math.min(x, this.lyrics[i].bounds.x);\n    }\n\n    return this.bounds.x + x;\n  }\n\n  getAllLyricsRight() {\n    if (this.lyrics.length === 0) return this.bounds.x;\n\n    var x = Number.MIN_VALUE;\n    for (var i = 0; i < this.lyrics.length; i++) {\n      if (this.lyrics[i])\n        x = Math.max(x, this.lyrics[i].bounds.x + this.lyrics[i].bounds.width);\n    }\n\n    return this.bounds.x + x;\n  }\n\n  // used by subclasses while building up the chant notations.\n  addVisualizer(chantLayoutElement) {\n    if (!chantLayoutElement.ignoreBounds) {\n      if (this.bounds.isEmpty())\n        this.bounds = chantLayoutElement.bounds.clone();\n      else this.bounds.union(chantLayoutElement.bounds);\n    }\n\n    this.visualizers.push(chantLayoutElement);\n  }\n\n  // same as addVisualizer, except the element is unshifted to the front\n  // of the visualizer array rather than the end. This way, some\n  // visualizers can be placed behind the others...ledger lines for example.\n  prependVisualizer(chantLayoutElement) {\n    if (this.bounds.isEmpty()) this.bounds = chantLayoutElement.bounds.clone();\n    else this.bounds.union(chantLayoutElement.bounds);\n\n    this.visualizers.unshift(chantLayoutElement);\n  }\n\n  // chant notation elements are given an opportunity to perform their layout via this function.\n  // subclasses should call this function first in overrides of this function.\n  // on completion, exsurge presumes that the bounds, the origin, and the fragment objects are\n  // all valid and prepared for higher level layout.\n  performLayout(ctxt) {\n    if (typeof this.trailingSpace === \"function\")\n      this.calculatedTrailingSpace = this.trailingSpace(ctxt);\n    else this.calculatedTrailingSpace = this.trailingSpace;\n\n    // reset the bounds and the staff notations before doing a layout\n    this.visualizers = [];\n    this.bounds = new Rect(Infinity, Infinity, -Infinity, -Infinity);\n\n    for (var i = 0; i < this.lyrics.length; i++)\n      this.lyrics[i].recalculateMetrics(ctxt);\n\n    if (this.alText)\n      for (i = 0; i < this.alText.length; i++)\n        this.alText[i].recalculateMetrics(ctxt);\n\n    if (this.translationText)\n      for (i = 0; i < this.translationText.length; i++)\n        this.translationText[i].recalculateMetrics(ctxt);\n  }\n\n  // some subclasses have internal dependencies on other notations (for example,\n  // a custos can depend on a later neume which it uses to set its height).\n  // subclasses can override this function so that when the notations are\n  // altered, the subclass can correctly invalidate (and later restore) its own\n  // depedencies\n  resetDependencies() {}\n\n  // a helper function for subclasses to call after they are done performing layout...\n  finishLayout(ctxt) {\n    this.bounds.x = 0;\n\n    let language =\n      (this.lyrics[0] && this.lyrics[0].language) || ctxt.defaultLanguage;\n    // center the neume itself over the syllable, or just the first punctum\n    // if the neume is wider than the syllable + the width of a punctum, we always revert to centering just over the punctum\n    let calculateLyricX = language.centerNeume\n      ? (lyric) =>\n          (lyric.bounds.x =\n            this.bounds.width + ctxt.staffInterval < lyric.vowelSegmentWidth\n              ? this.bounds.width / 2 - lyric.origin.x\n              : this.origin.x - lyric.origin.x)\n      : (lyric) => (lyric.bounds.x = this.origin.x - lyric.origin.x);\n    this.lyrics.forEach(calculateLyricX);\n\n    this.needsLayout = false;\n  }\n\n  draw(ctxt) {\n    var canvasCtxt = ctxt.canvasCtxt;\n    canvasCtxt.translate(this.bounds.x, 0);\n\n    for (var i = 0; i < this.visualizers.length; i++)\n      this.visualizers[i].draw(ctxt);\n\n    for (i = 0; i < this.lyrics.length; i++) this.lyrics[i].draw(ctxt);\n\n    if (this.translationText)\n      for (i = 0; i < this.translationText.length; i++)\n        this.translationText[i].draw(ctxt);\n\n    if (this.alText)\n      for (i = 0; i < this.alText.length; i++) this.alText[i].draw(ctxt);\n\n    canvasCtxt.translate(-this.bounds.x, 0);\n  }\n\n  getInnerSvgNodes(ctxt, functionName = \"createSvgNode\") {\n    var inner = [];\n\n    for (i = 0; i < this.lyrics.length; i++)\n      inner.push(this.lyrics[i][functionName](ctxt));\n\n    if (this.translationText)\n      for (i = 0; i < this.translationText.length; i++)\n        inner.push(this.translationText[i][functionName](ctxt));\n\n    if (this.alText)\n      for (i = 0; i < this.alText.length; i++)\n        inner.push(this.alText[i][functionName](ctxt));\n\n    if (this.visualizers.length) {\n      let visualizers = [];\n      for (var i = 0; i < this.visualizers.length; i++)\n        visualizers.push(this.visualizers[i][functionName](ctxt, this));\n\n      if (functionName === \"createSvgTree\") {\n        inner.push(\n          QuickSvg.createSvgTree(\"g\", { class: \"Notations\" }, ...visualizers)\n        );\n      } else {\n        inner.push(\n          QuickSvg.createNode(\"g\", { class: \"Notations\" }, visualizers)\n        );\n      }\n    }\n    return inner;\n  }\n\n  getSvgProps() {\n    return {\n      // this.constructor.name will not be the same after being mangled by UglifyJS\n      class: \"ChantNotationElement \" + (this.cssClass || this.constructor.name),\n      transform: \"translate(\" + this.bounds.x + \",\" + 0 + \")\"\n    };\n  }\n\n  createSvgNode(ctxt) {\n    var inner = this.getInnerSvgNodes(ctxt, \"createSvgNode\");\n    var svgProps = this.getSvgProps();\n    svgProps.source = this;\n    return QuickSvg.createNode(\"g\", svgProps, inner);\n  }\n  createSvgTree(ctxt) {\n    var inner = this.getInnerSvgNodes(ctxt, \"createSvgTree\");\n    var svgProps = this.getSvgProps();\n    svgProps.source = this;\n    return QuickSvg.createSvgTree(\"g\", svgProps, ...inner);\n  }\n\n  createSvgFragment(ctxt) {\n    var inner = \"\";\n\n    for (i = 0; i < this.lyrics.length; i++)\n      inner += this.lyrics[i].createSvgFragment(ctxt);\n\n    if (this.translationText)\n      for (i = 0; i < this.translationText.length; i++)\n        inner += this.translationText[i].createSvgFragment(ctxt);\n\n    if (this.alText)\n      for (i = 0; i < this.alText.length; i++)\n        inner += this.alText[i].createSvgFragment(ctxt);\n\n    for (var i = 0; i < this.visualizers.length; i++)\n      inner += this.visualizers[i].createSvgFragment(ctxt, this);\n\n    return QuickSvg.createFragment(\"g\", this.getSvgProps(), inner);\n  }\n}\n\nconst __connectorSpan = new TextSpan(\" • \");\nconst __mergeAnnotationWithTextLeft = (...annotationSpans) =>\n    annotationSpans.reduce((result, spans) => {\n      if (result && result.length) {\n        if (spans && spans.length) return result.concat(__connectorSpan, spans);\n        else return result;\n      } else if (spans && spans.length) {\n        return spans;\n      }\n      return [];\n    });\n\n\n\n// WEBPACK FOOTER //\n// ./src/Exsurge.Drawing.js","export const addAccent = (vowel) =>\n  ({\n    \"Æ\": \"Ǽ\",\n    \"Œ\": \"Œ́\",\n    \"A\": \"Á\",\n    \"E\": \"É\",\n    \"I\": \"Í\",\n    \"O\": \"Ó\",\n    \"U\": \"Ú\",\n    \"Y\": \"Ý\",\n    \"æ\": \"ǽ\",\n    \"œ\": \"œ́\",\n    \"a\": \"á\",\n    \"e\": \"é\",\n    \"i\": \"í\",\n    \"o\": \"ó\",\n    \"u\": \"ú\",\n    \"y\": \"ý\"\n  }[vowel] || vowel);\n\n\n\n// WEBPACK FOOTER //\n// ./src/addAccent.js","export const makeLigature = (vowels) =>\n  ({\n    AE: \"Æ\",\n    Ae: \"Æ\",\n    ae: \"æ\",\n    OE: \"Œ\",\n    Oe: \"Œ\",\n    oe: \"œ\"\n  }[vowels] || vowels);\n\n\n\n// WEBPACK FOOTER //\n// ./src/makeLigature.js","export const greextraGlyphs = {\n  MedicaeaFlat: \"\",\n  HufnagelCustosUpShort: \"\",\n  HufnagelCustosUpLong: \"\",\n  HufnagelCustosUpMedium: \"\",\n  HufnagelCustosDownShort: \"\",\n  HufnagelCustosDownLong: \"\",\n  HufnagelCustosDownMedium: \"\",\n  MedicaeaCustosUpShort: \"\",\n  MedicaeaCustosUpLong: \"\",\n  MedicaeaCustosUpMedium: \"\",\n  MedicaeaCustosDownShort: \"\",\n  MedicaeaCustosDownLong: \"\",\n  MedicaeaCustosDownMedium: \"\",\n  MensuralCustosUpShort: \"\",\n  MensuralCustosUpLong: \"\",\n  MensuralCustosUpMedium: \"\",\n  MensuralCustosDownShort: \"\",\n  MensuralCustosDownLong: \"\",\n  MensuralCustosDownMedium: \"\",\n  MensuralFlat: \"\",\n  HufnagelFlat: \"\",\n  MedicaeaCClef: \"\",\n  MedicaeaCClefChange: \"\",\n  MedicaeaFClef: \"\",\n  MedicaeaFClefChange: \"\",\n  HufnagelCClef: \"\",\n  HufnagelCClefChange: \"\",\n  HufnagelFClef: \"\",\n  HufnagelFClefChange: \"\",\n  HugnagelCFClef: \"\",\n  HufnagelCFClefChange: \"\",\n  MensuralFlatHole: \"\",\n  HufnagelFlatHole: \"\",\n  MedicaeaFlatHole: \"\",\n  StarSix: \"\",\n  Dagger: \"\",\n  \"Bar.alt\": \"\",\n  StarHeight: \"\",\n  Cross: \"\",\n  \"RBar.alt\": \"\",\n  \"VBar.alt\": \"\",\n  Drawing1: \"\",\n  Drawing2: \"\",\n  RWithBarGoth: \"\",\n  VWithBarGoth: \"\",\n  Line1: \"\",\n  Line2: \"\",\n  Line3: \"\",\n  Line4: \"\",\n  Line5: \"\",\n  \"Cross.alt\": \"\",\n  ABarCaption: \"\",\n  RBarCaption: \"\",\n  VBarCaption: \"\",\n  ABarCaptionSC: \"\",\n  RBarCaptionSC: \"\",\n  VBarCaptionSC: \"\",\n  ABar: \"\",\n  RBar: \"\",\n  VBar: \"\",\n  ABarSC: \"\",\n  RBarSC: \"\",\n  VBarSC: \"\",\n  ABarSmall: \"\",\n  RBarSmall: \"\",\n  VBarSmall: \"\",\n  ABarSmallSC: \"\",\n  RBarSmallSC: \"\",\n  VBarSmallSC: \"\",\n  \"RBar.alt2\": \"\",\n  \"VBar.alt2\": \"\",\n  ABarCaptionSlant: \"\",\n  RBarCaptionSlant: \"\",\n  VBarCaptionSlant: \"\",\n  ABarSlant: \"\",\n  RBarSlant: \"\",\n  VBarSlant: \"\",\n  ABarSmallSlant: \"\",\n  RBarSmallSlant: \"\",\n  VBarSmallSlant: \"\"\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/greextraGlyphs.js","//\n// Author(s):\n// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>\n//\n// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n//\n\nimport { ChantLine } from \"./Exsurge.Chant.ChantLine.js\";\nimport { InsertionCursor } from \"./Exsurge.Chant.Signs.js\";\nimport { Pitch, Rect, Step } from \"./Exsurge.Core.js\";\nimport {\n  Annotation, ChantLayoutElement,\n  ChantNotationElement,\n  GlyphCode,\n  GlyphVisualizer, QuickSvg, TextLeftRight,\n  TextSpan\n} from \"./Exsurge.Drawing.js\";\nimport { Gabc } from \"./Exsurge.Gabc.js\";\nimport { Titles } from \"./Exsurge.Titles.js\";\n\nexport var LiquescentType = {\n  None: 0,\n\n  // flags that can be combined, though of course it\n  // it doesn't make sense to combine some!\n  Large: 1 << 0,\n  Small: 1 << 1,\n  Ascending: 1 << 2,\n  Descending: 1 << 3,\n  InitioDebilis: 1 << 4,\n\n  // handy liquescent types\n  LargeAscending: (1 << 0) | (1 << 2),\n  LargeDescending: (1 << 0) | (1 << 3),\n  SmallAscending: (1 << 1) | (1 << 2),\n  SmallDescending: (1 << 1) | (1 << 3)\n};\n\nexport var NoteShape = {\n  // shapes\n  Default: 0,\n  Virga: 1,\n  Inclinatum: 2,\n  Quilisma: 3,\n  Stropha: 4,\n  Oriscus: 5\n};\n\nexport var NoteShapeModifiers = {\n  // flags which modify the shape\n  // not all of them apply to every shape of course\n  None: 0,\n  Ascending: 1 << 0,\n  Descending: 1 << 1,\n  Cavum: 1 << 2,\n  Stemmed: 1 << 3,\n  Linea: 1 << 4,\n  Reverse: 1 << 5\n};\n\n/**\n * @class\n */\nexport class Note extends ChantLayoutElement {\n  /**\n   * @para {Pitch} pitch\n   */\n  constructor(pitch) {\n    super();\n\n    if (typeof pitch !== \"undefined\") this.pitch = pitch;\n    else this.pitch = null;\n\n    this.glyphVisualizer = null;\n\n    // The staffPosition on a note is an integer that indicates the vertical position on the staff.\n    // 0 is the space just below the lowest line on the staff (equivalent to gabc 'c'). Positive numbers go up\n    // the staff, and negative numbers go down, i.e., 1 is gabc 'd', 2 is gabc 'e', -1 is gabc 'b', etc.\n    this.staffPosition = 4;\n    this.liquescent = LiquescentType.None;\n    this.shape = NoteShape.Default;\n    this.shapeModifiers = NoteShapeModifiers.None;\n\n    // notes keep track of the neume they belong to in order to facilitate layout\n    // this.neume gets set when a note is added to a neume via Neume.addNote()\n    this.neume = null;\n\n    // various markings that can exist on a note, organized by type\n    // for faster access and simpler code logic\n    this.episemata = [];\n    this.morae = []; // silly to have an array of these, but gabc allows multiple morae per note!\n\n    // these are set on the note when they are needed, otherwise, they're undefined\n    // this.ictus\n    // this.accuteAccent\n    // this.braceStart\n    // this.braceEnd\n  }\n\n  setGlyph(ctxt, glyphCode) {\n    if (this.glyphVisualizer) this.glyphVisualizer.setGlyph(ctxt, glyphCode);\n    else this.glyphVisualizer = new GlyphVisualizer(ctxt, glyphCode);\n\n    this.glyphVisualizer.setStaffPosition(ctxt, this.staffPosition);\n\n    // assign glyphvisualizer metrics to this note\n    this.bounds.x = this.glyphVisualizer.bounds.x;\n    this.bounds.y = this.glyphVisualizer.bounds.y;\n    this.bounds.width = this.glyphVisualizer.bounds.width;\n    this.bounds.height = this.glyphVisualizer.bounds.height;\n\n    this.origin.x = this.glyphVisualizer.origin.x;\n    this.origin.y = this.glyphVisualizer.origin.y;\n  }\n\n  // a utility function for modifiers\n  shapeModifierMatches(shapeModifier) {\n    if (shapeModifier === NoteShapeModifiers.None)\n      return this.shapeModifier === NoteShapeModifiers.None;\n    else return this.shapeModifier & (shapeModifier !== 0);\n  }\n\n  draw(ctxt) {\n    this.glyphVisualizer.bounds.x = this.bounds.x;\n    this.glyphVisualizer.bounds.y = this.bounds.y;\n\n    this.glyphVisualizer.draw(ctxt);\n  }\n\n  createSvgNode(ctxt) {\n    this.glyphVisualizer.bounds.x = this.bounds.x;\n    this.glyphVisualizer.bounds.y = this.bounds.y;\n    this.svgNode = this.glyphVisualizer.createSvgNode(ctxt, this);\n    return this.svgNode;\n  }\n  createSvgTree(ctxt) {\n    this.glyphVisualizer.bounds.x = this.bounds.x;\n    this.glyphVisualizer.bounds.y = this.bounds.y;\n    return this.glyphVisualizer.createSvgTree(ctxt, this);\n  }\n\n  createSvgFragment(ctxt) {\n    this.glyphVisualizer.bounds.x = this.bounds.x;\n    this.glyphVisualizer.bounds.y = this.bounds.y;\n    return this.glyphVisualizer.createSvgFragment(ctxt, this);\n  }\n}\n\nexport class Clef extends ChantNotationElement {\n  constructor(staffPosition, octave, defaultAccidental = null) {\n    super();\n\n    this.isClef = true;\n    this.staffPosition = staffPosition;\n    this.octave = octave;\n    this.defaultAccidental = defaultAccidental;\n    this.activeAccidental = defaultAccidental;\n    this.keepWithNext = true;\n  }\n\n  resetAccidentals() {\n    this.activeAccidental = this.defaultAccidental;\n  }\n\n  pitchToStaffPosition(pitch) {}\n\n  performLayout(ctxt) {\n    ctxt.activeClef = this;\n\n    if (this.defaultAccidental) this.defaultAccidental.performLayout(ctxt);\n\n    super.performLayout(ctxt);\n  }\n\n  finishLayout(ctxt) {\n    // if we have a default accidental, then add a glyph for it now\n    if (this.defaultAccidental) {\n      var accidentalGlyph = this.defaultAccidental.createGlyphVisualizer(ctxt);\n      accidentalGlyph.bounds.x +=\n        this.visualizers[0].bounds.right() + ctxt.intraNeumeSpacing;\n      this.addVisualizer(accidentalGlyph);\n    }\n\n    super.finishLayout(ctxt);\n  }\n\n  static default() {\n    return __defaultDoClef;\n  }\n\n  clone() {\n    if (this.model) return this.model.clone();\n    let clone = new this.constructor(\n      this.staffPosition,\n      this.octave,\n      this.defaultAccidental\n    );\n    clone.small = this.small;\n    clone.sourceGabc = this.sourceGabc;\n    clone.sourceIndex = this.sourceIndex;\n    clone.elementIndex = this.elementIndex;\n    clone.model = this;\n    return clone;\n  }\n}\n\nexport class DoClef extends Clef {\n  constructor(staffPosition, octave, defaultAccidental = null) {\n    super(staffPosition, octave, defaultAccidental);\n\n    this.leadingSpace = 0;\n  }\n\n  pitchToStaffPosition(pitch) {\n    return (\n      (pitch.octave - this.octave) * 7 +\n      this.staffPosition +\n      Pitch.stepToStaffOffset(pitch.step) -\n      Pitch.stepToStaffOffset(Step.Do)\n    );\n  }\n\n  staffPositionToPitch(staffPosition) {\n    var offset = staffPosition - this.staffPosition;\n    var octaveOffset = Math.floor(offset / 7);\n\n    var step = Pitch.staffOffsetToStep(offset);\n\n    if (\n      this.activeAccidental &&\n      this.activeAccidental.staffPosition === staffPosition\n    )\n      step += this.activeAccidental.accidentalType;\n\n    return new Pitch(step, this.octave + octaveOffset);\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    var glyph = new GlyphVisualizer(ctxt, GlyphCode.DoClef);\n    glyph.setStaffPosition(ctxt, this.staffPosition);\n    this.addVisualizer(glyph);\n\n    this.finishLayout(ctxt);\n  }\n}\n\nvar __defaultDoClef = new DoClef(7, 2);\n\nexport class FaClef extends Clef {\n  constructor(staffPosition, octave, defaultAccidental = null) {\n    super(staffPosition, octave, defaultAccidental);\n\n    this.leadingSpace = 0;\n  }\n\n  pitchToStaffPosition(pitch) {\n    return (\n      (pitch.octave - this.octave) * 7 +\n      this.staffPosition +\n      Pitch.stepToStaffOffset(pitch.step) -\n      Pitch.stepToStaffOffset(Step.Fa)\n    );\n  }\n\n  staffPositionToPitch(staffPosition) {\n    var offset = staffPosition - this.staffPosition + 3; // + 3 because it's a fa clef (3 == offset from Do)\n    var octaveOffset = Math.floor(offset / 7);\n\n    var step = Pitch.staffOffsetToStep(offset);\n\n    if (\n      this.activeAccidental &&\n      this.activeAccidental.staffPosition === staffPosition\n    )\n      step += this.activeAccidental.accidentalType;\n\n    return new Pitch(step, this.octave + octaveOffset);\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    var glyph = new GlyphVisualizer(ctxt, GlyphCode.FaClef);\n    glyph.setStaffPosition(ctxt, this.staffPosition);\n    this.addVisualizer(glyph);\n\n    this.finishLayout(ctxt);\n  }\n}\n\nexport class TrebleClef extends Clef {\n  constructor(staffPosition, octave, defaultAccidental = null, small = false) {\n    super(staffPosition, octave, defaultAccidental);\n\n    this.leadingSpace = 0;\n    this.small = small;\n  }\n\n  pitchToStaffPosition(pitch) {\n    return (\n      (pitch.octave - this.octave) * 7 +\n      this.staffPosition +\n      Pitch.stepToStaffOffset(pitch.step) -\n      Pitch.stepToStaffOffset(Step.So)\n    );\n  }\n\n  staffPositionToPitch(staffPosition) {\n    var offset = staffPosition - this.staffPosition + 4; // + 4 because it's a sol clef (4 == offset from Do)\n    var octaveOffset = Math.floor(offset / 7);\n\n    var step = Pitch.staffOffsetToStep(offset);\n\n    if (\n      this.activeAccidental &&\n      this.activeAccidental.staffPosition === staffPosition\n    )\n      step += this.activeAccidental.accidentalType;\n\n    return new Pitch(step, this.octave + octaveOffset);\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    var glyph = new GlyphVisualizer(ctxt, this.small ? GlyphCode.TrebleClefSmall : GlyphCode.TrebleClef);\n    glyph.setStaffPosition(ctxt, this.staffPosition);\n    this.addVisualizer(glyph);\n\n    this.finishLayout(ctxt);\n  }\n}\n\n/*\n * TextOnly\n */\nexport class TextOnly extends ChantNotationElement {\n  constructor(sourceIndex, sourceLength) {\n    super();\n    this.sourceIndex = sourceIndex;\n    this.sourceLength = sourceLength;\n    this.sourceGabc = \"\";\n    this.trailingSpace = 0;\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    // add an empty glyph as a placeholder\n    this.addVisualizer(new GlyphVisualizer(ctxt, GlyphCode.None));\n\n    this.origin.x = 0;\n    this.origin.y = -ctxt.staffInterval;\n\n    this.finishLayout(ctxt);\n  }\n}\n\nexport class ChantLineBreak extends ChantNotationElement {\n  constructor(justify) {\n    super();\n    this.calculatedTrailingSpace = this.trailingSpace = 0;\n    this.justify = justify;\n  }\n\n  performLayout(ctxt) {\n    // reset the bounds before doing a layout\n    this.bounds = new Rect(0, 0, 0, 0);\n  }\n\n  clone() {\n    var lb = new ChantLineBreak();\n    lb.justify = this.justify;\n\n    return lb;\n  }\n}\n\n// a chant mapping is a lightweight format independent way of\n// tracking how a chant language (e.g., gabc) has been\n// mapped to exsurge notations.\nexport class ChantMapping {\n  // source can be any object type. in the case of gabc, source is a text\n  // string that maps to a gabc word (e.g.: \"no(g)bis(fg)\").\n  // notations is an array of ChantNotationElements\n  constructor(source, notations, sourceIndex) {\n    this.source = source;\n    this.notations = notations;\n    this.sourceIndex = sourceIndex;\n  }\n}\n\n/*\n * Score, document\n */\nexport class ChantScore {\n  // mappings is an array of ChantMappings.\n  constructor(ctxt, mappings = [], useDropCap) {\n    this.mappings = mappings;\n\n    this.lines = [];\n    this.notes = [];\n    this.staffLineCount = 4;\n    if (ctxt) this.titles = new Titles(ctxt, this);\n\n    this.startingClef = null;\n\n    this.useDropCap = useDropCap;\n    this.dropCap = null;\n\n    this.annotation = null;\n\n    this.compiled = false;\n\n    this.autoColoring = true;\n    this.needsLayout = true;\n    this.extendLastSystemStaffLines = true;\n\n    // valid after chant lines are created...\n    this.bounds = new Rect();\n\n    if (ctxt) this.updateNotations(ctxt);\n  }\n\n  /**\n   * Make a copy of the score, only including the specified lines\n   * @param  {number} startLine starting index\n   * @param  {number} endLine   ending index\n   * @return {ChantScore}           the partial score\n   */\n  copyLines(startLine, endLine) {\n    let result = new ChantScore();\n    result.lines = this.lines.slice(startLine, endLine);\n    result.bounds = this.bounds.clone();\n    let lastLine = result.lines.slice(-1)[0];\n    result.bounds.height = lastLine.bounds.bottom() - lastLine.origin.y;\n    if (startLine === 0) {\n      result.titles = this.titles;\n      result.dropCap = this.dropCap;\n      result.annotation = this.annotation;\n    }\n    return result;\n  }\n\n  updateSelection(selection) {\n    this.selection = selection;\n    const elementSelection = (selection && selection.element) || {\n      indices: []\n    };\n    const selectedIndices = elementSelection.indices;\n    let insertion = elementSelection.insertion;\n    if (\n      !insertion &&\n      selectedIndices.length === 1 &&\n      this.notes[selectedIndices[0]] instanceof TextOnly\n    ) {\n      // if there is only one selection, and its a text only, it should display as an insertion cursor:\n      insertion = { afterElementIndex: selectedIndices[0] };\n    }\n    // update the selected elements so that they can be given a .selected class when rendered\n    for (let i = 0; i < this.notes.length; ++i) {\n      let element = this.notes[i];\n      element.selected = selectedIndices.includes(i);\n    }\n    (\n      this.startingClef.model || this.startingClef\n    ).selected = selectedIndices.includes(-1);\n    for (let i = 0; i < this.lines.length; ++i) {\n      this.lines[i].insertionCursor = null;\n    }\n    // update the insertion cursor, so it can be drawn on the correct system\n    this.insertionElement = null;\n    let insertionLine = null;\n    if (insertion) {\n      if (typeof insertion.chantLine === \"number\") {\n        insertionLine = this.lines[insertion.chantLine];\n        this.insertionElement = insertionLine.startingClef;\n        insertionLine.insertionCursor = new InsertionCursor();\n      } else if (typeof insertion.afterElementIndex === \"number\") {\n        this.insertionElement = this.notes[insertion.afterElementIndex];\n        if (!this.insertionElement) {\n          insertionLine = this.lines[0];\n          this.insertionElement = insertionLine.startingClef;\n        } else if (this.insertionElement.neume) {\n          this.insertionElement = this.insertionElement.neume;\n        }\n        if (!insertionLine) {\n          insertionLine = this.insertionElement.line || this.lines[this.lines.length - 1];\n        }\n        insertionLine.insertionCursor = new InsertionCursor();\n      }\n    }\n  }\n\n  updateNotations(ctxt) {\n    var i, j, mapping, notation;\n\n    // flatten all mappings into one array for N(0) access to notations\n    this.notations = [];\n    this.notes = [];\n    this.hasLyrics = false;\n    this.hasAboveLinesText = false;\n    this.hasTranslations = false;\n    const elementSelection = (this.selection && this.selection.element) || {\n      indices: []\n    };\n    const selectedIndices = elementSelection.indices;\n    let nonNoteElementCount = 0;\n\n    // find the starting clef...\n    // start with a default clef in case the notations don't provide one.\n    this.startingClef = null;\n\n    for (i = 0; i < this.mappings.length; i++) {\n      mapping = this.mappings[i];\n      for (j = 0; j < mapping.notations.length; j++) {\n        notation = mapping.notations[j];\n        notation.score = this;\n        notation.mapping = mapping;\n\n        if (!this.startingClef) {\n          if (notation.isNeume) {\n            this.startingClef = Clef.default();\n          } else if (notation.isClef) {\n            this.startingClef = notation;\n            continue;\n          }\n        }\n\n        notation.notationIndex = this.notations.push(notation) - 1;\n        if (!this.hasLyrics && notation.hasLyrics()) this.hasLyrics = true;\n        if (!this.hasAboveLinesText && notation.alText)\n          this.hasAboveLinesText = true;\n        if (!this.hasTranslations && notation.translationText)\n          this.hasTranslations = true;\n\n        // Update this.notes and find element indices:\n        let elements = notation.notes || [notation];\n        for (let element of elements) {\n          let elementIndex = (element.elementIndex =\n            this.notes.push(element) - 1);\n          if (element instanceof Note) {\n            element.noteIndex = elementIndex - nonNoteElementCount;\n          } else {\n            ++nonNoteElementCount;\n          }\n          \n          element.selected = selectedIndices.includes(elementIndex);\n        }\n      }\n    }\n\n    // if we've reached this far and we *still* don't have a clef, then there aren't even\n    // any neumes in the score. still, set the default clef just for good measure\n    if (!this.startingClef) this.startingClef = Clef.default();\n    this.startingClef.elementIndex = -1;\n\n    // update drop cap\n    if (this.useDropCap) this.recreateDropCap(ctxt);\n    else this.dropCap = null;\n\n    this.needsLayout = true;\n  }\n\n  recreateDropCap(ctxt) {\n    this.dropCap = null;\n\n    // find the first notation with lyrics to use\n    for (var i = 0; i < this.notations.length; i++) {\n      if (\n        this.notations[i].hasLyrics() &&\n        this.notations[i].lyrics[0] !== null &&\n        this.notations[i].lyrics[0].spans &&\n        this.notations[i].lyrics[0].spans.length\n      ) {\n        let notation = this.notations[i],\n          lyrics = notation.lyrics[0];\n        if (this.useDropCap) {\n          this.dropCap = lyrics.generateDropCap(ctxt);\n        } else {\n          lyrics.dropCap = null;\n          lyrics.generateSpansFromText(ctxt, lyrics.originalText);\n        }\n        notation.needsLayout = true;\n        return;\n      }\n    }\n  }\n\n  /**\n   * Shared layout initialization method for performLayout() and performLayoutAsync()\n   * @param  {ChantContext} ctxt\n   */\n  initializeLayout(ctxt) {\n    // setup the context\n    ctxt.activeClef = this.startingClef;\n    ctxt.notations = this.notations;\n    ctxt.currNotationIndex = 0;\n    ctxt.staffLineCount = this.staffLineCount;\n\n    if (this.dropCap) this.dropCap.recalculateMetrics(ctxt);\n\n    if (this.annotation) this.annotation.recalculateMetrics(ctxt);\n  }\n\n  // this is the the synchronous version of performLayout that\n  // process everything without yielding to any other workers/threads.\n  // good for server side processing or very small chant pieces.\n  performLayout(ctxt, force) {\n    if (!force && this.needsLayout === false) return; // nothing to do here!\n\n    ctxt.updateHyphenWidth();\n\n    this.initializeLayout(ctxt);\n\n    for (let i = 0; i < this.notations.length; i++) {\n      let notation = this.notations[i];\n      if (force || notation.needsLayout) {\n        ctxt.currNotationIndex = i;\n        notation.performLayout(ctxt);\n      }\n    }\n\n    this.needsLayout = false;\n  }\n\n  // for web applications, probably performLayoutAsync would be more\n  // apppropriate that the above performLayout, since it will process\n  // the notations without locking up the UI thread.\n  performLayoutAsync(ctxt, finishedCallback) {\n    if (this.needsLayout === false) {\n      if (finishedCallback) setTimeout(() => finishedCallback(), 0);\n\n      return; // nothing to do here!\n    }\n\n    if (ctxt.onFontLoaded) {\n      ctxt.onFontLoaded.push(() =>\n        this.performLayoutAsync(ctxt, finishedCallback)\n      );\n      return;\n    }\n\n    // check for sane value of hyphen width:\n    ctxt.updateHyphenWidth();\n    if (\n      !ctxt.hyphenWidth ||\n      ctxt.hyphenWidth / ctxt.textStyles.lyric.size > 0.6\n    ) {\n      setTimeout(() => {\n        this.performLayoutAsync(ctxt, finishedCallback);\n      }, 100);\n      return;\n    }\n\n    this.initializeLayout(ctxt);\n\n    setTimeout(() => this.layoutElementsAsync(ctxt, 0, finishedCallback), 0);\n  }\n\n  layoutElementsAsync(ctxt, index, finishedCallback) {\n    if (index >= this.notations.length) {\n      this.needsLayout = false;\n\n      if (finishedCallback) setTimeout(() => finishedCallback(), 0);\n\n      return;\n    }\n\n    if (index === 0) ctxt.activeClef = this.startingClef;\n\n    var timeout = new Date().getTime() + 50; // process for fifty milliseconds\n    do {\n      var notation = this.notations[index];\n      if (notation.needsLayout) {\n        ctxt.currNotationIndex = index;\n        notation.performLayout(ctxt);\n      }\n\n      index++;\n    } while (index < this.notations.length && new Date().getTime() < timeout);\n\n    // schedule the next block of processing\n    setTimeout(\n      () => this.layoutElementsAsync(ctxt, index, finishedCallback),\n      0\n    );\n  }\n\n  layoutChantLines(ctxt, width, finishedCallback) {\n    this.lines = [];\n\n    if (ctxt.mergeAnnotationWithTextLeft && this.annotation && !this.dropCap) {\n      let annotation = this.annotation,\n        annotationSpans = annotation.annotations\n          ? annotation.annotations.map((annotation) => annotation.spans)\n          : [annotation.spans];\n      this.overrideTextLeft = new TextLeftRight(ctxt, \"\", \"textLeft\");\n      if (ctxt.mapAnnotationSpansToTextLeft) {\n        annotationSpans = annotationSpans.map(ctxt.mapAnnotationSpansToTextLeft);\n      }\n      this.overrideTextLeft.spans = ctxt.mergeAnnotationWithTextLeft(\n        ...annotationSpans,\n        this.titles.textLeft && this.titles.textLeft.spans\n      );\n    } else {\n      this.overrideTextLeft = null;\n    }\n\n    var y = width > 0 ? this.titles.layoutTitles(ctxt, width) : 0;\n    var currIndex = 0;\n\n    ctxt.activeClef = this.startingClef;\n\n    var spaceBetweenSystems = ctxt.staffInterval * ctxt.spaceBetweenSystems;\n\n    do {\n      var line = new ChantLine(this);\n\n      line.buildFromChantNotationIndex(ctxt, currIndex, width);\n      currIndex = line.notationsStartIndex + line.numNotationsOnLine;\n      line.performLayout(ctxt);\n      line.elementIndex = this.lines.length;\n      this.lines.push(line);\n\n      line.bounds.y = -line.bounds.y + y;\n      y += line.bounds.height + spaceBetweenSystems;\n    } while (currIndex < this.notations.length);\n\n    var firstLine = this.lines[0];\n\n    this.bounds.x = 0;\n    this.bounds.y = 0;\n    this.bounds.width = firstLine.bounds.width;\n    this.bounds.height = y - spaceBetweenSystems;\n\n    this.pages = [this];\n\n    if (this.selection) {\n      this.updateSelection(this.selection);\n    }\n\n    if (finishedCallback) finishedCallback(this);\n  }\n\n  paginate(height) {\n    if (!height) return;\n    this.pages = [];\n    let pageHeightOffset = 0,\n      startLineIndex = 0;\n    for (let i = 1; i < this.lines.length; ++i) {\n      let line = this.lines[i];\n      let pageHeight = line.bounds.bottom() - pageHeightOffset - line.origin.y;\n\n      if (pageHeight > height) {\n        // this line will be the first on the new page\n        this.pages.push(this.copyLines(startLineIndex, i));\n        startLineIndex = i;\n        pageHeightOffset = line.bounds.y - line.origin.y;\n        line.bounds.y = line.origin.y;\n      } else {\n        // not a new page yet...update the bounds:\n        line.bounds.y -= pageHeightOffset;\n      }\n    }\n    this.pages.push(this.copyLines(startLineIndex, this.lines.length));\n  }\n\n  draw(ctxt, scale = 1) {\n    ctxt.setCanvasSize(this.bounds.width, this.bounds.height, scale);\n\n    var canvasCtxt = ctxt.canvasCtxt;\n\n    canvasCtxt.clearRect(0, 0, ctxt.canvas.width, ctxt.canvas.height);\n\n    canvasCtxt.translate(this.bounds.x, this.bounds.y);\n\n    if (this.titles) this.titles.draw(ctxt);\n\n    for (var i = 0; i < this.lines.length; i++) this.lines[i].draw(ctxt);\n\n    canvasCtxt.translate(-this.bounds.x, -this.bounds.y);\n  }\n\n  getSvgProps(ctxt, zoom) {\n    let width =\n        typeof zoom === \"number\"\n          ? zoom * this.bounds.width\n          : zoom\n          ? undefined\n          : this.bounds.width,\n      height = zoom ? undefined : this.bounds.height;\n\n    return {\n      xmlns: QuickSvg.ns,\n      \"xmlns:xlink\": QuickSvg.xlink,\n      version: \"1.1\",\n      class: \"Exsurge ChantScore\" + (ctxt.editable ? \" EditableChantScore\" : \"\"),\n      width,\n      height,\n      viewBox: [0, 0, this.bounds.width, this.bounds.height].join(\" \")\n    };\n  }\n\n  createSvgNode(ctxt) {\n    // create defs section\n    var node = [ctxt.defsNode.cloneNode(true)];\n    node[0].appendChild(ctxt.createStyleNode());\n\n    if (this.titles) node.push(this.titles.createSvgNode(ctxt));\n\n    for (var i = 0; i < this.lines.length; i++)\n      node.push(this.lines[i].createSvgNode(ctxt));\n\n    node = QuickSvg.createNode(\"g\", {}, node);\n\n    node = QuickSvg.createNode(\"svg\", this.getSvgProps(ctxt), node);\n\n    node.source = this;\n    this.svg = node;\n\n    return node;\n  }\n\n  createSvgTree(ctxt, zoom) {\n    // create defs section\n    var node = [\n      QuickSvg.createSvgTree(\n        \"defs\",\n        {},\n        ...ctxt.makeDefs.map((makeDef) => makeDef.makeSvgTree()),\n        ctxt.createStyleTree()\n      )\n    ];\n\n    if (this.titles) node.push(this.titles.createSvgTree(ctxt));\n\n    for (var i = 0; i < this.lines.length; i++)\n      node.push(this.lines[i].createSvgTree(ctxt));\n\n    node = QuickSvg.createSvgTree(\"g\", {}, ...node);\n    let svgProps = this.getSvgProps(ctxt, zoom);\n    svgProps.source = this;\n    node = QuickSvg.createSvgTree(\"svg\", svgProps, node);\n\n    return node;\n  }\n\n  createSvg(ctxt) {\n    var fragment = \"\";\n\n    // create defs section\n    for (var def in ctxt.defs)\n      if (ctxt.defs.hasOwnProperty(def)) fragment += ctxt.defs[def];\n    fragment += ctxt.createStyle();\n\n    fragment = QuickSvg.createFragment(\"defs\", {}, fragment);\n\n    if (this.titles) fragment += this.titles.createSvgFragment(ctxt);\n\n    for (var i = 0; i < this.lines.length; i++)\n      fragment += this.lines[i].createSvgFragment(ctxt);\n\n    fragment = QuickSvg.createFragment(\"g\", {}, fragment);\n\n    fragment = QuickSvg.createFragment(\"svg\", this.getSvgProps(ctxt), fragment);\n\n    return fragment;\n  }\n\n  createSvgNodeForEachLine(ctxt) {\n    var node = [];\n\n    var top = 0;\n    for (var i = 0; i < this.lines.length; i++) {\n      var lineFragment = [\n        ctxt.defsNode.cloneNode(true),\n        this.lines[i].createSvgNode(ctxt, top)\n      ];\n      lineFragment[0].appendChild(ctxt.createStyleNode());\n      var height = this.lines[i].bounds.height + ctxt.staffInterval * 1.5;\n      lineFragment = QuickSvg.createNode(\"g\", {}, lineFragment);\n      lineFragment = QuickSvg.createNode(\n        \"svg\",\n        {\n          xmlns: QuickSvg.ns,\n          version: \"1.1\",\n          class: \"Exsurge ChantScore\",\n          width: this.bounds.width,\n          height: height,\n          viewBox: [0, 0, this.bounds.width, height].join(\" \")\n        },\n        lineFragment\n      );\n      node.push(lineFragment);\n      top += height;\n    }\n    return node;\n  }\n\n  createSvgForEachLine(ctxt) {\n    var fragment = \"\",\n      fragmentDefs = \"\";\n\n    // create defs section\n    for (var def in ctxt.defs)\n      if (ctxt.defs.hasOwnProperty(def)) fragmentDefs += ctxt.defs[def];\n    fragmentDefs += ctxt.createStyle();\n\n    fragmentDefs = QuickSvg.createFragment(\"defs\", {}, fragmentDefs);\n    var top = 0;\n    for (var i = 0; i < this.lines.length; i++) {\n      var lineFragment =\n        fragmentDefs + this.lines[i].createSvgFragment(ctxt, top);\n      var height = this.lines[i].bounds.height + ctxt.staffInterval * 1.5;\n      lineFragment = QuickSvg.createFragment(\"g\", {}, lineFragment);\n      lineFragment = QuickSvg.createFragment(\n        \"svg\",\n        {\n          xmlns: QuickSvg.ns,\n          version: \"1.1\",\n          \"xmlns:xlink\": QuickSvg.xlink,\n          class: \"Exsurge ChantScore\",\n          width: this.bounds.width,\n          height: height\n        },\n        lineFragment\n      );\n      fragment += lineFragment;\n      top += height;\n    }\n    return fragment;\n  }\n\n  unserializeFromJson(data, ctxt) {\n    this.autoColoring = data[\"auto-coloring\"];\n\n    if (data.annotation !== null && data.annotation !== \"\") {\n      // create the annotation\n      this.annotation = new Annotation(ctxt, data.annotation);\n    } else this.annotation = null;\n\n    var createDropCap = data[\"drop-cap\"] === \"auto\" ? true : false;\n\n    Gabc.parseChantNotations(data.notations, this, createDropCap);\n  }\n\n  serializeToJson() {\n    var data = {};\n\n    data[\"type\"] = \"score\";\n    data[\"auto-coloring\"] = true;\n\n    if (this.annotation !== null)\n      data.annotation = this.annotation.unsanitizedText;\n    else data.annotation = \"\";\n\n    return data;\n  }\n}\n\nexport class ChantDocument {\n  constructor() {\n    var defaults = {\n      layout: {\n        units: \"mm\",\n        \"default-font\": {\n          \"font-family\": \"Crimson\",\n          \"font-size\": 14\n        },\n        page: {\n          width: 8.5,\n          height: 11,\n          \"margin-left\": 0,\n          \"margin-top\": 0,\n          \"margin-right\": 0,\n          \"margin-bottom\": 0\n        }\n      },\n      scores: []\n    };\n\n    // default layout\n    this.copyLayout(this, defaults);\n\n    this.scores = defaults.scores;\n  }\n\n  copyLayout(to, from) {\n    to.layout = {\n      units: from.layout.units,\n      \"default-font\": {\n        \"font-family\": from.layout[\"default-font\"][\"font-family\"],\n        \"font-size\": from.layout[\"default-font\"][\"font-size\"]\n      },\n      page: {\n        width: from.layout.page.width,\n        height: from.layout.page.height,\n        \"margin-left\": from.layout.page[\"margin-left\"],\n        \"margin-top\": from.layout.page[\"margin-top\"],\n        \"margin-right\": from.layout.page[\"margin-right\"],\n        \"margin-bottom\": from.layout.page[\"margin-bottom\"]\n      }\n    };\n  }\n\n  unserializeFromJson(data) {\n    this.copyLayout(this, data);\n\n    this.scores = [];\n\n    // read in the scores\n    for (var i = 0; i < data.scores.length; i++) {\n      var score = new ChantScore();\n\n      score.unserializeFromJson(data.scores[i]);\n      this.scores.push(score);\n    }\n  }\n\n  serializeToJson() {\n    var data = {};\n\n    this.copyLayout(data, this);\n\n    data.scores = [];\n\n    // save scores...\n    for (var i = 0; i < this.scores.length; i++)\n      data.scores.push(this.scores[i].serializeToJson());\n\n    return data;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Exsurge.Chant.js","//\n// Author(s):\n// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>\n//\n// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n//\n\nimport { ChantLineBreak, NoteShape, TextOnly } from \"./Exsurge.Chant.js\";\nimport {\n  BraceAttachment, BracePoint, BraceShape, HorizontalEpisemaAlignment\n} from \"./Exsurge.Chant.Markings.js\";\nimport {\n  Custos,\n  DoubleBar,\n  FullBar\n} from \"./Exsurge.Chant.Signs.js\";\nimport { Point, Rect } from \"./Exsurge.Core.js\";\nimport {\n  ChantLayoutElement, CurlyBraceVisualizer, GlyphCode, Lyric,\n  LyricArray,\n  LyricType, MarkingPositionHint, QuickSvg, RoundBraceVisualizer\n} from \"./Exsurge.Drawing.js\";\nimport { Glyphs } from \"./Exsurge.Glyphs.js\";\n\n// a chant line represents one staff line on the page. ChantLines are created by the score\n// and laid out by the page\nexport class ChantLine extends ChantLayoutElement {\n  constructor(score) {\n    super();\n\n    this.score = score;\n\n    this.notationsStartIndex = 0;\n    this.numNotationsOnLine = 0;\n    this.notationBounds = null; // Rect\n\n    this.staffLeft = 0;\n    this.staffRight = 0;\n\n    this.startingClef = null; // necessary for the layout process\n    this.custos = null;\n\n    this.justify = true;\n\n    // these are markings that exist at the chant line level rather than at the neume level.\n    this.ledgerLines = [];\n    this.braces = [];\n\n    this.nextLine = null;\n    this.previousLine = null; // for layout assistance\n\n    this.lyricLineHeight = 0; // height of each text line\n    this.lyricLineBaseline = 0; // offsets from the top of the text line to the baseline\n    this.numLyricLines = 0; // maximum count of lyrics on the same syllable\n\n    // fixme: make these configurable values from the score\n    this.spaceAfterNotations = 0; // the space between the notation bounds and the first text track\n    this.spaceBetweenTextTracks = 0; // spacing between each text track\n\n    this.lastLyrics = [];\n  }\n\n  get staffSpaces() {\n    return this.score.staffLineCount - 1;\n  }\n\n  performLayout(ctxt) {\n    // start off with a rectangle that holds at least the four staff lines\n    const staffSpaces = this.staffSpaces;\n    const staffLineCount = this.score.staffLineCount;\n    this.notationBounds = new Rect(\n      this.staffLeft,\n      -(ctxt.staffLineWeight / 2 + staffLineCount * 2 - 1 + ctxt.minSpaceAboveStaff) *\n        ctxt.staffInterval,\n      this.staffRight - this.staffLeft,\n      (ctxt.staffLineWeight + (staffSpaces * 2) + ctxt.minSpaceAboveStaff) * ctxt.staffInterval\n    );\n\n    // run through all the elements of the line and calculate the bounds of the notations,\n    // as well as the bounds of each text track we will use\n    var i;\n    var notations = this.score.notations;\n    var lastNeumeIndex =\n      this.extraTextOnlyIndex === null\n        ? this.notationsStartIndex + this.numNotationsOnLine\n        : this.extraTextOnlyIndex;\n    var lastIndex = this.notationsStartIndex + this.numNotationsOnLine;\n    var notation = null;\n\n    this.notationBounds.union(this.startingClef.bounds);\n\n    // reset the lyric line offsets before we [re]calculate them now\n    this.lyricLineHeight = ctxt.textStyles.lyric.size * (ctxt.textStyles.lyric.lineHeight || 1.1);\n    this.lyricLineBaseline = 0;\n    this.numLyricLines = 0;\n\n    this.altLineHeight = 0;\n    this.altLineBaseline = 0;\n    this.numAltLines = 0;\n\n    this.translationLineHeight = ctxt.textStyles.translation.size * (ctxt.textStyles.translation.lineHeight || 1.1);\n    this.translationLineBaseline = 0;\n    this.numTranslationLines = 0;\n\n    const aboveLinesLineHeight = ctxt.textStyles.al.size * (ctxt.textStyles.al.lineHeight || 1.1);\n\n    for (i = this.notationsStartIndex; i < lastNeumeIndex; i++) {\n      notation = notations[i];\n\n      if (notation.bounds.height || notation.bounds.width)\n        this.notationBounds.union(notation.bounds);\n\n      // keep track of lyric line offsets\n      if (notation.lyrics.length && notation.lyrics[0].text) {\n        // if (notation.lyrics[0].bounds.height > this.lyricLineHeight)\n        //   this.lyricLineHeight = notation.lyrics[0].bounds.height;\n        if (notation.lyrics[0].origin.y > this.lyricLineBaseline)\n          this.lyricLineBaseline = notation.lyrics[0].origin.y;\n        if (notation.lyrics.length > this.numLyricLines)\n          this.numLyricLines = notation.lyrics.length;\n      }\n\n      if (notation.alText && this.numAltLines < notation.alText.length) {\n        if (notation.alText[0].bounds.height > this.altLineHeight)\n          this.altLineHeight = notation.alText[0].bounds.height;\n        if (notation.alText[0].origin.y > this.altLineBaseline)\n          this.altLineBaseline = notation.alText[0].origin.y;\n        if (notation.alText.length > this.numAltLines)\n          this.numAltLines = notation.alText.length;\n      }\n\n      if (\n        notation.translationText &&\n        notation.translationText[0] &&\n        notation.translationText[0].text\n      ) {\n        // if (\n        //   notation.translationText[0].bounds.height > this.translationLineHeight\n        // )\n        //   this.translationLineHeight =\n        //     notation.translationText[0].bounds.height;\n        if (notation.translationText[0].origin.y > this.translationLineBaseline)\n          this.translationLineBaseline = notation.translationText[0].origin.y;\n        if (notation.translationText.length > this.numTranslationLines)\n          this.numTranslationLines = notation.translationText.length;\n      }\n    }\n\n    if (this.custos) this.notationBounds.union(this.custos.bounds);\n\n    // add any braces to the notationBounds as well\n    for (i = 0; i < this.braces.length; i++)\n      this.notationBounds.union(this.braces[i].bounds);\n\n    // finalize the lyrics placement\n    var notationBoundsOffset =\n      this.notationBounds.bottom() +\n      ctxt.minSpaceBelowStaff * ctxt.staffInterval;\n    this.lyricLineBaseline += notationBoundsOffset;\n    this.translationLineBaseline += notationBoundsOffset;\n    this.altLineBaseline +=\n      this.notationBounds.y - this.altLineHeight - ctxt.staffInterval * 0.5;\n\n    for (i = this.notationsStartIndex; i < lastNeumeIndex; i++) {\n      notation = notations[i];\n      var offset = 0;\n      for (var j = 0; j < notation.lyrics.length; j++) {\n        notation.lyrics[j].bounds.y = offset + this.lyricLineBaseline;\n        offset += this.lyricLineHeight;\n      }\n\n      if (notation.translationText) {\n        for (j = 0; j < notation.translationText.length; j++) {\n          notation.translationText[j].bounds.y =\n            offset + this.translationLineBaseline;\n          offset += this.translationLineHeight;\n        }\n      }\n\n      if (notation.alText) {\n        offset = 0;\n        for (j = 0; j < notation.alText.length; j++) {\n          notation.alText[j].bounds.y = offset + this.altLineBaseline;\n          offset -= aboveLinesLineHeight;\n        }\n      }\n    }\n\n    this.extraTextOnlyHeight = 0;\n    // handle placement of extra TextOnly elements:\n    if (ctxt.useExtraTextOnly) {\n      var extraTextOnlyLyricIndex = this.extraTextOnlyLyricIndex;\n      if (this.extraTextOnlyIndex === null) {\n        // even if extraTextOnlyIndex is null, there might be extra lines on the last lyric if it is TextOnly:\n        let lastNotation = notations[lastNeumeIndex - 1] || {};\n        if (lastNotation.constructor === ChantLineBreak)\n          lastNotation = notations[lastNeumeIndex - 2];\n        if (\n          lastNotation.constructor === TextOnly &&\n          lastNotation.lyrics.length === 1 &&\n          lastNotation.lyrics[0].bounds.height > this.lyricLineHeight\n        ) {\n          this.extraTextOnlyHeight = this.lyricLineHeight;\n        }\n      } else {\n        let lastLyrics = null;\n        let xOffset = 0;\n        offset = (this.numLyricLines - 1) * this.lyricLineHeight;\n        offset += this.numTranslationLines * this.translationLineHeight;\n        let extraLines = 0;\n        for (i = this.extraTextOnlyIndex; i < lastIndex; i++) {\n          notation = notations[i];\n          if (!notation.lyrics[extraTextOnlyLyricIndex]) continue;\n          lastLyrics = notation.lyrics[extraTextOnlyLyricIndex];\n          if (lastLyrics.lineWidth) {\n            xOffset = this.staffRight - lastLyrics.lineWidth;\n            offset += this.lyricLineHeight;\n            extraLines++;\n          }\n          extraLines += lastLyrics.numLines - 1;\n          lastLyrics.bounds.y = offset + this.lyricLineBaseline;\n          notation.bounds.x += xOffset;\n        }\n        this.extraTextOnlyHeight = this.lyricLineHeight * extraLines;\n      }\n    }\n\n    if (this.startingClef.hasLyrics()) {\n      offset = 0;\n      for (j = 0; j < this.startingClef.lyrics.length; j++) {\n        this.startingClef.lyrics[j].bounds.y = offset + this.lyricLineBaseline;\n        offset += this.lyricLineHeight;\n      }\n    }\n\n    // dropCap and the annotations\n    if (this.notationsStartIndex === 0) {\n      if (this.score.annotation !== null) {\n        // annotations use dominant-baseline to align text to the top\n        this.score.annotation.bounds.x = this.staffLeft / 2;\n        this.score.annotation.bounds.y = -ctxt.staffInterval * (staffLineCount * 2 - 1);\n        if (this.score.dropCap !== null) {\n          var lowestPossibleAnnotationY =\n            this.lyricLineBaseline -\n            this.score.annotation.bounds.height -\n            ctxt.staffInterval * ctxt.textStyles.annotation.padding -\n            this.score.dropCap.origin.y;\n          // if the annotation would overlap with the drop cap, move the annotation higher.\n          // otherwise, center the annotation in the vertical space between the top of the drop cap and the top of the staff.\n          if (lowestPossibleAnnotationY < this.score.annotation.bounds.y) {\n            this.score.annotation.bounds.y = lowestPossibleAnnotationY;\n          } else {\n            this.score.annotation.bounds.y =\n              (this.score.annotation.bounds.y + lowestPossibleAnnotationY) / 2;\n          }\n          if (this.score.annotation.bounds.y < this.notationBounds.y) {\n            this.notationBounds.y = this.score.annotation.bounds.y;\n            this.notationBounds.height +=\n              this.notationBounds.y - this.score.annotation.bounds.y;\n          }\n        }\n        this.score.annotation.bounds.y += this.score.annotation.origin.y;\n      }\n\n      if (this.score.dropCap !== null) {\n        // drop caps and annotations are drawn from their center, so aligning them\n        // horizontally is as easy as this.staffLeft / 2\n        this.score.dropCap.bounds.x = this.staffLeft / 2;\n        this.score.dropCap.bounds.y =\n          this.lyricLineBaseline - this.score.dropCap.origin.y;\n        this.notationBounds.union(this.score.dropCap.bounds);\n        this.score.dropCap.bounds.y = this.lyricLineBaseline;\n      }\n    }\n\n    if (this.numLyricLines > 0) {\n      // add up the lyric line heights to get the total height of the chant line\n      var lyricAndTextRect = new Rect(\n        0,\n        notationBoundsOffset,\n        0,\n        this.lyricLineHeight * this.numLyricLines +\n          this.extraTextOnlyHeight +\n          this.translationLineHeight * this.numTranslationLines\n      );\n      this.notationBounds.union(lyricAndTextRect);\n    }\n    if (this.numAltLines > 0) {\n      var altLineTextRect = new Rect(\n        0,\n        this.notationBounds.y -\n          this.altLineHeight -\n          0.5 * ctxt.staffInterval -\n          aboveLinesLineHeight * (this.numAltLines - 1),\n        0,\n        aboveLinesLineHeight * this.numAltLines\n      );\n      this.notationBounds.union(altLineTextRect);\n    }\n    // Ensure that there is at least minSpaceBelowStaff below the lowest staff line:\n    this.notationBounds.union(\n      new Rect(\n        0,\n        -ctxt.staffInterval, // lowest staff line\n        0,\n        (ctxt.staffLineWeight / 2 + ctxt.minSpaceBelowStaff) *\n          ctxt.staffInterval\n      )\n    );\n    var totalHeight = this.notationBounds.height;\n\n    this.bounds.x = 0;\n    this.bounds.y = this.notationBounds.y;\n    this.bounds.width = this.notationBounds.right();\n    this.bounds.height = totalHeight;\n\n    // the origin of the chant line's coordinate space is at the center line of the left extremity of the staff\n    this.origin = new Point(this.staffLeft, -this.notationBounds.y);\n  }\n\n  // TODO: remove if not necsessary\n  layoutInsertionCursor(ctxt) {\n    if (this.insertionCursor) {\n      // we have either a Notation to draw the cursor after, or the ChantLine itself when the cursor is the first thing on the line\n      this.insertionCursor.performLayout(ctxt);\n      this.insertionCursor.bounds.x =\n        this.score.insertionElement.bounds.right() +\n        ((this.score.insertionElement.trailingSpace &&\n          this.score.insertionElement.calculatedTrailingSpace) ||\n          0) /\n          2 -\n        this.insertionCursor.origin.x;\n    }\n    return this.insertionCursor;\n  }\n\n  draw(ctxt) {\n    var canvasCtxt = ctxt.canvasCtxt;\n\n    canvasCtxt.translate(this.bounds.x, this.bounds.y);\n\n    // draw the staff lines\n    var i,\n      x1 = this.staffLeft,\n      x2 = this.staffRight,\n      y;\n    canvasCtxt.lineWidth = ctxt.staffLineWeight;\n    canvasCtxt.strokeStyle = ctxt.staffLineColor;\n\n    for (i = this.score.staffLineCount * -2 + 1; i < 0; i += 2) {\n      y = ctxt.staffInterval * i;\n\n      canvasCtxt.beginPath();\n      canvasCtxt.moveTo(x1, y);\n      canvasCtxt.lineTo(x2, y);\n      canvasCtxt.stroke();\n    }\n\n    if (this.layoutInsertionCursor(ctxt)) {\n      this.insertionCursor.draw(ctxt);\n    }\n\n    // draw the ledger lines\n    for (i = 0; i < this.ledgerLines.length; i++) {\n      var ledgerLine = this.ledgerLines[i];\n      y = ctxt.calculateHeightFromStaffPosition(ledgerLine.staffPosition);\n\n      canvasCtxt.beginPath();\n      canvasCtxt.moveTo(ledgerLine.x1, y);\n      canvasCtxt.lineTo(ledgerLine.x2, y);\n      canvasCtxt.stroke();\n    }\n\n    // fixme: draw the braces\n\n    // draw the dropCap and the annotations\n    if (this.notationsStartIndex === 0) {\n      if (this.score.dropCap !== null) this.score.dropCap.draw(ctxt);\n\n      if (\n        this.score.annotation !== null &&\n        (!ctxt.mergeAnnotationWithTextLeft || this.score.dropCap)\n      )\n        // only draw it if there is a dropCap or there is no mergeAnnotationWithTextLeft\n        this.score.annotation.draw(ctxt);\n    }\n\n    // draw the notations\n    var notations = this.score.notations;\n    var lastIndex = this.notationsStartIndex + this.numNotationsOnLine;\n\n    for (i = this.notationsStartIndex; i < lastIndex; i++)\n      notations[i].draw(ctxt);\n\n    this.startingClef.draw(ctxt);\n\n    if (this.custos) this.custos.draw(ctxt);\n\n    canvasCtxt.translate(-this.bounds.x, -this.bounds.y);\n  }\n\n  getInnerNodes(\n    ctxt,\n    top = 0,\n    functionNames = { quickSvg: \"createNode\", elements: \"createSvgNode\" }\n  ) {\n    var inner = [];\n\n    // add the chant lines\n    var i,\n      x1 = this.staffLeft,\n      x2 = this.staffRight;\n    const staffSpaces = this.staffSpaces;\n    if (ctxt.editable) {\n      inner.push(\n        QuickSvg[functionNames.quickSvg](\"rect\", {\n          key: \"insertion\",\n          x: x1,\n          y: ctxt.staffInterval * this.score.staffLineCount * -2 + 1,\n          width: x2 - x1,\n          height: ctxt.staffInterval * 2 * staffSpaces,\n          fill: \"none\"\n        })\n      );\n    }\n\n    // create the staff lines\n    for (i = this.score.staffLineCount * -2 + 1; i < 0; i += 2) {\n      inner.push(\n        QuickSvg[functionNames.quickSvg](\"line\", {\n          key: i,\n          x1: x1,\n          y1: ctxt.staffInterval * i,\n          x2: x2,\n          y2: ctxt.staffInterval * i,\n          stroke: ctxt.staffLineColor,\n          \"stroke-width\": ctxt.staffLineWeight,\n          class: \"staffLine\"\n        })\n      );\n    }\n\n    inner = [\n      QuickSvg[functionNames.quickSvg](\"g\", { class: \"staffLines\" }, inner)\n    ];\n\n    if (this.layoutInsertionCursor(ctxt)) {\n      inner.push(this.insertionCursor[functionNames.elements](ctxt));\n    }\n\n    // create the ledger lines\n    for (i = 0; i < this.ledgerLines.length; i++) {\n      var ledgerLine = this.ledgerLines[i];\n      var y = ctxt.calculateHeightFromStaffPosition(ledgerLine.staffPosition);\n\n      inner.push(\n        QuickSvg[functionNames.quickSvg](\"line\", {\n          x1: ledgerLine.x1,\n          y1: y,\n          x2: ledgerLine.x2,\n          y2: y,\n          stroke: ctxt.staffLineColor,\n          \"stroke-width\": ctxt.staffLineWeight,\n          class: \"ledgerLine\"\n        })\n      );\n    }\n\n    // add any braces\n    for (i = 0; i < this.braces.length; i++)\n      inner.push(this.braces[i][functionNames.elements](ctxt));\n\n    // dropCap and the annotations\n    if (this.notationsStartIndex === 0) {\n      if (this.score.dropCap !== null)\n        inner.push(this.score.dropCap[functionNames.elements](ctxt));\n\n      if (\n        this.score.annotation !== null &&\n        (!ctxt.mergeAnnotationWithTextLeft || this.score.dropCap)\n      )\n        // only draw it if there is a dropCap or there is no mergeAnnotationWithTextLeft\n        inner = inner.concat(\n          this.score.annotation[functionNames.elements](ctxt)\n        );\n    }\n\n    inner.push(this.startingClef[functionNames.elements](ctxt));\n\n    var notations = this.score.notations;\n    var lastIndex = this.notationsStartIndex + this.numNotationsOnLine;\n\n    // add all of the notations\n    for (i = this.notationsStartIndex; i < lastIndex; i++)\n      inner.push(notations[i][functionNames.elements](ctxt));\n\n    if (this.custos) inner.push(this.custos[functionNames.elements](ctxt));\n    return inner;\n  }\n\n  createSvgNode(ctxt, top = 0) {\n    let inner = this.getInnerNodes(ctxt, top, {\n      quickSvg: \"createNode\",\n      elements: \"createSvgNode\"\n    });\n\n    return QuickSvg.createNode(\n      \"g\",\n      {\n        class: \"chantLine\",\n        transform:\n          \"translate(\" + this.bounds.x + \",\" + (this.bounds.y - top) + \")\",\n        \"element-index\": this.elementIndex,\n        source: this\n      },\n      inner\n    );\n  }\n\n  createSvgTree(ctxt, top = 0) {\n    let inner = this.getInnerNodes(ctxt, top, {\n      quickSvg: \"createSvgTree\",\n      elements: \"createSvgTree\"\n    });\n\n    return QuickSvg.createSvgTree(\n      \"g\",\n      {\n        class: \"chantLine\",\n        transform:\n          \"translate(\" + this.bounds.x + \",\" + (this.bounds.y - top) + \")\",\n        \"element-index\": this.elementIndex\n      },\n      ...inner\n    );\n  }\n\n  createSvgFragment(ctxt, top = 0) {\n    var inner = \"\";\n\n    // add the chant lines\n    var i,\n      x1 = this.staffLeft,\n      x2 = this.staffRight;\n\n    // create the staff lines\n    for (i = this.score.staffLineCount * -2 + 1; i < 0; i += 2) {\n      inner += QuickSvg.createFragment(\"line\", {\n        x1: x1,\n        y1: ctxt.staffInterval * i,\n        x2: x2,\n        y2: ctxt.staffInterval * i,\n        stroke: ctxt.staffLineColor,\n        \"stroke-width\": ctxt.staffLineWeight,\n        class: \"staffLine\"\n      });\n    }\n\n    inner = QuickSvg.createFragment(\"g\", { class: \"staffLines\" }, inner);\n\n    if (this.layoutInsertionCursor(ctxt)) {\n      inner += this.insertionCursor.createSvgFragment(ctxt);\n    }\n\n    // create the ledger lines\n    for (i = 0; i < this.ledgerLines.length; i++) {\n      var ledgerLine = this.ledgerLines[i];\n      var y = ctxt.calculateHeightFromStaffPosition(ledgerLine.staffPosition);\n\n      inner += QuickSvg.createFragment(\"line\", {\n        x1: ledgerLine.x1,\n        y1: y,\n        x2: ledgerLine.x2,\n        y2: y,\n        stroke: ctxt.staffLineColor,\n        \"stroke-width\": ctxt.staffLineWeight,\n        class: \"ledgerLine\"\n      });\n    }\n\n    // add any braces\n    for (i = 0; i < this.braces.length; i++)\n      inner += this.braces[i].createSvgFragment(ctxt);\n\n    // dropCap and the annotations\n    if (this.notationsStartIndex === 0) {\n      if (this.score.dropCap !== null)\n        inner += this.score.dropCap.createSvgFragment(ctxt);\n\n      if (\n        this.score.annotation !== null &&\n        (!ctxt.mergeAnnotationWithTextLeft || this.score.dropCap)\n      )\n        // only draw it if there is a dropCap or there is no mergeAnnotationWithTextLeft\n        inner += this.score.annotation.createSvgFragment(ctxt);\n    }\n\n    inner += this.startingClef.createSvgFragment(ctxt);\n\n    var notations = this.score.notations;\n    var lastIndex = this.notationsStartIndex + this.numNotationsOnLine;\n\n    // add all of the notations\n    for (i = this.notationsStartIndex; i < lastIndex; i++)\n      inner += notations[i].createSvgFragment(ctxt);\n\n    if (this.custos) inner += this.custos.createSvgFragment(ctxt);\n\n    return QuickSvg.createFragment(\n      \"g\",\n      {\n        class: \"chantLine\",\n        transform:\n          \"translate(\" + this.bounds.x + \",\" + (this.bounds.y - top) + \")\",\n        \"element-index\": this.elementIndex\n      },\n      inner\n    );\n  }\n\n  // code below based on code by: https://gist.github.com/alexhornbake\n  //\n  // optimized for braces that are only drawn horizontally.\n  // returns svg path string ready to insert into svg doc\n  generateCurlyBraceDrawable(ctxt, x1, x2, y, isAbove) {\n    var h;\n\n    if (isAbove) h = -ctxt.staffInterval / 2;\n    else h = ctxt.staffInterval / 2;\n\n    // and q factor, .5 is normal, higher q = more expressive bracket\n    var q = 0.6;\n\n    var len = x2 - x1;\n\n    //Calculate Control Points of path,\n    var qx1 = x1;\n    var qy1 = y + q * h;\n    var qx2 = x1 + 0.25 * len;\n    var qy2 = y + (1 - q) * h;\n    var tx1 = x1 + 0.5 * len;\n    var ty1 = y + h;\n    var qx3 = x2;\n    var qy3 = y + q * h;\n    var qx4 = x1 + 0.75 * len;\n    var qy4 = y + (1 - q) * h;\n    var d =\n      \"M \" +\n      x1 +\n      \" \" +\n      y +\n      \" Q \" +\n      qx1 +\n      \" \" +\n      qy1 +\n      \" \" +\n      qx2 +\n      \" \" +\n      qy2 +\n      \" T \" +\n      tx1 +\n      \" \" +\n      ty1 +\n      \" M \" +\n      x2 +\n      \" \" +\n      y +\n      \" Q \" +\n      qx3 +\n      \" \" +\n      qy3 +\n      \" \" +\n      qx4 +\n      \" \" +\n      qy4 +\n      \" T \" +\n      tx1 +\n      \" \" +\n      ty1;\n\n    return QuickSvg.createFragment(\"path\", {\n      d: d,\n      stroke: ctxt.neumeLineColor,\n      \"stroke-width\": ctxt.neumeLineWeight + \"px\",\n      fill: \"none\"\n    });\n  }\n\n  buildFromChantNotationIndex(ctxt, newElementStart, width) {\n    // todo: reset / clear the children we have in case they have data\n    var notations = this.score.notations,\n      beginningLyrics = null,\n      prev = null,\n      prevNeume = null,\n      prevLyrics = [];\n    var condensableSpaces = [];\n    this.notationsStartIndex = newElementStart;\n    this.numNotationsOnLine = 0;\n\n    this.staffLeft = 0;\n    this.paddingLeft = 0;\n\n    this.extraTextOnlyIndex = null;\n    this.extraTextOnlyLyricIndex = 0;\n\n    if (width > 0) this.staffRight = width;\n    else this.staffRight = Infinity; // no limit to staff size\n\n    // If this is the first chant line, then we have to make room for a\n    // drop cap and/or annotation, if present\n    if (this.notationsStartIndex === 0) {\n      var padding = 0;\n\n      if (this.score.dropCap)\n        padding =\n          this.score.dropCap.bounds.width + this.score.dropCap.padding * 2;\n\n      if (\n        this.score.annotation &&\n        (!ctxt.mergeAnnotationWithTextLeft || this.score.dropCap)\n      )\n        padding = Math.max(\n          padding,\n          this.score.annotation.bounds.width + this.score.annotation.padding * 2\n        );\n\n      this.staffLeft += padding;\n      if (this.score.dropCap)\n        this.paddingLeft = (padding - this.score.dropCap.bounds.width) / 2;\n    } else {\n      prev = notations[newElementStart - 1];\n      if (\n        prev.constructor === DoubleBar &&\n        prev.hasLyrics() &&\n        (prev.lyrics.length > 1 || !prev.lyrics[0].text.match(/^(i\\.?)+j\\.?/))\n      ) {\n        beginningLyrics = prev.lyrics.map((lyric) => {\n          var newLyric = new Lyric(\n            ctxt,\n            lyric.originalText,\n            lyric.lyricType,\n            lyric.notation,\n            lyric.notations,\n            lyric.sourceIndex\n          );\n          newLyric.elidesToNext = lyric.elidesToNext;\n          // Hide the original lyric by setting its bounds.y to an extremely high number.\n          // If the chant is re-laid out, this value will be recalculated so that it won't stay hidden.\n          lyric.bounds.y = Number.MAX_SAFE_INTEGER;\n          return newLyric;\n        });\n        var minX = beginningLyrics\n          .map(l => l.bounds.x)\n          .reduce((a, b) => a < b ? a : b);\n        beginningLyrics.forEach(l => {\n          l.bounds.x -= minX;\n        });\n      }\n    }\n\n    // set up the clef...\n    // if the first notation on the line is a starting clef, then we treat it a little differently...\n    // the clef becomes this line's starting clef and we skip over the clef in the notations array\n    if (notations.length && notations[newElementStart].isClef) {\n      ctxt.activeClef = notations[newElementStart];\n      newElementStart++;\n      this.notationsStartIndex++;\n    }\n\n    // make a copy for this line to use at the beginning\n    this.startingClef = ctxt.activeClef.clone();\n    this.startingClef.performLayout(ctxt);\n    this.startingClef.bounds.x = this.staffLeft;\n\n    var curr = this.startingClef;\n\n    if (beginningLyrics) {\n      LyricArray.setNotation(beginningLyrics, curr);\n    }\n\n    // estimate how much space we have available to us\n    var rightNotationBoundary =\n      this.staffRight - Glyphs.CustosLong.bounds.width * ctxt.glyphScaling; // possible custos on the line\n    var lastTranslationTextWithEndNeume = null;\n\n    // iterate through the notations, fittng what we can on this line\n    var i,\n      j,\n      lastNotationIndex = notations.length - 1;\n\n    if (curr.hasLyrics()) LyricArray.mergeIn(this.lastLyrics, curr.lyrics);\n\n    // if we already have a start brace on the context, we must be continuing it from the previous system.\n    if (ctxt.lastStartBrace && !ctxt.lastStartBrace.note) {\n      ctxt.lastStartBrace.note = this.startingClef;\n    }\n    var lastLyricsBeforeTextOnly;\n    var textOnlyStartIndex;\n\n    for (i = newElementStart; i <= lastNotationIndex; i++) {\n      prev = curr;\n      if (curr.constructor !== TextOnly) prevNeume = curr;\n\n      curr = notations[i];\n\n      var actualRightBoundary;\n      if (\n        i === lastNotationIndex ||\n        curr.constructor === Custos ||\n        (prev.constructor === Custos && curr.isDivider) ||\n        (curr.constructor === ChantLineBreak &&\n          prevNeume.constructor === Custos)\n      ) {\n        // on the last notation of the score, we don't need a custos or trailing space, so we use staffRight as the\n        // right boundary.\n        // Also, if the current notation is a divider and the previous was a custos, we don't need extra space\n        // because if the following notation won't fit, we can switch the order and use the custos as the end-of-the-line custos\n        // Ditto in the case of the current element being a chant line break and the previous neume a custos, because that custos will become our end-of-line custos\n        actualRightBoundary = this.staffRight;\n      } else if (i === lastNotationIndex - 1) {\n        // on the penultimate notation, make sure there is at least enough room for whichever takes up less space,\n        // between the final notation and a custos:\n        actualRightBoundary = Math.max(\n          rightNotationBoundary,\n          this.staffRight - notations[lastNotationIndex].bounds.width\n        );\n      } else {\n        // Otherwise, we use rightNotationBoundary, which leaves room for a custos...\n        actualRightBoundary = rightNotationBoundary;\n      }\n\n      // First check if we're already beyond the rightNotationBoundary (due to condensing that hasn't yet happened) and have a good element to end with\n      // but if we have 2 or fewer elements, or if the current element is a line break or a custos, we'll go ahead and try for them anyway.\n      var forceBreak =\n        !curr.isDivider &&\n        curr.constructor !== ChantLineBreak &&\n        curr.constructor !== Custos &&\n        !(\n          curr.constructor === TextOnly &&\n          curr.hasLyrics() &&\n          /^(?:[*†]|i+j\\.?)$/.test(curr.lyrics[0].text)\n        ) &&\n        lastNotationIndex - i > 1 &&\n        !prevNeume.keepWithNext &&\n        prevNeume.bounds.right() >= rightNotationBoundary;\n\n      // also force a break if we've run into extra TextOnly elements, but the current notation is not a TextOnly and has lyrics\n      forceBreak =\n        forceBreak ||\n        (this.extraTextOnlyIndex !== null &&\n          curr.constructor !== TextOnly &&\n          curr.constructor !== ChantLineBreak &&\n          curr.constructor !== Custos &&\n          curr.hasLyrics());\n\n      if (curr instanceof TextOnly && prev === prevNeume) {\n        lastLyricsBeforeTextOnly = this.lastLyrics.slice();\n        textOnlyStartIndex = i;\n      }\n      if (\n        curr instanceof TextOnly &&\n        notations[textOnlyStartIndex] &&\n        !notations[textOnlyStartIndex].hasLyrics()\n      ) {\n        // we want textOnlyStartIndex to be the first TextOnly that actually has lyrics,\n        // so if the current \"textOnlyStart\" element does not have lyrics, and we have another textOnly\n        // that does have lyrics, we will use it instead\n        textOnlyStartIndex = i;\n      }\n\n      if (curr.hasLyrics() && curr.lyrics[0].needsLayout) {\n        curr.lyrics[0].recalculateMetrics(ctxt);\n      }\n\n      // try to fit the curr element on this line.\n      // if it doesn't fit, we finish up here.\n      var fitsOnLine =\n        !forceBreak &&\n        this.positionNotationElement(\n          ctxt,\n          this.lastLyrics,\n          prevNeume,\n          curr,\n          actualRightBoundary,\n          this.extraTextOnlyIndex ? [] : condensableSpaces // no spaces are condensable once we are on extra text only lyrics\n        );\n      var candidateForExtraTextOnlyLine =\n        ctxt.useExtraTextOnly &&\n        curr.constructor === TextOnly &&\n        LyricArray.hasOnlyOneLyric(curr.lyrics) &&\n        (fitsOnLine === false || this.extraTextOnlyIndex !== null);\n      var extraTextOnlyLyricIndex;\n      if (candidateForExtraTextOnlyLine && this.extraTextOnlyIndex === null) {\n        // check to make sure there is enough text to put on the text only line:\n        extraTextOnlyLyricIndex = LyricArray.indexOfLyric(curr.lyrics);\n        if (textOnlyStartIndex === i) {\n          var currentLyric = notations[i].lyrics[extraTextOnlyLyricIndex].text;\n          if (currentLyric.length <= 1) {\n            var nextNotation = notations[i + 1];\n            candidateForExtraTextOnlyLine =\n              nextNotation &&\n              nextNotation.constructor === TextOnly &&\n              nextNotation.lyrics[extraTextOnlyLyricIndex] &&\n              nextNotation.lyrics[extraTextOnlyLyricIndex].text.length > 0;\n          }\n        }\n      }\n      if (candidateForExtraTextOnlyLine) {\n        // a special case for TextOnly elements that don't fit on the line: since they don't have neumes associated with them, we can place this\n        // and any additional TextOnly elements just below the current lyric lines, but we can only do this if the TextOnly elements have only one\n        // line of lyrics associated with them.\n        var firstOnLine;\n        extraTextOnlyLyricIndex = this.extraTextOnlyLyricIndex;\n        if (\n          this.extraTextOnlyIndex === null &&\n          notations[textOnlyStartIndex].lyrics.length\n        ) {\n          if (\n            textOnlyStartIndex === this.notationsStartIndex ||\n            !ctxt.startExtraTextOnlyFromFirst\n          ) {\n            textOnlyStartIndex = i;\n            let lastNotationWithLyrics = notations\n              .slice(this.notationsStartIndex, i)\n              .reverse()\n              .find(notation => notation.hasLyrics());\n            lastLyricsBeforeTextOnly =\n              (lastNotationWithLyrics &&\n                lastNotationWithLyrics.lyrics.slice()) ||\n              [];\n          }\n          // go back to the first in this string of consecutive TextOnly elements.\n          this.extraTextOnlyIndex = textOnlyStartIndex;\n          extraTextOnlyLyricIndex = this.extraTextOnlyLyricIndex = LyricArray.indexOfLyric(\n            curr.lyrics\n          );\n          this.lastLyricsBeforeTextOnly = lastLyricsBeforeTextOnly;\n          this.lastLyrics = [];\n          i = textOnlyStartIndex - 1;\n          this.numNotationsOnLine =\n            textOnlyStartIndex - this.notationsStartIndex;\n          continue;\n        }\n        delete curr.lyrics[extraTextOnlyLyricIndex].lineWidth;\n        if (!fitsOnLine || i === this.extraTextOnlyIndex) {\n          curr.bounds.x = curr.lyrics[extraTextOnlyLyricIndex].origin.x;\n          let lastLyricRight = ctxt.startExtraTextOnlyFromFirst\n            ? LyricArray.getRight(this.lastLyrics) +\n              (ctxt.minLyricWordSpacing || 0)\n            : 0;\n          curr.lyrics[extraTextOnlyLyricIndex].setMaxWidth(\n            ctxt,\n            this.staffRight,\n            this.staffRight - lastLyricRight\n          );\n          firstOnLine = curr;\n        }\n        if (firstOnLine)\n          firstOnLine.lyrics[extraTextOnlyLyricIndex].lineWidth = curr.lyrics[\n            extraTextOnlyLyricIndex\n          ].getRight();\n      } else if (fitsOnLine === false) {\n        const isTextOnlyBeforeDivider = (i) => {\n          const curr = notations[i];\n          if (curr.constructor !== TextOnly) return false;\n          const firstDivider = notations.slice(i + 1).findIndex(notation => notation.isDivider);\n          if (firstDivider < 0) return false;\n          return notations.slice(i + 1, i + 1 + firstDivider).every(notation => notation.constructor === TextOnly);\n        }\n        // first check for elements that cannot begin a system: dividers and custodes\n        while (\n          this.numNotationsOnLine > 1 &&\n          (curr.isDivider || curr.constructor === Custos || isTextOnlyBeforeDivider(i))\n        ) {\n          curr = notations[--i];\n          this.numNotationsOnLine--;\n          if (this.lastLyricsBeforeTextOnly && isTextOnlyBeforeDivider(i)) {\n            delete this.lastLyricsBeforeTextOnly;\n          }\n        }\n\n        if (lastTranslationTextWithEndNeume) {\n          // console.info(notations[i - 1], lastTranslationTextWithEndNeume);\n          // TODO?: need to go back to before the last translation text start:\n        }\n\n        // count syllables and notes\n        const notationsAfterBreak = notations.slice(i + 1);\n        let countSyllables = 0;\n        let countNotes = 0;\n        if (ctxt.minSyllablesLastLine && ctxt.minNotesLastLine) {\n          countSyllables = notationsAfterBreak.filter(notation => notation.hasLyrics()).length;\n          countNotes = notationsAfterBreak.flatMap(notation => notation.notes).filter(note => !!note).length;\n        }\n\n        // check if the prev elements want to be kept with this one\n        for (j = i - 1; j > this.notationsStartIndex; j--) {\n          var cne = notations[j];\n          curr = notations[j + 1];\n\n          // curr is the first notation on the next line\n          // cne is the last notation on this line\n          if (ctxt.minSyllablesLastLine && ctxt.minNotesLastLine) {\n            countSyllables += curr.hasLyrics() ? 1 : 0;\n            countNotes += (curr.notes || []).length;\n          }\n\n          if (cne.firstWithNoWidth) {\n            this.numNotationsOnLine--;\n            continue;\n          }\n\n          // don't let a line break occur in the middle of a translation\n          if (lastTranslationTextWithEndNeume) {\n            this.numNotationsOnLine--;\n            if (cne === lastTranslationTextWithEndNeume) {\n              lastTranslationTextWithEndNeume = null;\n            }\n            continue;\n          }\n\n          // force any notations starting with a quilisma or inclinatum (diamond) to be kept with the previous notation:\n          if (\n            curr &&\n            curr.notes &&\n            (curr.notes[0].shape === NoteShape.Quilisma ||\n              curr.notes[0].shape === NoteShape.Inclinatum)\n          ) {\n            this.numNotationsOnLine--;\n            continue;\n          }\n\n          if (countSyllables < ctxt.minSyllablesLastLine && countNotes < ctxt.minNotesLastLine) {\n            this.numNotationsOnLine--;\n            continue;\n          }\n\n          // if the line break is allowed (cne.allowLineBreakBeforeNext), keep this number of notations around so we can check during justification\n          // whether there would be too much space introduced between\n          if (cne.keepWithNext === true) {\n            if (cne.allowLineBreakBeforeNext && !this.maxNumNotationsOnLine)\n              this.maxNumNotationsOnLine = this.numNotationsOnLine;\n            this.numNotationsOnLine--;\n          } else break;\n        }\n        if (this.extraTextOnlyIndex && (this.notationsStartIndex + this.numNotationsOnLine) <= this.extraTextOnlyIndex) {\n          // we've cut back to before the extra text only index, so we have to remove it:\n          this.extraTextOnlyIndex = null;\n        }\n\n        // if for some reason not a single notation can fit on the line, we'd better put it on anyway, to avoid an infinite loop:\n        if (this.numNotationsOnLine === 0) this.numNotationsOnLine = 1;\n\n        // determine the neumes we can space apart, if we do end up justifying\n        curr = this.findNeumesToJustify(prevLyrics);\n\n        this.lastLyrics = prevLyrics;\n        if (this.maxNumNotationsOnLine) {\n          // Check whether we should squeeze some extra notations on the line to avoid too much space after justification:\n          // Check how much space we would have without the extra notations\n          var extraSpace = this.getWhitespaceOnRight(ctxt);\n          if (\n            extraSpace / this.toJustify.length >\n            ctxt.staffInterval * ctxt.maxExtraSpaceInStaffIntervals\n          ) {\n            LyricArray.mergeInArray(\n              prevLyrics,\n              notations.slice(\n                this.notationsStartIndex + this.numNotationsOnLine,\n                this.notationsStartIndex + this.maxNumNotationsOnLine\n              )\n            );\n            this.numNotationsOnLine = this.maxNumNotationsOnLine;\n            delete this.maxNumNotationsOnLine;\n          }\n        }\n\n        // if the next line begins with a fresh word, than there can be extra space between the last notation on this line and the custos:\n        let next = this.score.notations[\n          this.extraTextOnlyIndex === null\n            ? this.notationsStartIndex + this.numNotationsOnLine\n            : this.extraTextOnlyIndex\n        ];\n        if (\n          next &&\n          next.hasLyrics() &&\n          (next.lyrics[0].lyricType === LyricType.BeginningSyllable ||\n            next.lyrics[0].lyricType === LyricType.SingleSyllable)\n        ) {\n          this.toJustify.push(this.custos);\n        }\n\n        if (\n          j >= 1 &&\n          notations[j].isDivider &&\n          notations[j - 1].constructor === Custos\n        ) {\n          // reverse the order: put the divider first, and end the line with the custos.\n          prevLyrics = [];\n          for (i = j - 2; i >= this.notationsStartIndex; i--) {\n            if (notations[i].hasLyrics()) {\n              LyricArray.mergeIn(prevLyrics, notations[i].lyrics);\n              break;\n            }\n          }\n          // remove the custos and divider from the condensable spaces list, before adding the divider back, when repositioning it.\n          condensableSpaces.sum -= condensableSpaces.pop().condensable;\n          condensableSpaces.sum -= condensableSpaces.pop().condensable;\n          this.positionNotationElement(\n            ctxt,\n            prevLyrics,\n            notations[j - 2],\n            notations[j],\n            this.staffRight,\n            condensableSpaces\n          );\n          this.custos = notations[j - 1];\n          this.custos.bounds.x =\n            this.staffRight -\n            this.custos.bounds.width -\n            this.custos.leadingSpace;\n        }\n\n        // we are at the end of the line!\n        break;\n      }\n\n      if (curr.hasLyrics()) LyricArray.mergeIn(this.lastLyrics, curr.lyrics);\n\n      if (\n        lastTranslationTextWithEndNeume &&\n        curr === lastTranslationTextWithEndNeume.translationText[0].endNeume\n      ) {\n        lastTranslationTextWithEndNeume = null;\n      } else if (\n        curr.translationText &&\n        curr.translationText.length &&\n        curr.translationText[0].endNeume\n      ) {\n        lastTranslationTextWithEndNeume = curr;\n      }\n\n      curr.line = this;\n      this.numNotationsOnLine++;\n\n      if (curr.isClef) ctxt.activeClef = curr;\n\n      // line breaks are a special case indicating to stop processing here\n      if (curr.constructor === ChantLineBreak && width > 0) {\n        this.justify =\n          curr.justify ||\n          this.extraTextOnlyIndex !== null ||\n          this.getWhitespaceOnRight(ctxt) < 0;\n        if (this.justify) this.findNeumesToJustify(prevLyrics);\n        break;\n      }\n\n      if (curr.constructor === Custos) {\n        this.custos = curr;\n      } else if (curr.isNeume) {\n        this.custos = null;\n      }\n    }\n\n    var lastIndex = this.notationsStartIndex + this.numNotationsOnLine - 1;\n    var last = notations[lastIndex] || {};\n    while (\n      lastIndex > 0 &&\n      (last.constructor === ChantLineBreak ||\n        last.constructor === Custos ||\n        last.constructor === TextOnly)\n    ) {\n      last = notations[--lastIndex];\n    }\n    var isLastLine =\n      this.notationsStartIndex + this.numNotationsOnLine === notations.length;\n    if (\n      (this.justify && this.extraTextOnlyIndex !== null) ||\n      (width > 0 && isLastLine)\n    ) {\n      // this is the last chant line, or it has extra TextOnly elements at the end\n      if (!this.toJustify) this.findNeumesToJustify(prevLyrics);\n      this.justify =\n        (!isLastLine || last.isDivider) &&\n        this.getWhitespaceOnRight(ctxt) / (this.toJustify.length || 1) <=\n          ctxt.staffInterval * ctxt.maxExtraSpaceInStaffIntervals;\n    }\n\n    if (!this.custos) {\n      // create the automatic custos at the end of the line if there are neumes left in the notations\n      for (\n        i = this.notationsStartIndex + this.numNotationsOnLine;\n        i < notations.length;\n        i++\n      ) {\n        var notation = notations[i];\n\n        if (notation.isNeume) {\n          this.custos = new Custos(true);\n          ctxt.currNotationIndex = i - 1; // make sure the context knows where the custos is\n          this.custos.performLayout(ctxt);\n\n          if (this.justify) {\n            // Put the custos at the very end of the line\n            this.custos.bounds.x =\n              this.staffRight -\n              this.custos.bounds.width -\n              this.custos.leadingSpace;\n          } else {\n            this.custos.bounds.x =\n              prevNeume.bounds.right() + prevNeume.calculatedTrailingSpace;\n          }\n          // nothing more to see here...\n          break;\n        }\n      }\n    }\n\n    if (this.lastLyricsBeforeTextOnly) {\n      this.lastLyrics = this.lastLyricsBeforeTextOnly;\n      delete this.lastLyricsBeforeTextOnly;\n    }\n\n    // find the final lyric and mark it as connecting if needed.\n    if (width > 0) {\n      var whitespace = this.getWhitespaceOnRight();\n      var rightEdge = this.staffRight;\n      if (whitespace < 0) {\n        rightEdge -= whitespace;\n      }\n    }\n    i = 0;\n    while (this.lastLyrics && this.lastLyrics[i]) {\n      let lyrics = this.lastLyrics[i];\n      if (lyrics.allowsConnector()) {\n        lyrics.setNeedsConnector(true, 0);\n        if (width > 0 && ctxt.minLyricWordSpacing < ctxt.hyphenWidth) {\n          whitespace = rightEdge - lyrics.getRight();\n          // shrink the hyphen if we are already out of whitespace or if we would be if we used a regular hyphen:\n          if (whitespace < 0) {\n            var minHyphenWidth = Math.max(\n              ctxt.hyphenWidth + whitespace,\n              this.lastLyrics.length > 1\n                ? ctxt.intraNeumeSpacing\n                : ctxt.minLyricWordSpacing\n            );\n            // we might not need to shift the syllable, but we do want to shrink the hyphen...\n            lyrics.setConnectorWidth(minHyphenWidth);\n          }\n        }\n      }\n      ++i;\n    }\n\n    // if the provided width is less than zero, then set the width of the line\n    // based on the last notation\n    if (width <= 0) {\n      const lastNotation = notations[\n        this.notationsStartIndex + this.numNotationsOnLine - 1\n      ];\n      if (lastNotation) {\n        this.staffRight = lastNotation.bounds.right();\n      }\n      this.justify = false;\n    }\n\n    // Justify the line if we need to\n    this.justifyElements(ctxt, this.justify, condensableSpaces);\n\n    this.centerDividers();\n\n    if (width > 0 && isLastLine && this.score.extendLastSystemStaffLines !== true) {\n      // set the staff lines to only extend to the last element\n      const lastNotation = notations[\n        this.notationsStartIndex + this.numNotationsOnLine - 1\n      ];\n      if (lastNotation) {\n        this.staffRight = lastNotation.bounds.right();\n      }\n    }\n\n    this.finishLayout(ctxt);\n  }\n\n  centerDividers() {\n    var lastIndex =\n        this.extraTextOnlyIndex === null\n          ? this.notationsStartIndex + this.numNotationsOnLine\n          : this.extraTextOnlyIndex,\n      curr;\n    for (var i = this.notationsStartIndex; i < lastIndex; i++) {\n      curr = this.score.notations[i];\n\n      if (curr && curr.isDivider) {\n        var j = 1;\n        var prev = this.score.notations[i - 1];\n        var next =\n          i + 1 === lastIndex ? this.custos : this.score.notations[i + 1];\n        if (prev === next && next === this.custos) {\n          prev = this.score.notations[i - 2];\n          // force custos to right edge in this case, since it is a custos that exists\n          // regardless of line break, and would normally be before the double bar, but in this case it ends the line:\n          next.bounds.x = this.staffRight - next.bounds.width;\n        }\n        if (prev && next) {\n          //if (prev instanceof TextOnly || next instanceof TextOnly) continue;\n          var oldBoundsX = curr.bounds.x;\n          var barWidth = curr.bounds.width;\n          var leftPoint =\n              prev instanceof TextOnly && prev.hasLyrics()\n                ? prev.lyrics[0].getRight()\n                : prev.bounds.right(),\n            rightPoint =\n              next instanceof TextOnly && next.hasLyrics()\n                ? next.lyrics[0].getLeft()\n                : next.bounds.x;\n          if (prev instanceof TextOnly) {\n            let prev = this.score.notations.slice(this.notationsStartIndex, i).reverse().find(notation => !(notation instanceof TextOnly));\n            leftPoint = prev ? prev.bounds.right() : 0;\n          }\n          if (leftPoint) {\n            curr.bounds.x = (leftPoint + rightPoint - barWidth) / 2;\n          }\n          if (curr.hasLyrics()) {\n            var offset = oldBoundsX - curr.bounds.x;\n            for (j = curr.lyrics.length - 1; j >= 0; j--) {\n              curr.lyrics[j].bounds.x += offset;\n              curr.lyrics[j].needsLayout = true;\n            }\n          }\n        } else if (\n          i === lastIndex - 1 &&\n          this.justify &&\n          (curr.constructor === DoubleBar || curr.constructor === FullBar)\n        ) {\n          curr.bounds.x = this.staffRight - curr.bounds.width;\n        }\n      }\n    }\n  }\n\n  findNeumesToJustify(prevLyrics) {\n    this.toJustify = [];\n    var prev,\n      curr = null,\n      next = null,\n      nextOrCurr = null,\n      lastIndex = this.notationsStartIndex + this.numNotationsOnLine;\n    for (var i = this.notationsStartIndex; i < lastIndex; i++) {\n      prev = nextOrCurr;\n      curr = this.score.notations[i];\n      next = curr.isAccidental && this.score.notations[++i];\n      nextOrCurr = next || curr;\n      var hasLyrics = nextOrCurr.hasLyrics();\n\n      if (!curr || !prev) continue;\n\n      if (\n        this.extraTextOnlyIndex !== null &&\n        i >= this.extraTextOnlyIndex &&\n        curr.constructor === TextOnly\n      )\n        continue;\n\n      if (prev !== null) {\n        LyricArray.mergeIn(prevLyrics, prev.lyrics);\n        if (prev.keepWithNext === true) continue;\n      }\n\n      if (\n        !curr.isDivider &&\n        prevLyrics.length &&\n        prevLyrics[0].allowsConnector() &&\n        hasLyrics\n      )\n        continue;\n\n      if (nextOrCurr.constructor === ChantLineBreak) continue;\n\n      if (nextOrCurr === this.custos && !hasLyrics) continue;\n\n      if (i === 0 && this.score.useDropCap && hasLyrics) continue;\n\n      // otherwise, we can add space before this element\n      this.toJustify.push(curr);\n    }\n    if (nextOrCurr !== null) LyricArray.mergeIn(prevLyrics, nextOrCurr.lyrics);\n    return nextOrCurr;\n  }\n\n  getWhitespaceOnRight(ctxt) {\n    var notations = this.score.notations;\n    var lastIndex = this.notationsStartIndex + this.numNotationsOnLine;\n    var last = notations[lastIndex - 1];\n    if (this.extraTextOnlyIndex !== null && last.constructor === TextOnly) {\n      lastIndex = this.extraTextOnlyIndex;\n      last = notations[lastIndex - 1];\n    }\n    var lastRightNeume = last\n      ? last.bounds.right() + last.calculatedTrailingSpace\n      : 0;\n    var lastLyrics = this.lastLyricsBeforeTextOnly || this.lastLyrics;\n    var lastRightLyric = lastLyrics.length\n      ? LyricArray.getRight(lastLyrics)\n      : 0;\n\n    if (this.custos) {\n      lastRightNeume += this.custos.bounds.width + this.custos.leadingSpace;\n      if (this.custos.hasLyrics()) {\n        lastRightLyric = LyricArray.getRight(this.custos.lyrics);\n      }\n    } else if (ctxt && lastIndex < notations.length) {\n      lastRightNeume += Glyphs.CustosLong.bounds.width * ctxt.glyphScaling;\n    }\n    return this.staffRight - Math.max(lastRightLyric, lastRightNeume);\n  }\n\n  justifyElements(ctxt, doJustify, condensableSpaces) {\n    var i;\n    var toJustify = this.toJustify || [];\n    var notations = this.score.notations;\n    var lastIndex = this.notationsStartIndex + this.numNotationsOnLine;\n\n    // if it wasn't an ideal line break, and the last note is further from the custos than it would have been from its next punctum,\n    // move the custos over.\n    // We do this first so that if it opens up any new whitespace, that gets accounted for when we do the justification\n    var lastNotation =\n      notations[this.notationsStartIndex + this.numNotationsOnLine - 1];\n    var extraSpaceBeforeCustos =\n      this.staffRight < Infinity &&\n      this.custos &&\n      lastNotation.keepWithNext &&\n      this.custos.bounds.x -\n        lastNotation.bounds.right() -\n        lastNotation.calculatedTrailingSpace;\n    if (extraSpaceBeforeCustos > 0) {\n      // first, shrink the hyphen(s) if applicable, to move the neumes closer to the custos:\n      i = 0;\n      while (this.lastLyrics && this.lastLyrics[i]) {\n        let lyrics = this.lastLyrics[i];\n        if (lyrics.allowsConnector()) {\n          var connectorWidth = lyrics.getConnectorWidth();\n          if (ctxt.minLyricWordSpacing < connectorWidth) {\n            var minHyphenWidth = Math.max(\n              connectorWidth - extraSpaceBeforeCustos,\n              this.lastLyrics.length > 1\n                ? ctxt.intraNeumeSpacing\n                : ctxt.minLyricWordSpacing\n            );\n            // we might not need to shift the syllable, but we do want to shrink the hyphen...\n            lyrics.setConnectorWidth(minHyphenWidth);\n          }\n        }\n        ++i;\n      }\n      this.custos.bounds.x =\n        lastNotation.bounds.right() + lastNotation.calculatedTrailingSpace;\n    }\n\n    // first step of justification is to determine how much space we have to use up\n    var extraSpace = this.getWhitespaceOnRight();\n\n    if (\n      Math.abs(extraSpace) < 0.5 ||\n      (extraSpace > 0 && ((doJustify && toJustify.length === 0) || !doJustify))\n    )\n      return;\n\n    this.condensableSpaces = condensableSpaces;\n\n    var curr, prev;\n    var offset = 0;\n    var increment = extraSpace / toJustify.length;\n    var multiplier = 0;\n    var toJustifyIndex = 0;\n    if (extraSpace < 0) {\n      toJustify = condensableSpaces.filter(s => s.condensable > 0);\n      multiplier = extraSpace / condensableSpaces.sum;\n      increment = 0;\n    }\n    var nextToJustify = toJustify[toJustifyIndex++];\n    var incrementOffsetAtNextChance = false;\n    for (i = this.notationsStartIndex; i < lastIndex; i++) {\n      prev = curr;\n      curr = notations[i];\n\n      if (\n        this.extraTextOnlyIndex !== null &&\n        i >= this.extraTextOnlyIndex &&\n        curr.constructor === TextOnly\n      ) {\n        continue;\n      }\n\n      if (!multiplier && curr === this.custos) {\n        if (curr.hasLyrics()) {\n          curr.bounds.x = Math.min(\n            curr.bounds.x +\n              (this.staffRight - LyricArray.getRight(curr.lyrics)),\n            this.staffRight - curr.bounds.width\n          );\n          offset += increment;\n        } else {\n          curr.bounds.x = Math.min(\n            curr.bounds.x + offset,\n            this.staffRight - curr.bounds.width\n          );\n        }\n        continue;\n      }\n\n      if (multiplier) {\n        if (nextToJustify && nextToJustify.notation === curr) {\n          offset += multiplier * nextToJustify.condensable;\n          nextToJustify = toJustify[toJustifyIndex++];\n        }\n      } else if (nextToJustify === curr) {\n        if (prev.hasNoWidth) {\n          incrementOffsetAtNextChance = true;\n        } else {\n          offset += increment;\n        }\n        nextToJustify = toJustify[toJustifyIndex++];\n      } else if (incrementOffsetAtNextChance && !prev.hasNoWidth) {\n        incrementOffsetAtNextChance = false;\n        offset += increment;\n      }\n\n      curr.bounds.x += offset;\n    }\n\n    if (extraSpaceBeforeCustos > 0) {\n      this.custos.bounds.x =\n        lastNotation.bounds.right() + lastNotation.calculatedTrailingSpace;\n    }\n  }\n\n  handleEndBrace(ctxt, note, i) {\n    var startBrace = ctxt.lastStartBrace;\n    if (!startBrace) return;\n    // calculate the y value of the brace by iterating over all notations\n    // under/over the brace.\n    var y;\n    var k = startBrace.notationIndex;\n    var notations = this.score.notations;\n    var dy = ctxt.intraNeumeSpacing / 2; // some safe space between brace and notes.\n    var startNote = startBrace.note;\n\n    if (startBrace.isAbove) {\n      y = Math.min(\n        ctxt.calculateHeightFromStaffPosition(this.score.staffLineCount * 2),\n        ...[startNote, note]\n          .concat(notations.slice(k, i + 1))\n          .map(n => n.bounds.y - dy)\n      );\n    } else {\n      y = Math.max(\n        ctxt.calculateHeightFromStaffPosition(0),\n        ...[startNote, note]\n          .concat(notations.slice(k, i + 1))\n          .map(n => n.bounds.bottom() + dy)\n      );\n    }\n\n    var addAcuteAccent = false;\n\n    if (startBrace.shape === BraceShape.RoundBrace) {\n      this.braces.push(\n        new RoundBraceVisualizer(\n          ctxt,\n          startBrace.getAttachmentX(startNote),\n          note.braceEnd.getAttachmentX(note),\n          y,\n          startBrace.isAbove\n        )\n      );\n    } else {\n      if (startBrace.shape === BraceShape.AccentedCurlyBrace)\n        addAcuteAccent = true;\n\n      this.braces.push(\n        new CurlyBraceVisualizer(\n          ctxt,\n          startBrace.getAttachmentX(startNote),\n          note.braceEnd.getAttachmentX(note),\n          y,\n          startBrace.isAbove,\n          addAcuteAccent\n        )\n      );\n    }\n\n    delete ctxt.lastStartBrace;\n  }\n\n  finishLayout(ctxt) {\n    this.ledgerLines = []; // clear any existing ledger lines\n\n    var notations = this.score.notations;\n    var lastIndex = this.notationsStartIndex + this.numNotationsOnLine;\n\n    // an element needs to have a staffPosition property, as well as the standard\n    // bounds property. so it could be a note, or it could be a custos\n    // offsetX can be used to add to the position info for the element,\n    // useful in the case of notes.\n    var processElementForLedgerLine = (\n      element,\n      endElem = element,\n      staffPosition = element.staffPosition,\n      offsetX = element.neume ? element.neume.bounds.x : 0\n    ) => {\n      // do we need a ledger line for this note?\n      const ledgerLinePositionAbove = ctxt.staffLineCount * 2 + 1;\n      if (staffPosition >= ledgerLinePositionAbove || staffPosition <= -1) {\n        var x1 = offsetX + element.bounds.x - ctxt.intraNeumeSpacing;\n        var x2 =\n          offsetX +\n          endElem.bounds.x +\n          endElem.bounds.width +\n          ctxt.intraNeumeSpacing;\n\n        // round the staffPosition to the nearest line\n        if (staffPosition > 0)\n          staffPosition = staffPosition - ((staffPosition - 1) % 2);\n        else staffPosition = staffPosition - ((staffPosition + 1) % 2);\n\n        // if we have a ledger line close by, then average out the distance between the two\n        var minLedgerSeparation = ctxt.staffInterval * ctxt.minLedgerSeparation;\n\n        if (\n          this.ledgerLines.length > 0 &&\n          this.ledgerLines[this.ledgerLines.length - 1].x2 +\n            minLedgerSeparation >=\n            x1\n        ) {\n          // average out the distance\n          var half =\n            (x1 - this.ledgerLines[this.ledgerLines.length - 1].x2) / 2;\n          this.ledgerLines[this.ledgerLines.length - 1].x2 += half;\n          x1 -= half;\n        }\n\n        // never let a ledger line extend past the staff width\n        if (x2 > this.staffRight) x2 = this.staffRight;\n\n        // finally, add the ledger line\n        this.ledgerLines.push({\n          x1,\n          x2,\n          staffPosition\n        });\n      }\n    };\n\n    var episemata = []; // keep track of episemata in case we can connect some\n    var startBrace = null;\n    var minY = Number.MAX_VALUE,\n      maxY = Number.MIN_VALUE; // for braces\n\n    var positionNonLyricText = (text, neume, rightX) => {\n      text.setMaxWidth(ctxt, this.staffRight);\n      //text.bounds.x = neume.hasLyrics()? Math.min(...neume.lyrics.map(l => l.bounds.x)) : 0;\n      text.bounds.x = 0;\n      if (rightX)\n        text.bounds.x = (text.bounds.x + rightX - text.bounds.width) / 2;\n      var beyondStaffRight =\n        neume.bounds.x + text.bounds.right() - this.staffRight;\n      if (beyondStaffRight > 0) {\n        text.bounds.x -= beyondStaffRight;\n      }\n      if (neume.bounds.x + text.bounds.x < 0) {\n        text.bounds.x = -neume.bounds.x;\n      }\n    };\n\n    // make a final pass over all of the notes to add any necessary\n    // ledger lines and to smooth out episemata\n    for (var i = this.notationsStartIndex; i < lastIndex; i++) {\n      var neume = notations[i];\n\n      minY = Math.min(minY, neume.bounds.y);\n      maxY = Math.max(maxY, neume.bounds.bottom());\n\n      if (neume.constructor === Custos) {\n        processElementForLedgerLine(neume);\n        continue;\n      }\n\n      // if the AboveLinesText would extend beyond the right edge of the staff, right align it instead\n      if (neume.alText) {\n        for (var j = 0; j < neume.alText.length; j++) {\n          positionNonLyricText(neume.alText[j], neume);\n        }\n      }\n\n      // set up horizontal position of translations\n      if (neume.translationText) {\n        for (j = 0; j < neume.translationText.length; j++) {\n          var text = neume.translationText[j];\n          if (text.endNeume) {\n            var rightX = text.endNeume.hasLyrics()\n              ? text.endNeume.bounds.x +\n                Math.max(...text.endNeume.lyrics.map(l => l.bounds.right()))\n              : text.endNeume.bounds.right();\n            rightX -= neume.bounds.x;\n            positionNonLyricText(text, neume, rightX);\n          } else {\n            positionNonLyricText(text, neume);\n          }\n        }\n      }\n\n      // if it's not a neume then just skip here\n      if (!neume.isNeume) continue;\n\n      for (j = 0; j < neume.ledgerLines.length; j++) {\n        var ll = neume.ledgerLines[j];\n        processElementForLedgerLine(ll.element, ll.endElem, ll.staffPosition);\n      }\n\n      for (j = 0; j < neume.notes.length; j++) {\n        var k,\n          note = neume.notes[j];\n\n        // blend episemata as we're able\n        if (note.episemata.length === 0) episemata = [];\n        for (k = 0; k < note.episemata.length; k++) {\n          var episema = note.episemata[k];\n\n          var spaceBetweenEpisemata = 0;\n\n          // calculate the distance between the last episemata and this one...\n          // lots of code for a simple: currEpisemata.left - prevEpisemata.right\n          if (episemata.length > 0)\n            spaceBetweenEpisemata =\n              neume.bounds.x +\n              episema.bounds.x -\n              (episemata[episemata.length - 1].note.neume.bounds.x +\n                episemata[episemata.length - 1].bounds.right());\n\n          // we try to blend the episema if we're able.\n          if (\n            episemata.length === 0 ||\n            episemata[episemata.length - 1].positionHint !==\n              episema.positionHint ||\n            episemata[episemata.length - 1].terminating === true ||\n            episemata[episemata.length - 1].alignment ===\n              HorizontalEpisemaAlignment.Left ||\n            episemata[episemata.length - 1].alignment ===\n              HorizontalEpisemaAlignment.Center ||\n            episema.alignment === HorizontalEpisemaAlignment.Right ||\n            episema.alignment === HorizontalEpisemaAlignment.Center ||\n            (spaceBetweenEpisemata > ctxt.intraNeumeSpacing * 2 &&\n              note.glyphVisualizer.glyphCode !== GlyphCode.None)\n          ) {\n            // start a new set of episemata to potentially blend\n            episemata = [episema];\n          } else {\n            // blend all previous with this one\n            var newY;\n\n            if (episema.positionHint === MarkingPositionHint.Below)\n              newY = Math.max(\n                episema.bounds.y,\n                episemata[episemata.length - 1].bounds.y\n              );\n            else\n              newY = Math.min(\n                episema.bounds.y,\n                episemata[episemata.length - 1].bounds.y\n              );\n\n            if (episema.bounds.y !== newY) episema.bounds.y = newY;\n            else {\n              for (var l = 0; l < episemata.length; l++)\n                episemata[l].bounds.y = newY;\n            }\n\n            // extend the last episema to meet the new one\n            var newWidth =\n              neume.bounds.x +\n              episema.bounds.x -\n              (episemata[episemata.length - 1].note.neume.bounds.x +\n                episemata[episemata.length - 1].bounds.x);\n            if (newWidth < 0) {\n              newWidth *= -1;\n              episemata[episemata.length - 1].bounds.x -= newWidth;\n            }\n            episemata[episemata.length - 1].bounds.width = newWidth;\n\n            episemata.push(episema);\n          }\n        }\n\n        if (note.braceEnd) this.handleEndBrace(ctxt, note, i);\n\n        if (note.braceStart) {\n          ctxt.lastStartBrace = startBrace = note.braceStart;\n          startBrace.notationIndex = i;\n        }\n      }\n    }\n\n    // if we still have an active brace, that means it spands two chant lines!\n    if (startBrace !== null) {\n      if (this.custos) {\n        // if the next end brace is on the first note following the line break, simply use it with the custos\n        // Do the same if there is only an accidental between\n        // otherwise, make a new end brace to work for this one, and a new start brace for the next line.\n        var nextNotation = notations[lastIndex];\n        var nextNote = nextNotation.notes && nextNotation.notes[0];\n        var nextNotationButOne = notations[lastIndex + 1];\n        var nextNoteButOne =\n          nextNotationButOne &&\n          nextNotationButOne.notes &&\n          nextNotationButOne.notes[0];\n        var braceEnd =\n          (nextNote && nextNote.braceEnd) ||\n          (nextNotation.isAccidental &&\n            nextNoteButOne &&\n            nextNoteButOne.braceEnd);\n        if (braceEnd) {\n          this.custos.braceEnd = braceEnd;\n          this.handleEndBrace(ctxt, this.custos, i);\n        } else {\n          this.braceStart = startBrace;\n          this.custos.braceEnd = new BracePoint(\n            this.custos,\n            startBrace.isAbove,\n            startBrace.shape,\n            BraceAttachment.Right\n          );\n          this.handleEndBrace(ctxt, this.custos, i - 1);\n          ctxt.lastStartBrace = new BracePoint(\n            null,\n            startBrace.isAbove,\n            startBrace.shape,\n            BraceAttachment.Left\n          );\n          ctxt.lastStartBrace.notationIndex = i;\n        }\n      }\n    }\n\n    // don't forget to also include the final custos, which may need a ledger line too\n    if (this.custos) processElementForLedgerLine(this.custos);\n  }\n\n  // this is where the real core of positioning neumes takes place\n  // returns true if positioning was able to fit the neume before rightNotationBoundary.\n  // returns false if cannot fit before given right margin.\n  // fixme: if this returns false, shouldn't we set the connectors on prev to be activated?!\n  positionNotationElement(\n    ctxt,\n    prevLyrics,\n    prev,\n    curr,\n    rightNotationBoundary,\n    condensableSpaces = []\n  ) {\n    if (!condensableSpaces.hasOwnProperty(\"sum\")) condensableSpaces.sum = 0;\n    var i,\n      space = { notation: curr },\n      fixedX = false;\n\n    // To begin we just place the current notation right after the previous,\n    // irrespective of lyrics.\n    // But if the previous neume was part of a polyphonic \"no width\" group and the current is not, or is of a separate group,\n    // we force it to have the same x as the previous group.\n    if (\n      (!curr.hasNoWidth || curr.firstWithNoWidth === curr) &&\n      prev.firstWithNoWidth\n    ) {\n      curr.bounds.x = prev.firstWithNoWidth.bounds.x;\n      fixedX = true;\n    } else {\n      curr.bounds.x = prev.bounds.right();\n    }\n\n    if (\n      (curr.constructor === TextOnly && this.extraTextOnlyIndex === null) ||\n      (!curr.hasLyrics() && prev.calculatedTrailingSpace < 0)\n    ) {\n      // We transfer over the trailing space from the previous neume if the current neume is text only,\n      // so that the text only neume has a better chance at not needing a connector.\n      curr.calculatedTrailingSpace = prev.calculatedTrailingSpace;\n      if (curr.hasLyrics())\n        curr.calculatedTrailingSpace -= curr.lyrics[0].bounds.width;\n      if (curr.constructor === TextOnly && curr.lyrics.length === 1) {\n        curr.lyrics[0].setMaxWidth(\n          ctxt,\n          this.staffRight,\n          this.staffRight -\n            LyricArray.getRight(prevLyrics) -\n            ctxt.minLyricWordSpacing\n        );\n      }\n    } else if (!fixedX) {\n      curr.bounds.x += prev.calculatedTrailingSpace;\n    }\n\n    if (\n      curr.hasLyrics() &&\n      !prev.isDivider &&\n      !prev.isAccidental &&\n      this.numNotationsOnLine > 0 &&\n      (curr.lyrics[0].lyricType === LyricType.SingleSyllable ||\n        curr.lyrics[0].lyricType === LyricType.BeginningSyllable)\n    ) {\n      curr.bounds.x += ctxt.intraNeumeSpacing * ctxt.interVerbalMultiplier;\n    }\n    if (curr.hasNoWidth || fixedX) {\n      space.total = space.condensable = 0;\n    } else if (\n      this.extraTextOnlyIndex !== null &&\n      curr.constructor === TextOnly\n    ) {\n      curr.bounds.x = 0;\n      space.total = space.condensable = 0;\n    } else {\n      space.total = curr.bounds.x - prev.bounds.right();\n      space.condensable = space.total * ctxt.condensingTolerance;\n    }\n\n    // if the previous notation has no lyrics, then we simply make sure the\n    // current notation with lyrics is in the bounds of the line\n    if (prevLyrics.length === 0) {\n      var maxRight = curr.bounds.right() + curr.calculatedTrailingSpace;\n\n      // if the lyric left is negative, then offset the neume appropriately\n      for (i = 0; i < curr.lyrics.length; i++) {\n        let currLyric = curr.lyrics[i];\n        // we hope for the best!\n        // but always use a connector if the lyric has original text that was all used up for the drop cap.\n        let needsConnector =\n          currLyric.allowsConnector() &&\n          currLyric.dropCap &&\n          currLyric.originalText &&\n          !currLyric.text;\n        currLyric.setNeedsConnector(needsConnector);\n        let minLeft = this.staffLeft - this.paddingLeft;\n\n        if (currLyric.getLeft() < minLeft)\n          curr.bounds.x -= currLyric.getLeft() - minLeft;\n\n        space.condensable = Math.min(\n          space.condensable,\n          currLyric.getLeft() - minLeft\n        );\n        maxRight = Math.max(maxRight, currLyric.getRight());\n      }\n\n      if (\n        maxRight >\n        rightNotationBoundary + condensableSpaces.sum + space.condensable\n      )\n        return false;\n      condensableSpaces.push(space);\n      condensableSpaces.sum += space.condensable;\n      return true;\n    } else {\n      if (curr.firstOfSyllable && prevLyrics.length && !curr.hasLyrics()) {\n        curr.bounds.x = Math.max(curr.bounds.x, prevLyrics[0].getRight());\n        space.total = curr.bounds.x - prev.bounds.right();\n        space.condensable = space.total * ctxt.condensingTolerance;\n      }\n    }\n\n    // if the curr notation has no lyrics, then simply check whether there is enough room\n    if (curr.hasLyrics() === false) {\n      if (\n        curr.bounds.right() + curr.calculatedTrailingSpace >\n        rightNotationBoundary + condensableSpaces.sum + space.condensable\n      )\n        return false;\n      condensableSpaces.push(space);\n      condensableSpaces.sum += space.condensable;\n      return true;\n    }\n\n    // if we have multiple lyrics on the current or the previous notation,\n    // we will have to run several passes over each set of lyrics:\n\n    // on the first pass, we will check the absolute left-most placement of the new syllables\n    // we will make additional passes until everything is stable\n    do {\n      var hasShifted = false;\n      var atLeastOneWithoutConnector = false;\n      for (i = 0; i < curr.lyrics.length; i++) {\n        if (!curr.lyrics[i].originalText) continue;\n        var prevLyricRight = 0;\n        let condensableSpacesSincePrevLyric = [];\n        let condensableSpaceSincePrevLyric = null;\n        if (i < prevLyrics.length && prevLyrics[i]) {\n          prevLyricRight = prevLyrics[i].getRight();\n          let notationI = condensableSpaces\n            .map(s => s.notation)\n            .lastIndexOf(prevLyrics[i].notation);\n          if (notationI >= 0) {\n            condensableSpacesSincePrevLyric = condensableSpaces.slice(\n              notationI + 1\n            );\n            condensableSpacesSincePrevLyric.sum = condensableSpacesSincePrevLyric\n              .map(s => s.condensable)\n              .reduce((a, b) => a + b, 0);\n          } else {\n            condensableSpacesSincePrevLyric.sum = 0;\n          }\n        }\n\n        curr.lyrics[i].setNeedsConnector(false); // we hope for the best!\n        var currLyricLeft = curr.lyrics[i].getLeft();\n        if (!prevLyrics[i] || prevLyrics[i].allowsConnector() === false) {\n          // No connector needed, but include space between words if necessary!\n          let extraSpace = currLyricLeft - prevLyricRight - ctxt.minLyricWordSpacing;\n          if (extraSpace < 0) {\n            // push the current element over a bit.\n            let shift =\n              prevLyricRight + ctxt.minLyricWordSpacing - currLyricLeft;\n            curr.bounds.x += shift;\n            condensableSpaceSincePrevLyric = 0;\n            hasShifted = shift > 0.5;\n          } else {\n            condensableSpaceSincePrevLyric = extraSpace;\n          }\n        } else {\n          // we may need a connector yet...\n          if (\n            prevLyricRight + 0.1 >\n            currLyricLeft -\n              condensableSpacesSincePrevLyric.sum -\n              space.condensable\n          ) {\n            // in this case, the lyric elements actually overlap.\n            // so nope, no connector needed. instead, we just place the lyrics together\n            // fixme: for better text layout, we could actually use the kerning values\n            // between the prev and curr lyric elements!\n            let shift = prevLyricRight - currLyricLeft;\n            if (shift < -0.1) {\n              // in this case, the spacing needs to be condensed in the neumes since the last lyric...\n              let multiplier =\n                shift /\n                (condensableSpacesSincePrevLyric.sum + space.condensable);\n              let offset = 0;\n              condensableSpacesSincePrevLyric.forEach(s => {\n                offset += multiplier * s.condensable;\n                s.notation.bounds.x += offset;\n              });\n            }\n            curr.bounds.x += shift;\n            condensableSpaceSincePrevLyric = 0;\n            atLeastOneWithoutConnector = true;\n            hasShifted = shift > 0.5;\n          } else {\n            // bummer, looks like we couldn't merge the syllables together. Better add a connector...\n            if (ctxt.minLyricWordSpacing < ctxt.hyphenWidth) {\n              var spaceBetweenSyls = currLyricLeft - prevLyricRight;\n              if (spaceBetweenSyls < ctxt.hyphenWidth) {\n                var minHyphenWidth =\n                  prevLyrics.length > 1\n                    ? ctxt.intraNeumeSpacing\n                    : ctxt.minLyricWordSpacing;\n                // we might not need to shift the syllable, but we do want to shrink the hyphen...\n                prevLyrics[i].setConnectorWidth(\n                  Math.max(minHyphenWidth, spaceBetweenSyls)\n                );\n              }\n            }\n            prevLyrics[i].setNeedsConnector(true);\n            prevLyricRight = prevLyrics[i].getRight();\n\n            if (prevLyricRight + 0.1 > currLyricLeft) {\n              let shift = prevLyricRight - currLyricLeft;\n              curr.bounds.x += shift;\n              condensableSpaceSincePrevLyric = 0;\n              hasShifted = shift > 0.5;\n            } else {\n              condensableSpaceSincePrevLyric = currLyricLeft - prevLyricRight;\n            }\n          }\n        }\n\n        if (condensableSpaceSincePrevLyric !== null) {\n          if (\n            condensableSpaceSincePrevLyric <\n            condensableSpacesSincePrevLyric.sum + space.condensable\n          ) {\n            // reduce condensable space so that lyrics retain at least the width of a space character between words:\n            let multiplier = condensableSpaceSincePrevLyric / (condensableSpacesSincePrevLyric.sum + space.condensable);\n            space.condensable *= multiplier;\n            if (condensableSpacesSincePrevLyric.sum) {\n              condensableSpacesSincePrevLyric.forEach(space => {\n                space.condensable *= multiplier;\n              });\n              condensableSpaces.sum = condensableSpaces\n                .map(s => s.condensable)\n                .reduce((a, b) => a + b, 0);\n            }\n          }\n        }\n      }\n    } while (\n      curr.lyrics.length > 1 &&\n      hasShifted &&\n      atLeastOneWithoutConnector\n    );\n\n    for (i = Math.min(curr.lyrics.length, prevLyrics.length) - 1; i >= 0; i--) {\n      let pLyrics = prevLyrics[i];\n      if (pLyrics.needsConnector && pLyrics.connectorWidth) {\n        currLyricLeft = curr.lyrics[i].getLeft();\n        prevLyricRight = pLyrics.getRight() - pLyrics.connectorWidth;\n        spaceBetweenSyls = currLyricLeft - prevLyricRight;\n        if (spaceBetweenSyls >= ctxt.hyphenWidth) spaceBetweenSyls = 0;\n        pLyrics.setConnectorWidth(spaceBetweenSyls);\n      }\n    }\n\n    if (\n      curr.bounds.right() + curr.calculatedTrailingSpace <\n        rightNotationBoundary + condensableSpaces.sum + space.condensable &&\n      LyricArray.getRight(curr.lyrics, true) <=\n        this.staffRight + condensableSpaces.sum + space.condensable\n    ) {\n      if (prev.isAccidental) {\n        // move the previous accidental up next to the current note:\n        let shift =\n          curr.bounds.x -\n          prev.bounds.width -\n          prev.calculatedTrailingSpace -\n          prev.bounds.x;\n        prev.bounds.x += shift;\n        if (Math.abs(shift) > 0.1) {\n          let lastCondensable = condensableSpaces[condensableSpaces.length - 1];\n          condensableSpaces.sum -= lastCondensable.condensable;\n          lastCondensable.condensable = 0;\n        }\n      }\n      condensableSpaces.push(space);\n      condensableSpaces.sum += space.condensable;\n      return true;\n    }\n\n    // if we made it this far, then the element won't fit on this line.\n    return false;\n  }\n\n  /**\n   * Find the notation closest to x without going past it\n   * @param {number} x\n   */\n  bisectNotationAtX(x, useMidpoint = true) {\n    let minIndex = -1,\n      maxIndex = Math.min(this.numNotationsOnLine, Infinity),\n      curIndex = minIndex + ((maxIndex - minIndex) >> 1),\n      notations = this.score.notations.slice(\n        this.notationsStartIndex,\n        this.notationsStartIndex + this.numNotationsOnLine\n      );\n\n    while (minIndex < curIndex) {\n      let notation = notations[curIndex];\n      let notationX = notation.bounds.x;\n      if (notationX > x) {\n        maxIndex = curIndex;\n      } else {\n        minIndex = curIndex;\n      }\n      curIndex = minIndex + ((maxIndex - minIndex) >> 1);\n    }\n    let notation = notations[curIndex];\n    if (\n      useMidpoint &&\n      notation &&\n      notation.bounds.width === 0 &&\n      curIndex + 1 < notations.length\n    ) {\n      let nextNotation = notations[curIndex + 1],\n        closenessToLeft = x - notation.bounds.x,\n        closenessToRight = nextNotation.bounds.x - x;\n      if (nextNotation.bounds.width === 0 && closenessToRight < closenessToLeft)\n        ++curIndex;\n    }\n    return notations[curIndex];\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Exsurge.Chant.ChantLine.js","//\n// Author(s):\n// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>\n//\n// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n//\n\nimport { NoteShape } from \"./Exsurge.Chant.js\";\nimport {\n  ChantLayoutElement,\n  GlyphCode,\n  GlyphVisualizer,\n  MarkingPositionHint,\n  QuickSvg\n} from \"./Exsurge.Drawing.js\";\n\nexport class Accent extends GlyphVisualizer {\n  constructor(ctxt, note, glyphCode = GlyphCode.AcuteAccent) {\n    super(ctxt, glyphCode);\n    this.note = note;\n    this.positionHint = MarkingPositionHint.Above;\n  }\n\n  performLayout(ctxt) {\n    this.bounds.x = this.note.bounds.x + this.bounds.width / 2; // center on the note itself\n\n    // this puts the acute accent either over the staff lines, or over the note if the\n    // note is above the staff lines\n    this.setStaffPosition(ctxt, Math.max(this.note.staffPosition + 1, 2 * ctxt.staffLineCount));\n  }\n}\n\n// for positioning markings on notes\nexport var HorizontalEpisemaAlignment = {\n  Default: 0,\n  Left: 1,\n  Center: 2,\n  Right: 3\n};\n\n/*\n * HorizontalEpisema\n *\n * A horizontal episema marking is it's own visualizer (that is, it implements createSvgFragment)\n */\nexport class HorizontalEpisema extends ChantLayoutElement {\n  constructor(note) {\n    super();\n\n    this.note = note;\n\n    this.positionHint = MarkingPositionHint.Default;\n    this.terminating = false; // indicates if this episema should terminate itself or not\n    this.alignment = HorizontalEpisemaAlignment.Default;\n  }\n\n  performLayout(ctxt) {\n    // following logic helps to keep the episemata away from staff lines if they get too close\n\n    var y = 0,\n      step;\n    var minDistanceAway = ctxt.staffInterval * 0.25; // min distance from neume\n    var glyphCode = this.note.glyphVisualizer.glyphCode;\n    var ledgerLine = this.note.neume.ledgerLines[0] || {};\n    var punctumInclinatumShorten = false;\n\n    if (glyphCode === GlyphCode.PunctumInclinatum) {\n      let notes = this.note.neume.notes,\n        index = notes.indexOf(this.note),\n        prevNote = notes[index - 1];\n      if (\n        prevNote &&\n        prevNote.glyphVisualizer.glyphCode === GlyphCode.PunctumInclinatum &&\n        prevNote.staffPosition - this.note.staffPosition === 1\n      ) {\n        punctumInclinatumShorten = true;\n      }\n    }\n\n    const staffLineCountParity = (ctxt.staffLineCount % 2) || 0;\n    const staffLineCountNonParity = (staffLineCountParity + 1) % 2;\n    if (this.positionHint === MarkingPositionHint.Below) {\n      y = this.note.bounds.bottom() + minDistanceAway; // the highest the line could be at\n      // convert y to be based around center Y between top and bottom staff lines so that it is symmetric:\n      y += ctxt.staffLineCount * ctxt.staffInterval;\n\n      if (glyphCode === GlyphCode.None)\n        // correction for episema under the second note of a porrectus\n        y += ctxt.staffInterval / 2;\n      step = Math.ceil(y / ctxt.staffInterval);\n      // if there's enough space, center the episema between the punctum and the next staff line\n      if (Math.abs(step % 2) === staffLineCountParity) {\n        step = (step + 3 / 4 + (y - minDistanceAway) / ctxt.staffInterval) / 2;\n      } else {\n        // otherwise, find nearest acceptable third between staff lines (or staff line)\n        step = (Math.ceil((1.5 * y) / ctxt.staffInterval - 0.5) * 2 + staffLineCountNonParity) / 3;\n\n        // if it's an odd step, that means we're on a staff line,\n        // so we shift to between the staff line\n        if (Math.abs(step) % 2 === staffLineCountNonParity) {\n          if (Math.abs(step) < ctxt.staffLineCount || ctxt.convertStaffPositionToSymmetric(ledgerLine.staffPosition) === -step) {\n            step += 2 / 3;\n          } else {\n            // no ledger line, but we don't want the episema to be at exactly the same height the ledger line would occupy:\n            step += 1 / 3;\n          }\n        }\n      }\n    } else {\n      y = this.note.bounds.y - minDistanceAway; // the lowest the line could be at\n      // convert y to be based around center Y between top and bottom staff lines so that it is symmetric:\n      y += ctxt.staffLineCount * ctxt.staffInterval;\n\n      step = Math.floor(y / ctxt.staffInterval);\n      // if there's enough space, center the episema between the punctum and the next staff line\n      if (Math.abs(step % 2) === staffLineCountParity) {\n        step = (step - 3 / 4 + (y + minDistanceAway) / ctxt.staffInterval) / 2;\n      } else {\n        // otherwise, find nearest acceptable third between staff lines (or staff line)\n        step = (Math.floor((1.5 * y) / ctxt.staffInterval - 0.5) * 2 + staffLineCountNonParity) / 3;\n\n        // find nearest acceptable third between staff lines (or staff line)\n        if (Math.abs(step) % 2 === staffLineCountNonParity) {\n          // if it was a staff line, we need to adjust\n          if (Math.abs(step) < ctxt.staffLineCount || ctxt.convertStaffPositionToSymmetric(ledgerLine.staffPosition) === -step) {\n            step -= 2 / 3;\n          } else {\n            // no ledger line, but we don't want the episema to be at exactly the same height the ledger line would occupy:\n            step -= 1 / 3;\n          }\n        }\n      }\n    }\n\n    y = (step - ctxt.staffLineCount) * ctxt.staffInterval;\n\n    var width = this.note.bounds.width;\n    var x = this.note.bounds.x;\n\n    // The porrectus requires special handling of the note width,\n    // otherwise the width is just that of the note itself\n    if (\n      glyphCode === GlyphCode.Porrectus1 ||\n      glyphCode === GlyphCode.Porrectus2 ||\n      glyphCode === GlyphCode.Porrectus3 ||\n      glyphCode === GlyphCode.Porrectus4\n    )\n      width = ctxt.staffInterval;\n    else if (glyphCode === GlyphCode.None) {\n      width = ctxt.staffInterval;\n      x -= width;\n    } else if (punctumInclinatumShorten) {\n      width *= 2 / 3;\n      x += 0.5 * width;\n    } else if (glyphCode === GlyphCode.PunctumInclinatumLiquescent) {\n      width *= 2 / 3;\n      x += 0.25 * width;\n    }\n\n    // also, the position hint can affect the x/width of the episema\n    if (this.alignment === HorizontalEpisemaAlignment.Left) {\n      width *= 0.8;\n    } else if (this.alignment === HorizontalEpisemaAlignment.Center) {\n      x += width * 0.1;\n      width *= 0.8;\n    } else if (this.alignment === HorizontalEpisemaAlignment.Right) {\n      x += width * 0.2;\n      width *= 0.8;\n    }\n\n    this.bounds.x = x;\n    this.bounds.y = y - ctxt.episemaLineWeight / 2;\n    this.bounds.width = width;\n    this.bounds.height = ctxt.episemaLineWeight;\n\n    this.origin.x = 0;\n    this.origin.y = 0;\n  }\n\n  draw(ctxt) {\n    var canvasCtxt = ctxt.canvasCtxt;\n\n    canvasCtxt.fillStyle = ctxt.neumeLineColor;\n\n    canvasCtxt.fillRect(\n      this.bounds.x,\n      this.bounds.y,\n      this.bounds.width,\n      this.bounds.height\n    );\n  }\n\n  getSvgProps(ctxt) {\n    return {\n      x: this.bounds.x,\n      y: this.bounds.y,\n      width: this.bounds.width,\n      height: this.bounds.height,\n      fill: ctxt.neumeLineColor,\n      class: \"horizontalEpisema\"\n    };\n  }\n\n  createSvgNode(ctxt) {\n    return QuickSvg.createNode(\"rect\", this.getSvgProps(ctxt));\n  }\n  createSvgTree(ctxt) {\n    return QuickSvg.createSvgTree(\"rect\", this.getSvgProps(ctxt));\n  }\n\n  createSvgFragment(ctxt) {\n    return QuickSvg.createFragment(\"rect\", this.getSvgProps(ctxt));\n  }\n}\n\n/*\n * Ictus\n */\nexport class Ictus extends GlyphVisualizer {\n  constructor(ctxt, note) {\n    super(ctxt, GlyphCode.VerticalEpisemaAbove);\n    this.note = note;\n    this.positionHint = MarkingPositionHint.Default;\n  }\n\n  performLayout(ctxt) {\n    var glyphCode = this.note.glyphVisualizer.glyphCode;\n    // we have to place the ictus further from the note in some cases to avoid a collision with an episema on the same note:\n    var positionHint = this.positionHint || MarkingPositionHint.Below;\n    var staffPosition =\n      this.note.staffPosition +\n      (positionHint === MarkingPositionHint.Above ? 1 : -1);\n    var collisionWithEpisema =\n      this.note.episemata.length > 0 &&\n      (this.note.episemata[0].positionHint || MarkingPositionHint.Above) ===\n        positionHint;\n    var horizontalOffset;\n    var verticalOffset = 1;\n    var shortOffset = -0.2;\n    var extraOffset = 0;\n    var collisionWithStaffLine =\n      staffPosition % 2 &&\n      (Math.abs(ctxt.convertStaffPositionToSymmetric(staffPosition)) < ctxt.staffLineCount ||\n        (this.note.neume.ledgerLines[0] || {}).staffPosition === staffPosition);\n\n    // The porrectus requires special handling of the note width,\n    // otherwise the width is just that of the note itself\n    if (\n      glyphCode === GlyphCode.Porrectus1 ||\n      glyphCode === GlyphCode.Porrectus2 ||\n      glyphCode === GlyphCode.Porrectus3 ||\n      glyphCode === GlyphCode.Porrectus4\n    )\n      horizontalOffset = ctxt.staffInterval / 2;\n    else if (glyphCode === GlyphCode.None) {\n      horizontalOffset = -ctxt.staffInterval / 2;\n    } else {\n      horizontalOffset = this.note.bounds.width / 2;\n      if (\n        glyphCode === GlyphCode.PunctumInclinatum &&\n        !collisionWithStaffLine &&\n        !collisionWithEpisema\n      ) {\n        extraOffset = 0.3;\n      }\n    }\n\n    if (this.positionHint === MarkingPositionHint.Above) {\n      glyphCode = GlyphCode.VerticalEpisemaAbove;\n      verticalOffset *= -1;\n    } else {\n      glyphCode = GlyphCode.VerticalEpisemaBelow;\n    }\n    if (collisionWithEpisema) {\n      extraOffset = 0.4;\n    }\n    verticalOffset *=\n      ctxt.staffInterval *\n      (extraOffset + (collisionWithStaffLine ? 0.3 : shortOffset));\n\n    this.setGlyph(ctxt, glyphCode);\n    this.setStaffPosition(ctxt, staffPosition);\n\n    this.bounds.x = this.note.bounds.x + horizontalOffset - this.origin.x;\n    this.bounds.y += verticalOffset;\n  }\n}\n\n/*\n * Mora\n */\nexport class Mora extends GlyphVisualizer {\n  constructor(ctxt, note) {\n    super(ctxt, GlyphCode.Mora);\n    this.note = note;\n    this.positionHint = MarkingPositionHint.Default;\n    this.horizontalOffset = ctxt.staffInterval / 2 + this.origin.x;\n  }\n\n  performLayout(ctxt) {\n    this.setGlyph(ctxt, this.glyphCode);\n    this.horizontalOffset = ctxt.staffInterval / 2 + this.origin.x;\n    var staffPosition = this.note.staffPosition;\n\n    this.setStaffPosition(ctxt, staffPosition);\n\n    var verticalOffset = 0;\n    // First, we need to find the next note in the neume.\n    var noteIndex = this.note.neume.notes.indexOf(this.note);\n    var nextNote;\n    if (noteIndex >= 0) {\n      ++noteIndex;\n      if (this.note.neume.notes.length > noteIndex) {\n        nextNote = this.note.neume.notes[noteIndex];\n        if (\n          nextNote.morae &&\n          nextNote.morae.length &&\n          this.note.neume.notes.length === noteIndex + 1\n        ) {\n          // this note is the second to last in its neume, and the last note also has a mora\n          this.horizontalOffset +=\n            nextNote.bounds.right() - this.note.bounds.right();\n        } else if (nextNote.bounds.right() > this.note.bounds.right()) {\n          // center the dot over the following note.\n          this.horizontalOffset =\n            (nextNote.bounds.right() -\n              this.note.bounds.right() -\n              this.bounds.right()) /\n            2;\n        } else {\n          nextNote = null;\n        }\n      } else if (this.note.neume.notes.length === noteIndex) {\n        // this note is the last in its neume:\n        if (this.note.neume.trailingSpace === 0) {\n          // if this was the last note in its neume, we only care about the next note if there is no trailing space at the end of this neume.\n          var notationIndex = this.note.neume.score.notations.indexOf(\n            this.note.neume\n          );\n          if (notationIndex >= 0) {\n            var nextNotation = this.note.neume.score.notations[\n              notationIndex + 1\n            ];\n            if (nextNotation && nextNotation.notes) {\n              nextNote = nextNotation.notes[0];\n            }\n          }\n        } else if (this.note.shape !== NoteShape.Inclinatum) {\n          this.note.neume.calculatedTrailingSpace += this.origin.x;\n        }\n      }\n    }\n\n    if (this.positionHint === MarkingPositionHint.Above) {\n      if (staffPosition % 2 === 0) verticalOffset -= ctxt.staffInterval * 1.75;\n      else verticalOffset -= ctxt.staffInterval * 0.75;\n    } else if (this.positionHint === MarkingPositionHint.Below) {\n      if (staffPosition % 2 === 0) verticalOffset += ctxt.staffInterval * 1.75;\n      else verticalOffset += ctxt.staffInterval * 0.75;\n    } else {\n      if (staffPosition % 2 === 0) {\n        // if the note is in a space and followed by a note on the line below, we often want to move the mora dot up slightly so that it is centered\n        // between the top of the note's space and the top of the following note.\n        if (nextNote && nextNote.staffPosition === staffPosition - 1) {\n          verticalOffset -= ctxt.staffInterval * 0.25;\n        }\n      } else {\n        verticalOffset -= ctxt.staffInterval * 0.75;\n      }\n    }\n    this.bounds.x = this.horizontalOffset + this.note.bounds.right();\n    this.bounds.y += verticalOffset;\n  }\n}\n\n// indicates the shape of the brace\nexport var BraceShape = {\n  RoundBrace: 0,\n  CurlyBrace: 1,\n  AccentedCurlyBrace: 2\n};\n\n// indicates how the brace is alignerd to the note to which it's connected\nexport var BraceAttachment = {\n  Left: 0,\n  Right: 1\n};\n\nexport class BracePoint extends ChantLayoutElement {\n  constructor(note, isAbove, shape, attachment) {\n    super();\n\n    this.note = note;\n    this.isAbove = isAbove;\n    this.shape = shape;\n    this.attachment = attachment;\n  }\n\n  getAttachmentX(note) {\n    if (!note) note = this.note;\n    if (this.attachment === BraceAttachment.Left)\n      return (note.neume ? note.neume.bounds.x : 0) + note.bounds.x;\n    else return (note.neume ? note.neume.bounds.x : 0) + note.bounds.right();\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Exsurge.Chant.Markings.js","//\n// Author(s):\n// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>\n//\n// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n//\n\nimport { Step } from \"./Exsurge.Core.js\";\nimport {\n  ChantNotationElement, DividerLineVisualizer, GlyphCode,\n  GlyphVisualizer,\n  RoundBraceVisualizer\n} from \"./Exsurge.Drawing.js\";\n\n/*\n *\n */\nexport class Custos extends ChantNotationElement {\n  // if auto is true, then the custos will automatically try to determine it's height based on\n  // subsequent notations\n  constructor(auto = false) {\n    super();\n    this.auto = auto;\n    this.staffPosition = 2; // default sane value\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    if (this.auto) {\n      var neume = ctxt.findNextNeume();\n\n      if (neume)\n        this.staffPosition = ctxt.activeClef.pitchToStaffPosition(\n          neume.notes[0].pitch\n        );\n\n      // in case there was a weird fa/do clef change, let's sanitize the staffPosition by making sure it is\n      // within reasonable bounds\n      while (this.staffPosition < -2) this.staffPosition += 7;\n\n      while (this.staffPosition > 2 * ctxt.staffLineCount + 2) this.staffPosition -= 7;\n    }\n\n    var glyph = new GlyphVisualizer(\n      ctxt,\n      Custos.getGlyphCode(this.staffPosition, ctxt.staffLineCount)\n    );\n    glyph.setStaffPosition(ctxt, this.staffPosition);\n    this.addVisualizer(glyph);\n\n    this.finishLayout(ctxt);\n  }\n\n  // called when layout has changed and our dependencies are no longer good\n  resetDependencies() {\n    // we only need to resolve new dependencies if we're an automatic custos\n    if (this.auto) this.needsLayout = true;\n  }\n\n  /**\n   * \n   * @param {number} staffPosition position of custos\n   * @param {number} staffLineCount number of lines on staff\n   * @returns \n   */\n  static getGlyphCode(staffPosition, staffLineCount = 4) {\n    if (staffPosition <= staffLineCount * 2 - 2) {\n      // ascending custos\n      if (Math.abs(staffPosition) % 2 === 1) return GlyphCode.CustosLong;\n      else return GlyphCode.CustosShort;\n    } else {\n      // descending custos\n      if (Math.abs(staffPosition) % 2 === 1) return GlyphCode.CustosDescLong;\n      else return GlyphCode.CustosDescShort;\n    }\n  }\n}\n\n/*\n * Divider\n */\nexport class Divider extends ChantNotationElement {\n  constructor(withCarryover = false) {\n    super();\n\n    this.isDivider = true;\n    this.hasCarryover = withCarryover || false;\n    this.resetsAccidentals = true;\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n    if (this.hasCarryover) {\n      const top = ctxt.staffLineCount * 2;\n      const y = ctxt.calculateHeightFromStaffPosition(top);\n      this.addVisualizer(new RoundBraceVisualizer(ctxt, -ctxt.staffInterval * 1.5, ctxt.staffInterval * 1.5, y, true));\n    }\n    \n  }\n}\n\n/*\n * QuarterBar\n */\nexport class QuarterBar extends Divider {\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n    const top = ctxt.staffLineCount * 2;\n    this.addVisualizer(new DividerLineVisualizer(ctxt, top - 2, top, this));\n    this.origin.x = this.bounds.width / 2;\n\n    this.finishLayout(ctxt);\n  }\n}\n\n/*\n * HalfBar\n */\nexport class HalfBar extends Divider {\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    const offset = ctxt.staffLineCount === 2 ? 1.5 : 2;\n    this.addVisualizer(new DividerLineVisualizer(ctxt, offset, ctxt.staffLineCount * 2 - offset, this));\n\n    this.origin.x = this.bounds.width / 2;\n\n    this.finishLayout(ctxt);\n  }\n}\n\n/*\n * FullBar\n */\nexport class FullBar extends Divider {\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    this.addVisualizer(new DividerLineVisualizer(ctxt, 1, ctxt.staffLineCount * 2 - 1, this));\n\n    this.origin.x = this.bounds.width / 2;\n\n    this.finishLayout(ctxt);\n  }\n}\n\n/*\n * Insertion Cursor\n */\nexport class InsertionCursor extends Divider {\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n    this.cssClass = 'InsertionCursor';\n\n    this.addVisualizer(new DividerLineVisualizer(ctxt, 0, ctxt.staffLineCount * 2));\n\n    this.origin.x = this.bounds.width / 2;\n    this.bounds.width = 0;\n    this.bounds.height = 0;\n\n    this.finishLayout(ctxt);\n  }\n}\n\n/*\n * DominicanBar\n */\nexport class DominicanBar extends Divider {\n  constructor(staffPosition) {\n    super();\n    var parity = (staffPosition + 1) % 2;\n\n    this.staffPosition = staffPosition - 2 * parity;\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n    this.addVisualizer(\n      new DividerLineVisualizer(\n        ctxt,\n        this.staffPosition,\n        this.staffPosition + 3,\n        this\n      )\n    );\n\n    this.origin.x = this.bounds.width / 2;\n\n    this.finishLayout(ctxt);\n  }\n}\n\n/*\n * DoubleBar\n */\nexport class DoubleBar extends Divider {\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    const top = ctxt.staffLineCount * 2 - 1;\n    var line0 = new DividerLineVisualizer(ctxt, 1, top, this);\n    line0.bounds.x = 0;\n    this.addVisualizer(line0);\n\n    var line1 = new DividerLineVisualizer(ctxt, 1, top, this);\n    line1.bounds.x = ctxt.intraNeumeSpacing * 2 - line1.bounds.width;\n    this.addVisualizer(line1);\n\n    this.origin.x = this.bounds.width / 2;\n\n    this.finishLayout(ctxt);\n  }\n}\n\nexport const AccidentalType = {\n  Flat: -1,\n  Natural: 0,\n  Sharp: 1\n};\n\n/*\n * Accidental\n */\nexport class Accidental extends ChantNotationElement {\n  constructor(staffPosition, accidentalType) {\n    super();\n    this.isAccidental = true;\n    this.keepWithNext = true; // accidentals should always stay connected...\n\n    this.staffPosition = staffPosition;\n    this.accidentalType = accidentalType;\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    this.addVisualizer(this.createGlyphVisualizer(ctxt));\n\n    this.finishLayout(ctxt);\n  }\n\n  // creation of the glyph visualizer is refactored out or performLayout\n  // so that clefs can use the same logic for their accidental glyph\n  createGlyphVisualizer(ctxt) {\n    var glyphCode = GlyphCode.Flat;\n\n    switch (this.accidentalType) {\n      case AccidentalType.Natural:\n        glyphCode = GlyphCode.Natural;\n        break;\n      case AccidentalType.Sharp:\n        glyphCode = GlyphCode.Sharp;\n        break;\n      default:\n        glyphCode = GlyphCode.Flat;\n        break;\n    }\n\n    var glyph = new GlyphVisualizer(ctxt, glyphCode);\n    glyph.setStaffPosition(ctxt, this.staffPosition);\n\n    return glyph;\n  }\n\n  adjustStep(step) {\n    switch (this.accidentalType) {\n      case AccidentalType.Flat:\n        if (step === Step.Ti) return Step.Te;\n        if (step === Step.Mi) return Step.Me;\n        break;\n      case AccidentalType.Sharp:\n        if (step === Step.Do) return Step.Du;\n        if (step === Step.Fa) return Step.Fu;\n        break;\n      case AccidentalType.Natural:\n        if (step === Step.Te) return Step.Ti;\n        if (step === Step.Me) return Step.Mi;\n        if (step === Step.Du) return Step.Do;\n        if (step === Step.Fu) return Step.Fa;\n        break;\n    }\n\n    // no adjustment needed\n    return step;\n  }\n\n  applyToPitch(pitch) {\n    // no adjusment needed\n    if (this.pitch.octave !== pitch.octave) return;\n\n    pitch.step = this.adjustStep(pitch.step);\n  }\n}\n\n/*\n * Virgula\n */\nexport class Virgula extends Divider {\n  constructor(withCarryover = false) {\n    super(withCarryover);\n\n    // unlike other dividers a virgula does not reset accidentals\n    this.resetsAccidentals = false;\n\n    // the staff position of the virgula is customizable, so that it\n    // can be placed on different lines (top or bottom) depending on the\n    // notation tradition of what is being notated (e.g., Benedictine has it\n    //  on top line, Norbertine at the bottom)\n    this.staffPosition = 7;\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    var glyph = new GlyphVisualizer(ctxt, GlyphCode.Virgula);\n    glyph.setStaffPosition(ctxt, this.staffPosition);\n\n    this.addVisualizer(glyph);\n\n    this.origin.x = this.bounds.width / 2;\n\n    this.finishLayout(ctxt);\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Exsurge.Chant.Signs.js","//\n// Author(s):\n// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>\n//\n// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n//\n\nimport {\n  Units,\n  Pitch,\n  Point,\n  Rect,\n  Margins,\n  Size,\n  Step\n} from \"./Exsurge.Core.js\";\nimport {\n  MarkingPositionHint,\n  LyricType,\n  Lyric,\n  LyricArray,\n  AboveLinesText,\n  ChoralSign,\n  TranslationText,\n  DefaultTrailingSpace,\n  GlyphCode\n} from \"./Exsurge.Drawing.js\";\nimport {\n  Note,\n  LiquescentType,\n  NoteShape,\n  NoteShapeModifiers,\n  ChantMapping,\n  ChantScore,\n  ChantDocument,\n  Clef,\n  DoClef,\n  FaClef,\n  TrebleClef,\n  TextOnly,\n  ChantLineBreak\n} from \"./Exsurge.Chant.js\";\nimport * as Markings from \"./Exsurge.Chant.Markings.js\";\nimport * as Signs from \"./Exsurge.Chant.Signs.js\";\nimport * as Neumes from \"./Exsurge.Chant.Neumes.js\";\n\n// reusable reg exps\nvar __syllablesRegex = /(?=\\S)((?:<v>[\\s\\S]*<\\/v>|[^(])*)(?:\\(?([^)]*)\\)?)?/g\nvar __altTranslationRegex = /<alt>(.*?)<\\/alt>|\\[(alt:)?(.*?)\\]/g;\n\nvar __notationsRegex = /z0|z|Z|(::|(?::|[,;][1-8]?|`)_?)|(?:[cfg]|cb|treble-?)[1-5]|\\/+| |\\!|-?[a-mA-M][oOwWvVrRsxy#~\\+><_\\.'012345]*(?:\\[[^\\]]*\\]?)*|\\{([^}]+)\\}?/g;\nvar __notationsRegex_group_bar = 1;\nvar __notationsRegex_group_insideBraces = 2;\n\nvar __bracketedCommandRegex = /^([a-z]+):(.*)/;\n\n// for the brace string inside of [ and ] in notation data\n// the capturing groups are:\n//  1. o or u, to indicate over or under\n//  2. b, cb, or cba, to indicate the brace type\n//  3. 0 or 1 to indicate the attachment point\n//  4. { or } to indicate opening/closing (this group will be null if the metric version is used)\n//  5. a float indicating the millimeter length of the brace (not supported yet)\nvar __braceSpecRegex = /([ou])(b|cb|cba):([01])(?:([{}])|;(\\d*(?:\\.\\d+)?)mm)/;\n\nconst TrailingSpaceForAccidental = ctxt =>\n  ctxt.intraNeumeSpacing * ctxt.accidentalSpaceMultiplier;\nconst TrailingSpaceMultiple = multiplier => ctxt =>\n  ctxt.intraNeumeSpacing * multiplier;\n\nconst regexHeaderEnd = /(?:^|\\n)%%\\s?\\n/;\nconst regexHeaderLine = /^([\\w-_.]+):\\s*((?:[^;\\r\\n]|;[ \\t])*)(?:;|$)/i;\nconst regexHeaderComment = /^%.*/;\nexport class GabcHeader {\n  static getLength(gabc) {\n    let match = gabc.match(regexHeaderEnd);\n    return match ? match.index + match[0].length : 0;\n  }\n\n  constructor(text) {\n    if (typeof text !== \"string\") text = \"\";\n    this.comments = [];\n    this.cValues = {};\n    this.original = \"\";\n    let match = text.match(regexHeaderEnd);\n    if (match) {\n      let txtHeader = (this.original = text.slice(\n        0,\n        match.index + match[0].length\n      ));\n      var lines = txtHeader.split(/\\r?\\n/g);\n      for (var i = 0; i < lines.length; ++i) {\n        let line = lines[i],\n          match = regexHeaderLine.exec(line);\n        if (match) {\n          var key = match[1].replace(/-([a-z])/g, function(a, letter) {\n            return letter.toUpperCase();\n          });\n          if (this[match[1]]) {\n            var arrayName = match[1] + \"Array\";\n            if (!this[arrayName]) {\n              this[arrayName] = [this[match[1]]];\n            }\n            this[arrayName].push(match[2]);\n          } else {\n            this[match[1]] = match[2];\n          }\n          if (key !== match[1]) this[key] = this[match[1]];\n        } else if ((match = regexHeaderComment.exec(line))) {\n          if (line !== \"%%\") {\n            match = regexHeaderLine.exec(line.slice(1));\n            if (match) {\n              let key = match[1].replace(/-([a-z])/g, function(a, letter) {\n                return letter.toUpperCase();\n              });\n              this.cValues[match[1]] = match[2];\n              if (key !== match[1]) this.cValues[key] = match[2];\n            } else {\n              this.comments[i] = line;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  toString() {\n    var result = [];\n    for (let key in this) {\n      if (\n        typeof this[key] !== \"string\" ||\n        /^(length|original|comments|cValues)$/.test(key)\n      ) {\n        continue;\n      }\n      var alternateKey = key.replace(/[A-Z]/g, function(letter) {\n        return \"-\" + letter.toLowerCase();\n      });\n      if (alternateKey !== key && alternateKey in this) continue;\n      var array = this[key + \"Array\"];\n      if (array) {\n        for (var i = 0; i < array.length; ++i) {\n          result.push(key + \": \" + array[i] + \";\");\n        }\n      } else {\n        result.push(key + \": \" + this[key] + \";\");\n      }\n    }\n    for (let key in this.cValues) {\n      if (key.length === 0 || !this.cValues.hasOwnProperty(key)) continue;\n      result.push(\"%\" + key + \": \" + this.cValues[key] + \";\");\n    }\n    for (let i in this.comments) {\n      if (!this.comments.hasOwnProperty(i)) continue;\n      try {\n        result.splice(i, 0, this.comments[i]);\n      } catch (e) {\n        console.warn(e);\n      }\n    }\n    return result.join(\"\\n\") + \"\\n%%\\n\";\n  }\n}\n\nvar elementCountForNotations = items =>\n  items.reduce((sum, item) => sum + (item.notes ? item.notes.length : 1), 0);\n\nexport class Gabc {\n  // takes gabc source code (without the header info) and returns an array\n  // of ChantMappings describing the chant. A chant score can then be created\n  // fron the chant mappings and later updated via updateMappings() if need\n  // be...\n  static createMappingsFromSource(ctxt, gabcSource) {\n    var headerLength = GabcHeader.getLength(gabcSource);\n    gabcSource = gabcSource.slice(headerLength);\n    var words = this.splitWords(gabcSource);\n\n    // set the default clef\n    ctxt.activeClef = Clef.default();\n\n    var mappings = this.createMappingsFromWords(\n      ctxt,\n      words,\n      clef => (ctxt.activeClef = clef)\n    );\n\n    // always set the last notation to have a trailingSpace of 0. This makes layout for the last chant line simpler\n    if (\n      mappings.length > 0 &&\n      mappings[mappings.length - 1].notations.length > 0\n    )\n      mappings[mappings.length - 1].notations[\n        mappings[mappings.length - 1].notations.length - 1\n      ].trailingSpace = 0;\n\n    return mappings;\n  }\n\n  // A simple general purpose diff algorithm adapted here for comparing\n  // an array of existing mappings with an updated list of gabc words.\n  // note before is an array of mappings, and after is an array of strings\n  // (gabc words).\n  //\n  // This is definitely not the most effecient diff algorithm, but for our\n  // limited needs and source size it seems to work just fine...\n  //\n  // code is adapted from: https://github.com/paulgb/simplediff\n  //\n  // Returns:\n  //   A list of pairs, with the first part of the pair being one of three\n  //   strings ('-', '+', '=') and the second part being a list of values from\n  //   the original before and/or after lists. The first part of the pair\n  //   corresponds to whether the list of values is a deletion, insertion, or\n  //   unchanged, respectively.\n  static diffDescriptorsAndNewWords(before, after) {\n    // Create a map from before values to their indices\n    var oldIndexMap = {},\n      i;\n    for (i = 0; i < before.length; i++) {\n      oldIndexMap[before[i].source] = oldIndexMap[before[i].source] || [];\n      oldIndexMap[before[i].source].push(i);\n    }\n\n    var overlap = [],\n      startOld,\n      startNew,\n      subLength,\n      inew;\n\n    startOld = startNew = subLength = 0;\n\n    for (inew = 0; inew < after.length; inew++) {\n      var _overlap = [];\n      oldIndexMap[after[inew]] = oldIndexMap[after[inew]] || [];\n      for (i = 0; i < oldIndexMap[after[inew]].length; i++) {\n        var iold = oldIndexMap[after[inew]][i];\n        // now we are considering all values of val such that\n        // `before[iold] == after[inew]`\n        _overlap[iold] = ((iold && overlap[iold - 1]) || 0) + 1;\n        if (_overlap[iold] > subLength) {\n          // this is the largest substring seen so far, so store its indices\n          subLength = _overlap[iold];\n          startOld = iold - subLength + 1;\n          startNew = inew - subLength + 1;\n        }\n      }\n      overlap = _overlap;\n    }\n\n    if (subLength === 0) {\n      // If no common substring is found, we return an insert and delete...\n      var result = [];\n\n      if (before.length) result.push([\"-\", before]);\n\n      if (after.length) result.push([\"+\", after]);\n\n      return result;\n    }\n\n    // ...otherwise, the common substring is unchanged and we recursively\n    // diff the text before and after that substring\n    return [].concat(\n      this.diffDescriptorsAndNewWords(\n        before.slice(0, startOld),\n        after.slice(0, startNew)\n      ),\n      [[\"=\", after.slice(startNew, startNew + subLength)]],\n      this.diffDescriptorsAndNewWords(\n        before.slice(startOld + subLength),\n        after.slice(startNew + subLength)\n      )\n    );\n  }\n\n  // this function essentially performs and applies a rudimentary diff between a\n  // previously parsed set of mappings and between a new gabc source text.\n  // the mappings array passed in is changed in place to be updated from the\n  // new source\n  static updateMappingsFromSource(\n    ctxt,\n    mappings,\n    newGabcSource,\n    insertionIndex = null,\n    oldInsertionIndex = null\n  ) {\n    var headerLength = GabcHeader.getLength(newGabcSource);\n    newGabcSource = newGabcSource.slice(headerLength);\n    // always remove the last old mapping since it's spacing/trailingSpace is handled specially\n    mappings.pop();\n\n    if (insertionIndex === null) {\n      insertionIndex = NaN;\n    }\n    if (oldInsertionIndex === null) {\n      oldInsertionIndex = NaN;\n    }\n\n    var newWords = this.splitWords(newGabcSource);\n\n    var results = this.diffDescriptorsAndNewWords(mappings, newWords);\n\n    var index = 0,\n      j,\n      k,\n      l,\n      sourceIndex = 0,\n      wordLength = 0,\n      mapping,\n      elementIndex = 0;\n\n    ctxt.activeClef = Clef.default();\n\n    // apply the results to the mappings, marking notations that need to be processed\n    var lastTranslationNeumes = [];\n    for (var i = 0; i < results.length; i++) {\n      var resultCode = results[i][0];\n      var resultValues = results[i][1];\n\n      if (index > 0)\n        sourceIndex =\n          mappings[index - 1].sourceIndex +\n          mappings[index - 1].source.length +\n          1;\n      if (resultCode === \"=\") {\n        var sourceIndexDiff = sourceIndex - mappings[index].sourceIndex;\n        // skip over ones that haven't changed, but updating the clef and source\n        // index (and pitch in case clef or accidentals have changed) as we go\n        for (j = 0; j < resultValues.length; j++, index++) {\n          mapping = mappings[index];\n          if (\n            elementIndex === 0 &&\n            mapping.notations.length &&\n            mapping.notations[0].isClef\n          ) {\n            // the first clef doesn't get kept as a notation:\n            elementIndex = -1;\n          }\n          if (\n            insertionIndex >= elementIndex ||\n            oldInsertionIndex >= elementIndex\n          ) {\n            // check if the insertion index is within this mapping:\n            let elementCount = elementCountForNotations(mapping.notations);\n            if (\n              (insertionIndex >= elementIndex &&\n                insertionIndex < elementIndex + elementCount) ||\n              (oldInsertionIndex >= elementIndex &&\n                oldInsertionIndex < elementIndex + elementCount)\n            ) {\n              // re-do this mapping:\n              // TODO: check sourceIndex\n              let sourceIndex = mapping.sourceIndex + sourceIndexDiff;\n              mapping = this.createMappingFromWord(\n                ctxt,\n                resultValues[j],\n                sourceIndex,\n                lastTranslationNeumes,\n                insertionIndex - elementIndex\n              );\n              mappings.splice(index, 1, mapping);\n\n              elementIndex += elementCount;\n              continue;\n            }\n            elementIndex += elementCount;\n          }\n          mapping.sourceIndex += sourceIndexDiff;\n          for (k = 0; k < mapping.notations.length; k++) {\n            var curNotation = mapping.notations[k];\n            var prevIsAccidental =\n              mapping.notations[k - 1] && mapping.notations[k - 1].isAccidental;\n            // notify the notation that its dependencies are no longer valid\n            curNotation.resetDependencies();\n\n            if (curNotation.isClef) {\n              ctxt.activeClef = mappings[index].notations[k];\n            }\n\n            if (curNotation.isAccidental) {\n              ctxt.activeClef.activeAccidental = curNotation;\n            } else if (\n              curNotation.resetsAccidentals ||\n              (!prevIsAccidental &&\n                curNotation.hasLyrics() &&\n                curNotation.lyrics[0].lyricType <= LyricType.BeginningSyllable)\n            ) {\n              ctxt.activeClef.resetAccidentals();\n            }\n\n            // update source index, pitch, and automatic braces\n            if (curNotation.notes) {\n              for (l = 0; l < curNotation.notes.length; ++l) {\n                let note = curNotation.notes[l];\n                note.sourceIndex += sourceIndexDiff;\n                note.pitch = ctxt.activeClef.staffPositionToPitch(\n                  note.staffPosition\n                );\n                if (note.braceEnd && note.braceEnd.automatic)\n                  delete note.braceEnd;\n                if (this.needToEndBrace && !note.braceStart && !note.braceEnd) {\n                  note.braceEnd = new Markings.BracePoint(\n                    note,\n                    this.needToEndBrace.isAbove,\n                    this.needToEndBrace.shape,\n                    this.needToEndBrace.attachment ===\n                    Markings.BraceAttachment.Left\n                      ? Markings.BraceAttachment.Right\n                      : Markings.BraceAttachment.Left\n                  );\n                  note.braceEnd.automatic = true;\n                  delete this.needToEndBrace;\n                } else if (note.braceStart && note.braceStart.automatic) {\n                  this.needToEndBrace = note.braceStart;\n                }\n              }\n            }\n            if (curNotation.translationText) {\n              for (l = 0; l < curNotation.translationText.length; ++l) {\n                let transText = curNotation.translationText[l];\n                delete transText.endNeume;\n                curNotation.translationText[l].sourceIndex += sourceIndexDiff;\n                if (\n                  transText.textAnchor === \"end\" &&\n                  lastTranslationNeumes[0]\n                ) {\n                  let lastTranslationText =\n                    lastTranslationNeumes[0].translationText[l];\n                  if (lastTranslationText)\n                    lastTranslationText.endNeume = curNotation;\n                }\n              }\n              lastTranslationNeumes[0] = curNotation;\n            }\n            if (sourceIndexDiff) {\n              if (typeof curNotation.sourceIndex === \"number\") {\n                curNotation.sourceIndex += sourceIndexDiff;\n              }\n              for (l = 0; l < curNotation.lyrics.length; ++l) {\n                curNotation.lyrics[l].sourceIndex += sourceIndexDiff;\n              }\n              if (curNotation.alText) {\n                for (l = 0; l < curNotation.alText.length; ++l) {\n                  curNotation.alText[l].sourceIndex += sourceIndexDiff;\n                }\n              }\n            }\n          }\n        }\n      } else if (resultCode === \"-\") {\n        // delete elements that no longer exist, but first notify all\n        // elements of the change\n        mappings.splice(index, resultValues.length);\n      } else if (resultCode === \"+\") {\n        // insert new ones\n        for (j = 0; j < resultValues.length; j++) {\n          wordLength = resultValues[j].length + 1;\n          mapping = this.createMappingFromWord(\n            ctxt,\n            resultValues[j],\n            sourceIndex,\n            lastTranslationNeumes,\n            insertionIndex - elementIndex\n          );\n\n          if (\n            elementIndex === 0 &&\n            mapping.notations.length &&\n            mapping.notations[0].isClef\n          ) {\n            // the first clef doesn't get kept as a notation:\n            elementIndex = -1;\n            let elementCount = elementCountForNotations(mapping.notations);\n            if (insertionIndex < elementCount) {\n              // re-do the first mapping, because it was broken up incorrectly, due to the presence of the initial clef\n              mapping = this.createMappingFromWord(\n                ctxt,\n                resultValues[j],\n                sourceIndex,\n                lastTranslationNeumes,\n                insertionIndex - elementIndex\n              );\n            }\n          }\n\n          for (k = 0; k < mapping.notations.length; k++) {\n            let curNotation = mapping.notations[k];\n            elementIndex += curNotation.notes ? curNotation.notes.length : 1;\n            if (curNotation.isClef) {\n              ctxt.activeClef = mapping.notations[k];\n            }\n          }\n\n          mappings.splice(index++, 0, mapping);\n          sourceIndex += wordLength;\n        }\n      }\n    }\n\n    // always set the last notation to have a trailingSpace of 0. This makes layout for the last chant line simpler\n    if (\n      mappings.length > 0 &&\n      mappings[mappings.length - 1].notations.length > 0\n    )\n      mappings[mappings.length - 1].notations[\n        mappings[mappings.length - 1].notations.length - 1\n      ].trailingSpace = 0;\n\n    return headerLength;\n  }\n\n  // takes an array of gabc words (like that returned by splitWords below)\n  // and returns an array of ChantMapping objects, one for each word.\n  static createMappingsFromWords(ctxt, words) {\n    var mappings = [];\n    var sourceIndex = 0,\n      wordLength = 0,\n      lastTranslationNeumes = [];\n\n    for (var i = 0; i < words.length; i++) {\n      sourceIndex += wordLength;\n      wordLength = words[i].length + 1;\n      var word = words[i].trim();\n\n      if (word === \"\") continue;\n\n      var mapping = this.createMappingFromWord(\n        ctxt,\n        word,\n        sourceIndex,\n        lastTranslationNeumes\n      );\n\n      if (mapping) mappings.push(mapping);\n    }\n\n    return mappings;\n  }\n\n  // takes a gabc word (like those returned by splitWords below) and returns\n  // a ChantMapping object that contains the gabc word source text as well\n  // as the generated notations.\n  static createMappingFromWord(\n    ctxt,\n    word,\n    sourceIndex,\n    lastTranslationNeumes,\n    insertionIndex\n  ) {\n    var matches = [];\n    var notations = [];\n    var currSyllable = 0;\n\n    while ((match = __syllablesRegex.exec(word))) matches.push(match);\n\n    for (var j = 0; j < matches.length; j++) {\n      var match = matches[j];\n\n      var lyricText = match[1].replace(\n        /(^|<\\/sp>)([\\s\\S]*?)($|<sp>)/g,\n        (_, pre, main, post) => `${pre}${main.replace(/~/g, \" \")}${post}`\n      );\n      var alText = [];\n      var translationText = [];\n      var notationData = match[2];\n\n      // new words reset the accidentals, per the Solesmes style (see LU xviij)\n      // but we need to also make sure that there _is_ a word and that it has notes associated with it.\n      if (\n        currSyllable === 0 &&\n        /[a-z]/i.test(lyricText) &&\n        /[a-m]/i.test(notationData)\n      )\n        ctxt.activeClef.resetAccidentals();\n\n      var items = this.parseNotations(\n        ctxt,\n        notationData,\n        sourceIndex + match.index + match[1].length + 1,\n        insertionIndex\n      );\n\n      if (items.length === 0) continue;\n\n      if (insertionIndex >= 0)\n        insertionIndex -= elementCountForNotations(items);\n\n      items[0].firstOfSyllable = !!lyricText;\n      items[0].firstOfParentheses = true;\n      notations.push(...items);\n\n      // add the lyrics and/or alText to the first notation that makes sense...\n      var notationWithLyrics = null;\n      for (var i = 0; i < items.length; i++) {\n        var cne = items[i];\n\n        if (cne.isAccidental && i + 1 < items.length) continue;\n\n        notationWithLyrics = cne;\n        break;\n      }\n\n      var m = __altTranslationRegex.exec();\n      let indexOffset = 0;\n      while ((m = __altTranslationRegex.exec(lyricText))) {\n        let index = m.index;\n        lyricText =\n          lyricText.slice(0, index) + lyricText.slice(index + m[0].length);\n        index += sourceIndex + indexOffset + 1;\n        if (typeof m[1] === \"string\") {\n          let elem = new AboveLinesText(\n            ctxt,\n            m[1],\n            notationWithLyrics,\n            index + 4\n          );\n          elem.alIndex = alText.push(elem) - 1;\n        } else if (typeof m[2] === \"string\") {\n          let elem = new AboveLinesText(\n            ctxt,\n            m[3],\n            notationWithLyrics,\n            index + m[2].length\n          );\n          elem.alIndex = alText.push(elem) - 1;\n        } else {\n          let elem = new TranslationText(ctxt, m[3], notationWithLyrics, index);\n          elem.translationIndex = translationText.push(elem) - 1;\n        }\n        indexOffset += m[0].length;\n        __altTranslationRegex.exec();\n      }\n      if (lyricText === \"\" && alText.length === 0) continue;\n\n      if (notationWithLyrics === null)\n        return new ChantMapping(word, notations, sourceIndex);\n\n      if (alText.length) notationWithLyrics.alText = alText;\n\n      if (translationText.length) {\n        notationWithLyrics.translationText = translationText;\n        for (i = 0; i < translationText.length; ++i) {\n          let transText = translationText[i];\n          if (transText.textAnchor === \"end\" && lastTranslationNeumes[0]) {\n            let lastTranslationText =\n              lastTranslationNeumes[0].translationText[i];\n            if (lastTranslationText)\n              lastTranslationText.endNeume = notationWithLyrics;\n          }\n        }\n        lastTranslationNeumes[0] = notationWithLyrics;\n      }\n\n      if (lyricText === \"\") continue;\n\n      var proposedLyricType;\n\n      // if it's not a neume or a TextOnly notation, then make the lyrics a directive\n      if (!cne.isNeume && cne.constructor !== TextOnly)\n        proposedLyricType = LyricType.Directive;\n      // otherwise trye to guess the lyricType for the first lyric anyway\n      else if (currSyllable === 0 && j === matches.length - 1)\n        proposedLyricType = LyricType.SingleSyllable;\n      else if (currSyllable === 0 && j < matches.length - 1)\n        proposedLyricType = LyricType.BeginningSyllable;\n      else if (j === matches.length - 1)\n        proposedLyricType = LyricType.EndingSyllable;\n      else proposedLyricType = LyricType.MiddleSyllable;\n\n      currSyllable++;\n\n      var lyrics = this.createSyllableLyrics(\n        ctxt,\n        lyricText,\n        proposedLyricType,\n        notationWithLyrics,\n        items,\n        sourceIndex + match.index\n      );\n\n      if (lyrics === null || lyrics.length === 0) continue;\n\n      notationWithLyrics.lyrics = lyrics;\n    }\n\n    return new ChantMapping(word, notations, sourceIndex);\n  }\n\n  // returns an array of lyrics (an array because each syllable can have multiple lyrics)\n  static createSyllableLyrics(\n    ctxt,\n    text,\n    proposedLyricType,\n    notation,\n    notations,\n    sourceIndex\n  ) {\n    var lyrics = [];\n\n    // an extension to gabc: multiple lyrics per syllable can be separated by a |\n    var lyricTexts = text.split(\"|\");\n\n    for (var i = 0; i < lyricTexts.length; i++) {\n      var lyricText = lyricTexts[i];\n\n      if (i > 0) {\n        if (lyricText.match(/\\s$/)) {\n          lyricText = lyricText.replace(/s+$/, \"\");\n          proposedLyricType = LyricType.EndingSyllable;\n        } else {\n          proposedLyricType = LyricType.MiddleSyllable;\n        }\n      }\n\n      // gabc allows lyrics to indicate the centering part of the text by\n      // using braces to indicate how to center the lyric. So a lyric can\n      // look like \"f{i}re\" or \"{fenced}\" to center on the i or on the entire\n      // word, respectively. Here we determine if the lyric should be spaced\n      // manually with this method of using braces.\n      // however, we don't want to consider any braces inside of v tags, so we\n      // do a bit of text processing here:\n      var lyricTextWithoutVTags = lyricText;\n      const vtagRegex = /<v>[\\s\\S]*?<\\/v>/;\n      let match;\n      const vtags = [];\n      while ((match = vtagRegex.exec(lyricTextWithoutVTags))) {\n        let index = match.index;\n        let length = match[0].length;\n        vtags[index] = length;\n        lyricTextWithoutVTags = lyricTextWithoutVTags.slice(0, index) + lyricTextWithoutVTags.slice(index + length);\n      }\n      var centerStartIndex = lyricTextWithoutVTags.indexOf(\"{\");\n      var centerLength = 0;\n\n      if (centerStartIndex >= 0) {\n        let indexClosingBracket = lyricTextWithoutVTags.indexOf(\"}\");\n\n        if (\n          indexClosingBracket >= 0 &&\n          indexClosingBracket > centerStartIndex\n        ) {\n          const getTrueIndex = (indexWithoutVTags) => {\n            // map indices back to the lyricText with the V tags:\n            let accum = 0;\n            for (let index in vtags) {\n              if (vtags.hasOwnProperty(index) && indexWithoutVTags >= index) {\n                accum += vtags[index];\n              } else {\n                break;\n              }\n            }\n            return indexWithoutVTags + accum;\n          }\n          centerStartIndex = getTrueIndex(centerStartIndex);\n          indexClosingBracket = getTrueIndex(indexClosingBracket);\n          centerLength = indexClosingBracket - centerStartIndex - 1;\n\n          // strip out the brackets:\n          lyricText =\n            lyricText.substring(0, centerStartIndex) +\n            lyricText.substring(centerStartIndex + 1, indexClosingBracket) +\n            lyricText.substring(indexClosingBracket + 1, lyricText.length);\n        } else centerStartIndex = -1; // if there's no closing bracket, don't enable centering\n      }\n\n      var lyric = this.makeLyric(\n        ctxt,\n        lyricText,\n        proposedLyricType,\n        notation,\n        notations,\n        sourceIndex\n      );\n\n      if (centerStartIndex >= 0) {\n        // update indices in case there had been any tags, etc.\n        let textIndex = 0,\n          centerEndIndex = -1;\n        for (let span of lyric.spans) {\n          if (\n            centerStartIndex >= span.index &&\n            centerStartIndex <= span.index + span.text.length\n          ) {\n            centerEndIndex = centerStartIndex + centerLength;\n            centerStartIndex += textIndex - span.index;\n          }\n          if (\n            centerEndIndex >= 0 &&\n            centerEndIndex >= span.index &&\n            centerEndIndex <= span.index + span.text.length\n          ) {\n            centerEndIndex += textIndex - span.index;\n            centerLength = centerEndIndex - centerStartIndex;\n            centerEndIndex = -1;\n            break;\n          }\n          textIndex += span.text.length;\n        }\n        if (centerEndIndex >= 0) {\n          centerEndIndex = textIndex;\n          centerLength = centerEndIndex - centerStartIndex;\n        }\n      }\n\n      // if we have manual lyric centering, then set it now\n      if (centerStartIndex >= 0) {\n        lyric.centerStartIndex = centerStartIndex;\n        lyric.centerLength = centerLength;\n      }\n\n      lyric.lyricIndex = lyrics.push(lyric) - 1;\n      sourceIndex += lyricText.length + 1;\n    }\n    notation.lyrics = lyrics;\n    return lyrics;\n  }\n\n  static makeLyric(ctxt, text, lyricType, notation, notations, sourceIndex) {\n    var elides = false;\n    var forceConnector = false;\n    if (text.length > 1) {\n      if (text[text.length - 1] === \"-\") {\n        forceConnector = true;\n        if (lyricType === LyricType.EndingSyllable)\n          lyricType = LyricType.MiddleSyllable;\n        else if (lyricType === LyricType.SingleSyllable)\n          lyricType = LyricType.BeginningSyllable;\n\n        text = text.slice(0, -1);\n      } else if (text[text.length - 1] === \" \") {\n        if (lyricType === LyricType.MiddleSyllable)\n          lyricType = LyricType.EndingSyllable;\n        else if (lyricType === LyricType.BeginningSyllable)\n          lyricType = LyricType.SingleSyllable;\n\n        text = text.slice(0, -1);\n      } else if (/<\\/i>$/.test(text)) {\n        // must be an elision\n        elides = true;\n      }\n    }\n\n    if (text.match(/^(?:[*†]+|i+j|\\d+)\\.?$/)) lyricType = LyricType.Directive;\n\n    var lyric = new Lyric(\n      ctxt,\n      text,\n      lyricType,\n      notation,\n      notations,\n      sourceIndex\n    );\n    lyric.elidesToNext = elides;\n    if (forceConnector) lyric.setForceConnector(true);\n\n    return lyric;\n  }\n\n  // takes a string of gabc notations and creates exsurge objects out of them.\n  // returns an array of notations.\n  static parseNotations(ctxt, data, sourceIndex, insertionIndex) {\n    // if there is no data, then this must be a text only object\n    if (!data) return [new TextOnly(sourceIndex, 0)];\n\n    var baseSourceIndex = sourceIndex;\n    var sourceLength = 0;\n    var notations = [];\n    var notes = [];\n    var trailingSpace = DefaultTrailingSpace;\n\n    var addToLastSourceGabc = gabc => {\n      if (notes.length > 0) {\n        notes[notes.length - 1].sourceGabc += gabc;\n      }\n    };\n    var addNotation = notation => {\n      // first, if we have any notes left over, we create a neume out of them\n      if (notes.length > 0) {\n        // create neume(s)\n        var neumes = this.createNeumesFromNotes(ctxt, notes, trailingSpace);\n        for (var i = 0; i < neumes.length; i++) notations.push(neumes[i]);\n\n        notes = [];\n      }\n\n      // reset the trailing space\n      trailingSpace = DefaultTrailingSpace;\n\n      // then, if we're passed a notation, let's add it\n      // also, perform chant logic here\n      if (notation !== null) {\n        let prevNotation = notations[notations.length - 1];\n        notation.sourceIndex = sourceIndex;\n        notation.sourceGabc = match[0];\n        if (notation.isClef) {\n          ctxt.activeClef = notation;\n          if (\n            prevNotation &&\n            prevNotation.trailingSpace.isDefault &&\n            prevNotation.isDivider\n          ) {\n            prevNotation.trailingSpace = TrailingSpaceForAccidental;\n          }\n        } else if (notation.isAccidental) {\n          ctxt.activeClef.activeAccidental = notation;\n        } else if (\n          notation.trailingSpace.isDefault &&\n          notation instanceof Signs.Custos\n        ) {\n          notation.trailingSpace = TrailingSpaceForAccidental;\n        } else if (notation.resetsAccidentals)\n          ctxt.activeClef.resetAccidentals();\n\n        notations.push(notation);\n      }\n    };\n\n    var regex = new RegExp(__notationsRegex);\n    var match;\n\n    while ((match = regex.exec(data))) {\n      sourceIndex = baseSourceIndex + match.index;\n      sourceLength = match[0].length;\n      var atom = match[0];\n      var bar = match[__notationsRegex_group_bar];\n\n      let barWithCarryover = !!bar && bar.endsWith('_');\n      if (barWithCarryover) {\n        atom = atom.slice(0, -1);\n      }\n\n      // handle the clefs and dividers here\n      switch (atom) {\n        case \",\":\n          addNotation(new Signs.QuarterBar(barWithCarryover));\n          break;\n        case \"`\":\n          addNotation(new Signs.Virgula(barWithCarryover));\n          break;\n        case \";\":\n          addNotation(new Signs.HalfBar(barWithCarryover));\n          break;\n        case \";1\":\n        case \";2\":\n        case \";3\":\n        case \";4\":\n        case \";5\":\n        case \";6\":\n        case \";7\":\n        case \";8\":\n        case \",1\":\n        case \",2\":\n        case \",3\":\n        case \",4\":\n        case \",5\":\n        case \",6\":\n        case \",7\":\n        case \",8\":\n          addNotation(new Signs.DominicanBar(parseInt(atom[1], 10)));\n          break;\n        case \":\":\n          addNotation(new Signs.FullBar(barWithCarryover));\n          break;\n        case \"::\":\n          addNotation(new Signs.DoubleBar());\n          break;\n        // other gregorio dividers are not supported yet\n\n        case \"c1\":\n        case \"c2\":\n        case \"c3\":\n        case \"c4\":\n        case \"c5\":\n          addNotation((ctxt.activeClef = new DoClef(2 * parseInt(atom[1], 10) - 1, 2)));\n          break;\n        case \"f1\":\n        case \"f2\":\n        case \"f3\":\n        case \"f4\":\n        case \"f5\":\n          addNotation((ctxt.activeClef = new FaClef(2 * parseInt(atom[1], 10) - 1, 2)));\n          break;\n        case \"treble1\":\n        case \"treble2\":\n        case \"treble3\":\n        case \"treble4\":\n        case \"treble5\":\n        case \"treble-1\":\n        case \"treble-2\":\n        case \"treble-3\":\n        case \"treble-4\":\n        case \"treble-5\":\n          addNotation((ctxt.activeClef = new TrebleClef(2 * parseInt(atom.slice(-1), 10) - 1, 2, null, atom[6] === '-')));\n          break;\n        case \"cb1\":\n        case \"cb2\":\n        case \"cb3\":\n        case \"cb4\":\n        case \"cb5\":\n          {\n            const line = 2 * parseInt(atom[2], 10) - 1;\n            addNotation(\n              (ctxt.activeClef = new DoClef(\n                line,\n                2,\n                new Signs.Accidental(line - 1, Signs.AccidentalType.Flat)\n              ))\n            );\n          }\n          break;\n\n        case \"z\":\n          addNotation(new ChantLineBreak(true));\n          break;\n        case \"Z\":\n          addNotation(new ChantLineBreak(false));\n          break;\n        case \"z0\":\n          addNotation(new Signs.Custos(true));\n          break;\n\n        // spacing indicators\n        case \"!\":\n          trailingSpace = 0;\n          addToLastSourceGabc(atom);\n          addNotation(null);\n          break;\n        case \" \":\n          // fixme: is this correct? logically what is the difference in gabc\n          // between putting a space between notes vs putting '//' between notes?\n          trailingSpace = TrailingSpaceMultiple(2);\n          addToLastSourceGabc(atom);\n          addNotation(null);\n          break;\n\n        default:\n          // might be a number of slashes, a custos, might be an accidental, or might be a note\n          if (atom[0] === \"/\") {\n            trailingSpace = TrailingSpaceMultiple(atom.length);\n            addToLastSourceGabc(atom);\n            addNotation(null);\n          } else if (atom.length > 1 && atom[1] === \"+\") {\n            // custos\n            var custos = new Signs.Custos();\n\n            custos.staffPosition = this.gabcHeightToExsurgeHeight(atom[0]);\n\n            addNotation(custos);\n          } else if (atom.length > 1 && /[xy#]/.test(atom[1])) {\n            var accidentalType;\n\n            switch (atom[1]) {\n              case \"y\":\n                accidentalType = Signs.AccidentalType.Natural;\n                break;\n              case \"#\":\n                accidentalType = Signs.AccidentalType.Sharp;\n                break;\n              default:\n                accidentalType = Signs.AccidentalType.Flat;\n                break;\n            }\n\n            var noteArray = [];\n            this.createNoteFromData(\n              ctxt,\n              ctxt.activeClef,\n              atom,\n              noteArray,\n              sourceIndex\n            );\n            var accidental = new Signs.Accidental(\n              noteArray[0].staffPosition,\n              accidentalType\n            );\n            accidental.pitch = this.gabcHeightToExsurgePitch(\n              ctxt.activeClef,\n              atom[0]\n            );\n            accidental.sourceIndex = sourceIndex;\n            accidental.sourceLength = sourceLength;\n            accidental.trailingSpace = TrailingSpaceForAccidental;\n\n            ctxt.activeClef.activeAccidental = accidental;\n\n            addNotation(accidental);\n          } else if (atom.length > 1 && atom[0] === \"{\") {\n            trailingSpace = 0;\n            addNotation(null);\n            let bracketedNotations = this.parseNotations(\n              ctxt,\n              match[__notationsRegex_group_insideBraces],\n              sourceIndex + 1\n            );\n            // Set the width of these notations to 0\n            bracketedNotations.forEach(neume => {\n              neume.hasNoWidth = true;\n              neume.firstWithNoWidth = bracketedNotations[0];\n            });\n            notations.push(...bracketedNotations);\n          } else {\n            // looks like it's a note\n            if (insertionIndex === -1) {\n              trailingSpace = TrailingSpaceMultiple(1);\n              addNotation(null);\n            }\n            this.createNoteFromData(\n              ctxt,\n              ctxt.activeClef,\n              atom,\n              notes,\n              sourceIndex\n            );\n            --insertionIndex;\n          }\n          break;\n      }\n    }\n\n    // finish up any remaining notes we have left\n    addNotation(null);\n\n    return notations;\n  }\n\n  static createNeumesFromNotes(ctxt, notes, finalTrailingSpace) {\n    var neumes = [];\n    var firstNoteIndex = 0;\n    var currNoteIndex = 0;\n\n    // here we use a simple finite state machine to create the neumes from the notes\n    // createNeume is helper function which returns the next state after a neume is created\n    // (unknownState). Each state object has a neume() function and a handle() function.\n    // neume() allows us to create the neume of the state in the event that we run out\n    // of notes. handle() gives the state an opportunity to examine the currNote and\n    // determine what to do...either transition to a different neume/state, or\n    // continue building the neume of that state. handle() returns the next state\n\n    var createNeume = function(neume, includeCurrNote, includePrevNote = true) {\n      // add the notes to the neume\n      var lastNoteIndex;\n      if (includeCurrNote) lastNoteIndex = currNoteIndex;\n      else if (includePrevNote) lastNoteIndex = currNoteIndex - 1;\n      else lastNoteIndex = currNoteIndex - 2;\n\n      if (lastNoteIndex < 0) return;\n\n      while (firstNoteIndex <= lastNoteIndex) {\n        let note = notes[firstNoteIndex++];\n        neume.addNote(note);\n        if (note.alText) {\n          if (!neume.alText) neume.alText = [];\n          neume.alText.push(note.alText);\n          note.alText.noteIndex = firstNoteIndex - 1;\n        }\n      }\n\n      neumes.push(neume);\n\n      if (includeCurrNote === false) {\n        currNoteIndex--;\n\n        if (includePrevNote === false) currNoteIndex--;\n\n        neume.keepWithNext = true;\n        if (notes[currNoteIndex + 1].shape === NoteShape.Quilisma)\n          neume.trailingSpace = 0;\n        else {\n          neume.trailingSpace = TrailingSpaceMultiple(1);\n          neume.allowLineBreakBeforeNext = true;\n        }\n      }\n\n      return unknownState;\n    };\n\n    var unknownState = {\n      neume: function() {\n        return new Neumes.Punctum();\n      },\n      handle: function(currNote, prevNote) {\n        if (currNote.shape === NoteShape.Virga) return virgaState;\n        else if (currNote.shape === NoteShape.Stropha) return apostrophaState;\n        else if (currNote.shape === NoteShape.Oriscus) return oriscusState;\n        else if (currNote.shape === NoteShape.Inclinatum)\n          return punctaInclinataState;\n        else if (currNote.shapeModifiers & NoteShapeModifiers.Cavum)\n          return createNeume(new Neumes.Punctum(), true);\n        else return punctumState;\n      }\n    };\n\n    var punctumState = {\n      neume: function() {\n        return new Neumes.Punctum();\n      },\n      handle: function(currNote, prevNote, notesRemaining) {\n        if (currNote.shape || prevNote.liquescent === LiquescentType.Small) {\n          var neume = new Neumes.Punctum();\n          var state = createNeume(neume, false);\n          // if the current note is on a space within the staff AND the previous note is on the line below AND the previous note has a mora,\n          // then we went the trailing space at its default of intraNeumeSpacing to prevent the dot from running up into the current note.\n          // Otherwise, we want no trailing space.\n          if (\n            currNote.staffPosition > prevNote.staffPosition &&\n            (currNote.staffPosition % 2 === 1 ||\n              prevNote.staffPosition !== currNote.staffPosition - 1 ||\n              !prevNote.morae ||\n              prevNote.morae.length === 0)\n          )\n            neume.trailingSpace = 0;\n          return state;\n        }\n\n        if (currNote.staffPosition > prevNote.staffPosition) {\n          if (currNote.ictus)\n            currNote.ictus.positionHint = MarkingPositionHint.Above;\n          return podatusState;\n        } else if (currNote.staffPosition < prevNote.staffPosition) {\n          if (prevNote.ictus)\n            prevNote.ictus.positionHint = MarkingPositionHint.Above;\n          if (currNote.shape === NoteShape.Inclinatum) return climacusState;\n          else {\n            return clivisState;\n          }\n        } else if (!prevNote.morae || !prevNote.morae.length) {\n          return distrophaState;\n        }\n        return createNeume(new Neumes.Punctum(), false);\n      }\n    };\n\n    var punctaInclinataState = {\n      neume: function() {\n        return new Neumes.PunctaInclinata();\n      },\n      handle: function() {\n        if (currNote.shape !== NoteShape.Inclinatum)\n          return createNeume(new Neumes.PunctaInclinata(), false);\n        else return punctaInclinataState;\n      }\n    };\n\n    var oriscusState = {\n      neume: function() {\n        return new Neumes.Oriscus();\n      },\n      handle: function(currNote, prevNote) {\n        if (currNote.shape === NoteShape.Default) {\n          if (currNote.staffPosition > prevNote.staffPosition) {\n            prevNote.shapeModifiers |= NoteShapeModifiers.Ascending;\n            return createNeume(new Neumes.PesQuassus(), true);\n          } else if (currNote.staffPosition < prevNote.staffPosition) {\n            prevNote.shapeModifiers |= NoteShapeModifiers.Descending;\n            return createNeume(new Neumes.Clivis(), true);\n          }\n        }\n        // stand alone oriscus\n        var neume = new Neumes.Oriscus(),\n          state = createNeume(neume, false);\n        // if the current note is on a space within the staff AND the previous note is on the line below AND the previous note has a mora,\n        // then we went the trailing space at its default of intraNeumeSpacing to prevent the dot from running up into the current note.\n        // Otherwise, we want no trailing space.\n        if (\n          currNote.staffPosition > prevNote.staffPosition &&\n          (currNote.staffPosition % 2 === 1 ||\n            prevNote.staffPosition !== currNote.staffPosition - 1 ||\n            !prevNote.morae ||\n            prevNote.morae.length === 0)\n        )\n          neume.trailingSpace = 0;\n        return state;\n      }\n    };\n\n    var podatusState = {\n      neume: function() {\n        return new Neumes.Podatus();\n      },\n      handle: function(currNote, prevNote) {\n        if (currNote.staffPosition > prevNote.staffPosition) {\n          if (currNote.ictus)\n            currNote.ictus.positionHint = MarkingPositionHint.Above;\n          if (prevNote.ictus)\n            prevNote.ictus.positionHint = MarkingPositionHint.Below;\n\n          if (prevNote.shape === NoteShape.Oriscus) return salicusState;\n          else return scandicusState;\n        } else if (currNote.staffPosition < prevNote.staffPosition) {\n          if (currNote.shape === NoteShape.Inclinatum)\n            return pesSubpunctisState;\n          else return torculusState;\n        } else return createNeume(new Neumes.Podatus(), false);\n      }\n    };\n\n    var clivisState = {\n      neume: function() {\n        return new Neumes.Clivis();\n      },\n      handle: function(currNote, prevNote) {\n        if (\n          currNote.shape === NoteShape.Default &&\n          currNote.staffPosition > prevNote.staffPosition\n        ) {\n          if (currNote.ictus)\n            currNote.ictus.positionHint = MarkingPositionHint.Above;\n          return porrectusState;\n        } else if (\n          currNote.staffPosition < prevNote.staffPosition &&\n          currNote.liquescent & LiquescentType.Small\n        ) {\n          return createNeume(new Neumes.Ancus(), true);\n        } else {\n          return createNeume(new Neumes.Clivis(), false);\n        }\n      }\n    };\n\n    var climacusState = {\n      neume: function() {\n        return new Neumes.Climacus();\n      },\n      handle: function(currNote, prevNote) {\n        if (currNote.shape !== NoteShape.Inclinatum)\n          return createNeume(new Neumes.Climacus(), false);\n        else return state;\n      }\n    };\n\n    var porrectusState = {\n      neume: function() {\n        return new Neumes.Porrectus();\n      },\n      handle: function(currNote, prevNote) {\n        if (\n          currNote.shape === NoteShape.Default &&\n          currNote.staffPosition < prevNote.staffPosition\n        )\n          return createNeume(new Neumes.PorrectusFlexus(), true);\n        else return createNeume(new Neumes.Porrectus(), false);\n      }\n    };\n\n    var pesSubpunctisState = {\n      neume: function() {\n        return new Neumes.PesSubpunctis();\n      },\n      handle: function(currNote, prevNote) {\n        if (currNote.shape !== NoteShape.Inclinatum)\n          return createNeume(new Neumes.PesSubpunctis(), false);\n        else return state;\n      }\n    };\n\n    var salicusState = {\n      neume: function() {\n        return new Neumes.Salicus();\n      },\n      handle: function(currNote, prevNote) {\n        if (currNote.staffPosition < prevNote.staffPosition)\n          return salicusFlexusState;\n        else return createNeume(new Neumes.Salicus(), false);\n      }\n    };\n\n    var salicusFlexusState = {\n      neume: function() {\n        return new Neumes.SalicusFlexus();\n      },\n      handle: function(currNote, prevNote) {\n        return createNeume(new Neumes.SalicusFlexus(), false);\n      }\n    };\n\n    var scandicusState = {\n      neume: function() {\n        return new Neumes.Scandicus();\n      },\n      handle: function(currNote, prevNote) {\n        if (\n          prevNote.shape === NoteShape.Virga &&\n          currNote.shape === NoteShape.Inclinatum &&\n          currNote.staffPosition < prevNote.staffPosition\n        ) {\n          // if we get here, then it seems we have a podatus, now being followed by a climacus\n          // rather than a scandicus. react accordingly\n          return createNeume(new Neumes.Podatus(), false, false);\n        } else if (\n          currNote.shape === NoteShape.Default &&\n          currNote.staffPosition < prevNote.staffPosition\n        )\n          return scandicusFlexusState;\n        else return createNeume(new Neumes.Scandicus(), false);\n      }\n    };\n\n    var scandicusFlexusState = {\n      neume: function() {\n        return new Neumes.ScandicusFlexus();\n      },\n      handle: function(currNote, prevNote) {\n        return createNeume(new Neumes.ScandicusFlexus(), false);\n      }\n    };\n\n    var virgaState = {\n      neume: function() {\n        return new Neumes.Virga();\n      },\n      handle: function(currNote, prevNote) {\n        if (\n          currNote.shape === NoteShape.Inclinatum &&\n          currNote.staffPosition < prevNote.staffPosition\n        )\n          return climacusState;\n        else if (\n          currNote.shape === NoteShape.Virga &&\n          currNote.staffPosition === prevNote.staffPosition\n        )\n          return bivirgaState;\n        else return createNeume(new Neumes.Virga(), false);\n      }\n    };\n\n    var bivirgaState = {\n      neume: function() {\n        return new Neumes.Bivirga();\n      },\n      handle: function(currNote, prevNote) {\n        if (\n          currNote.shape === NoteShape.Virga &&\n          currNote.staffPosition === prevNote.staffPosition\n        )\n          return createNeume(new Neumes.Trivirga(), true);\n        else return createNeume(new Neumes.Bivirga(), false);\n      }\n    };\n\n    var apostrophaState = {\n      neume: function() {\n        return new Neumes.Apostropha();\n      },\n      handle: function(currNote, prevNote) {\n        if (currNote.staffPosition === prevNote.staffPosition)\n          return distrophaState;\n        else return createNeume(new Neumes.Apostropha(), false);\n      }\n    };\n\n    var distrophaState = {\n      neume: function() {\n        return new Neumes.Distropha();\n      },\n      handle: function(currNote, prevNote) {\n        if (currNote.staffPosition === prevNote.staffPosition) {\n          if (prevNote.morae && prevNote.morae.length) {\n            return createNeume(new Neumes.Distropha(), false);\n          } else {\n            return tristrophaState;\n          }\n        } else return createNeume(new Neumes.Apostropha(), false, false);\n      }\n    };\n\n    var tristrophaState = {\n      neume: function() {\n        return new Neumes.Tristropha();\n      },\n      handle: function(currNote, prevNote) {\n        // we only create a tristropha when the note run ends after three\n        // and the neume() function of this state is called. Otherwise\n        // we always interpret the third note to belong to the next sequence\n        // of notes.\n        //\n        // fixme: gabc allows any number of punctum/stropha in succession...\n        // is this a valid neume type? Or is it just multiple *stropha neumes\n        // in succession? Should we simplify the apostropha/distropha/\n        // tristropha classes to a generic stropha neume that can have 1 or\n        // more successive notes?\n        return createNeume(new Neumes.Distropha(), false, false);\n      }\n    };\n\n    var torculusState = {\n      neume: function() {\n        return new Neumes.Torculus();\n      },\n      handle: function(currNote, prevNote) {\n        if (\n          currNote.shape === NoteShape.Default &&\n          currNote.staffPosition > prevNote.staffPosition\n        ) {\n          let prevNoteButOne = notes[currNoteIndex - 2];\n          if (\n            prevNoteButOne &&\n            prevNoteButOne.staffPosition - prevNote.staffPosition <= 4\n          ) {\n            if (currNote.ictus)\n              currNote.ictus.positionHint = MarkingPositionHint.Above;\n            return torculusResupinusState;\n          }\n        }\n        return createNeume(new Neumes.Torculus(), false);\n      }\n    };\n\n    var torculusResupinusState = {\n      neume: function() {\n        return new Neumes.TorculusResupinus();\n      },\n      handle: function(currNote, prevNote) {\n        if (\n          currNote.shape === NoteShape.Default &&\n          currNote.staffPosition < prevNote.staffPosition\n        )\n          return createNeume(new Neumes.TorculusResupinusFlexus(), true);\n        else return createNeume(new Neumes.TorculusResupinus(), false);\n      }\n    };\n\n    var state = unknownState;\n\n    while (currNoteIndex < notes.length) {\n      var prevNote = currNoteIndex > 0 ? notes[currNoteIndex - 1] : null;\n      var currNote = notes[currNoteIndex];\n\n      state = state.handle(\n        currNote,\n        prevNote,\n        notes.length - 1 - currNoteIndex\n      );\n\n      // if we are on the last note, then try to create a neume if we need to.\n      if (currNoteIndex === notes.length - 1 && state !== unknownState)\n        createNeume(state.neume(), true);\n\n      currNoteIndex++;\n    }\n\n    if (neumes.length > 0) {\n      if (!finalTrailingSpace.isDefault) {\n        neumes[neumes.length - 1].trailingSpace = finalTrailingSpace;\n        neumes[neumes.length - 1].keepWithNext = true;\n\n        if (finalTrailingSpace > 0)\n          neumes[neumes.length - 1].allowLineBreakBeforeNext = neumes[\n            neumes.length - 1\n          ].keepWithNext = true;\n      }\n    }\n\n    return neumes;\n  }\n\n  // appends any notes created to the notes array argument\n  static createNoteFromData(ctxt, clef, data, notes, sourceIndex) {\n    var note = new Note();\n    note.sourceIndex = sourceIndex;\n    note.sourceGabc = data;\n\n    if (data.length < 1) throw \"Invalid note data: \" + data;\n\n    if (data[0] === \"-\") {\n      // liquescent initio debilis\n      note.liquescent = LiquescentType.InitioDebilis;\n      data = data.substring(1);\n    }\n\n    if (data.length < 1) throw \"Invalid note data: \" + data;\n\n    // the next char is always the pitch\n    var pitch = this.gabcHeightToExsurgePitch(clef, data[0]);\n\n    if (data[0] === data[0].toUpperCase()) note.shape = NoteShape.Inclinatum;\n\n    note.staffPosition = this.gabcHeightToExsurgeHeight(data[0]);\n    note.pitch = pitch;\n\n    var mark;\n\n    var episemaNoteIndex = notes.length;\n    var episemaNote = note;\n\n    // process the modifiers\n    for (var i = 1; i < data.length; i++) {\n      var c = data[i];\n      var lookahead = \"\\0\";\n\n      var haveLookahead = i + 1 < data.length;\n      if (haveLookahead) lookahead = data[i + 1];\n\n      switch (c) {\n        // rhythmic markings\n        case \".\":\n          mark = null;\n\n          // gabc supports putting up to two morae on each note, by repeating the\n          // period. here, we check to see if we've already created a mora for the\n          // note, and if so, we simply force the second one to have an Above\n          // position hint. if a user decides to try to put position indicators\n          // on the double morae (such as 1 or 2), then really the behavior is\n          // not defined by gabc, so it's on the user to figure it out.\n          if (note.morae.length > 0 && notes.length) {\n            var previousNote = notes.slice(-1)[0];\n            var previousMora = note.morae.slice(-1)[0];\n            previousMora.note = previousNote;\n          }\n\n          mark = new Markings.Mora(ctxt, note);\n          if (haveLookahead && lookahead === \"1\")\n            mark.positionHint = MarkingPositionHint.Above;\n          else if (haveLookahead && lookahead === \"0\")\n            mark.positionHint = MarkingPositionHint.Below;\n\n          note.morae.push(mark);\n          break;\n\n        case \"_\":\n          var episemaHadModifier = false;\n\n          mark = new Markings.HorizontalEpisema(episemaNote);\n          while (haveLookahead) {\n            if (lookahead === \"0\")\n              mark.positionHint = MarkingPositionHint.Below;\n            else if (lookahead === \"1\")\n              mark.positionHint = MarkingPositionHint.Above;\n            else if (lookahead === \"2\") mark.terminating = true;\n            // episema terminates\n            else if (lookahead === \"3\")\n              mark.alignment = Markings.HorizontalEpisemaAlignment.Left;\n            else if (lookahead === \"4\")\n              mark.alignment = Markings.HorizontalEpisemaAlignment.Center;\n            else if (lookahead === \"5\")\n              mark.alignment = Markings.HorizontalEpisemaAlignment.Right;\n            else break;\n\n            // the gabc definition for episemata is so convoluted...\n            // - double underscores create episemata over multiple notes.\n            // - unless the _ has a 0, 1, 3, 4, or 5 modifier, which means\n            //   another underscore puts a second episema on the same note\n            // - (when there's a 2 lookahead, then this is treated as an\n            //   unmodified underscore, so another underscore would be\n            //   added to previous notes\n            if (\n              mark.alignment !== Markings.HorizontalEpisemaAlignment.Default &&\n              mark.positionHint !== MarkingPositionHint.Below\n            )\n              episemaHadModifier = true;\n\n            i++;\n            haveLookahead = i + 1 < data.length;\n\n            if (haveLookahead) lookahead = data[i + 1];\n          }\n\n          // since gabc allows consecutive underscores which is a shortcut to\n          // apply the episemata to previous notes, we keep track of that here\n          // in order to add the new episema to the correct note.\n\n          if (episemaNote) episemaNote.episemata.push(mark);\n\n          if (episemaNote === note && episemaHadModifier) episemaNote = note;\n          else if (episemaNoteIndex >= 0 && notes.length > 0)\n            episemaNote = notes[--episemaNoteIndex];\n\n          break;\n\n        case \"'\":\n          mark = new Markings.Ictus(ctxt, note);\n          if (haveLookahead && lookahead === \"1\")\n            mark.positionHint = MarkingPositionHint.Above;\n          else if (haveLookahead && lookahead === \"0\")\n            mark.positionHint = MarkingPositionHint.Below;\n          else if (note.shape === NoteShape.Virga)\n            // ictus on a virga goes above by default:\n            mark.positionHint = MarkingPositionHint.Above;\n\n          note.ictus = mark;\n          break;\n\n        //note shapes\n        case \"r\":\n          if (haveLookahead && /^[0-5]$/.test(lookahead)) {\n            switch (lookahead) {\n              case \"0\":\n                note.shapeModifiers |= NoteShapeModifiers.Cavum;\n                note.shapeModifiers |= NoteShapeModifiers.Linea;\n                break;\n              case \"1\":\n                note.accent = new Markings.Accent(\n                  ctxt,\n                  note,\n                  GlyphCode.AcuteAccent\n                );\n                break;\n              case \"2\":\n                note.accent = new Markings.Accent(\n                  ctxt,\n                  note,\n                  GlyphCode.GraveAccent\n                );\n                break;\n              case \"3\":\n                note.accent = new Markings.Accent(ctxt, note, GlyphCode.Circle);\n                break;\n              case \"4\":\n                note.accent = new Markings.Accent(\n                  ctxt,\n                  note,\n                  GlyphCode.Semicircle\n                );\n                break;\n              case \"5\":\n                note.accent = new Markings.Accent(\n                  ctxt,\n                  note,\n                  GlyphCode.ReversedSemicircle\n                );\n                break;\n              default:\n            }\n            i++;\n          } else note.shapeModifiers |= NoteShapeModifiers.Cavum;\n          break;\n        \n        case \"R\":\n          note.shapeModifiers |= NoteShapeModifiers.Linea;\n          break;\n\n        case \"s\":\n          if (note.shape === NoteShape.Stropha) {\n            // if we're already a stropha, that means this is gabc's\n            // quick stropha feature (e.g., gsss). create a new note\n            let newNote = new Note();\n            newNote.sourceIndex = sourceIndex + i;\n            newNote.sourceGabc = \"s\";\n            newNote.staffPosition = note.staffPosition;\n            newNote.pitch = note.pitch;\n            notes.push(note);\n            note = newNote;\n            episemaNoteIndex++; // since a new note was added, increase the index here\n          }\n\n          note.shape = NoteShape.Stropha;\n          break;\n\n        case \"v\":\n          if (note.shape === NoteShape.Virga) {\n            // if we're already a stropha, that means this is gabc's\n            // quick virga feature (e.g., gvvv). create a new note\n            let newNote = new Note();\n            newNote.sourceIndex = sourceIndex + i;\n            newNote.sourceGabc = \"v\";\n            newNote.staffPosition = note.staffPosition;\n            newNote.pitch = note.pitch;\n            notes.push(note);\n            note = newNote;\n            episemaNoteIndex++; // since a new note was added, increase the index here\n          }\n\n          note.shape = NoteShape.Virga;\n          break;\n        \n        case \"V\":\n          note.shape = NoteShape.Virga;\n          note.shapeModifers |= NoteShapeModifiers.Reverse;\n          break;\n\n        case \"w\":\n          note.shape = NoteShape.Quilisma;\n          break;\n\n        case \"o\":\n          note.shape = NoteShape.Oriscus;\n          if (haveLookahead && lookahead === \"<\") {\n            note.shapeModifiers |= NoteShapeModifiers.Ascending;\n            i++;\n          } else if (haveLookahead && lookahead === \">\") {\n            note.shapeModifiers |= NoteShapeModifiers.Descending;\n            i++;\n          }\n          break;\n\n        case \"O\":\n          note.shape = NoteShape.Oriscus;\n          if (haveLookahead && lookahead === \"<\") {\n            note.shapeModifiers |=\n              NoteShapeModifiers.Ascending | NoteShapeModifiers.Stemmed;\n            i++;\n          } else if (haveLookahead && lookahead === \">\") {\n            note.shapeModifiers |=\n              NoteShapeModifiers.Descending | NoteShapeModifiers.Stemmed;\n            i++;\n          } else note.shapeModifiers |= NoteShapeModifiers.Stemmed;\n          break;\n\n        // liquescents\n        case \"~\":\n          if (note.shape === NoteShape.Inclinatum)\n            note.liquescent |= LiquescentType.Small;\n          else if (note.shape === NoteShape.Oriscus)\n            note.liquescent |= LiquescentType.Large;\n          else note.liquescent |= LiquescentType.Small;\n          break;\n        case \"<\":\n          note.liquescent |= LiquescentType.Ascending;\n          break;\n        case \">\":\n          note.liquescent |= LiquescentType.Descending;\n          break;\n\n        // accidentals\n        case \"x\":\n          if (note.pitch.step === Step.Mi) note.pitch.step = Step.Me;\n          else if (note.pitch.step === Step.Ti) note.pitch.step = Step.Te;\n          break;\n        case \"y\":\n          if (note.pitch.step === Step.Te) note.pitch.step = Step.Ti;\n          else if (note.pitch.step === Step.Me) note.pitch.step = Step.Mi;\n          else if (note.pitch.step === Step.Du) note.pitch.step = Step.Do;\n          else if (note.pitch.step === Step.Fu) note.pitch.step = Step.Fa;\n          break;\n        case \"#\":\n          if (note.pitch.step === Step.Do) note.pitch.step = Step.Du;\n          else if (note.pitch.step === Step.Fa) note.pitch.step = Step.Fu;\n          break;\n\n        // gabc special item groups\n        case \"[\":\n          // read in the whole group and parse it\n          var startIndex = ++i;\n          while (i < data.length && data[i] !== \"]\") i++;\n\n          this.processInstructionForNote(\n            ctxt,\n            note,\n            data.substring(startIndex, i),\n            startIndex\n          );\n          break;\n      }\n    }\n\n    if (\n      this.needToEndBrace &&\n      !note.braceStart &&\n      !note.braceEnd &&\n      !/[xy#]/.test(c)\n    ) {\n      note.braceEnd = new Markings.BracePoint(\n        note,\n        this.needToEndBrace.isAbove,\n        this.needToEndBrace.shape,\n        this.needToEndBrace.attachment === Markings.BraceAttachment.Left\n          ? Markings.BraceAttachment.Right\n          : Markings.BraceAttachment.Left\n      );\n      note.braceEnd.automatic = true;\n      delete this.needToEndBrace;\n    }\n\n    notes.push(note);\n  }\n\n  // an instruction in this context is referring to a special gabc coding found after\n  // notes between ['s and ]'s. choral signs and braces fall into this\n  // category.\n  //\n  // currently only brace instructions are supported here!\n  static processInstructionForNote(ctxt, note, instruction, sourceIndexOffset) {\n    var results = instruction.match(__bracketedCommandRegex);\n    if (results === null) return;\n    var cmd = results[1];\n    var data = results[2];\n    switch (cmd) {\n      case \"cs\":\n        note.choralSign = new ChoralSign(\n          ctxt,\n          data,\n          note,\n          note.sourceIndex + sourceIndexOffset,\n          instruction.length\n        );\n        return;\n      case \"alt\":\n        note.alText = new AboveLinesText(\n          ctxt,\n          data,\n          note,\n          note.sourceIndex + sourceIndexOffset,\n          instruction.length\n        );\n        return;\n    }\n\n    results = instruction.match(__braceSpecRegex);\n\n    if (results === null) return;\n\n    // see the comments at the definition of __braceSpecRegex for the\n    // capturing groups\n    var above = results[1] === \"o\";\n    var shape = Markings.BraceShape.CurlyBrace; // default\n\n    switch (results[2]) {\n      case \"b\":\n        shape = Markings.BraceShape.RoundBrace;\n        break;\n      case \"cb\":\n        shape = Markings.BraceShape.CurlyBrace;\n        break;\n      case \"cba\":\n        shape = Markings.BraceShape.AccentedCurlyBrace;\n        break;\n    }\n\n    var attachmentPoint =\n      results[3] === \"1\"\n        ? Markings.BraceAttachment.Left\n        : Markings.BraceAttachment.Right;\n\n    if (results[4] === \"{\" || results[5])\n      note.braceStart = new Markings.BracePoint(\n        note,\n        above,\n        shape,\n        attachmentPoint\n      );\n    else\n      note.braceEnd = new Markings.BracePoint(\n        note,\n        above,\n        shape,\n        attachmentPoint\n      );\n\n    // just have the next note end a brace that uses length;\n    if (results[5]) {\n      note.braceStart.automatic = true;\n      this.needToEndBrace = note.braceStart;\n    }\n  }\n\n  // takes raw gabc text source and parses it into words. For example, passing\n  // in a string of \"me(f.) (,) ma(fff)num(d!ewf) tu(fgF'E)am,(f.)\" would return\n  // an array of four strings: [\"me(f.)\", \"(,)\", \"ma(fff)num(d!ewf)\", \"tu(fgF'E)am,(f.)\"]\n  static splitWords(gabcNotations) {\n    // split the notations on whitespace boundaries, as long as the space\n    // immediately follows a set of parentheses. Prior to doing that, we replace\n    // all whitespace with spaces, which prevents tabs and newlines from ending\n    // up in the notation data.\n    gabcNotations = gabcNotations\n      // .trim()\n      // .replace(/\\s/g, \" \")\n      .replace(/\\)\\s(?=[^\\)]*(?:\\(|$))/g, \")\\n\");\n    return gabcNotations.split(/\\n/g);\n  }\n\n  static parseSource(gabcSource) {\n    return this.parseWords(this.splitWords(gabcSource));\n  }\n\n  // gabcWords is an array of strings, e.g., the result of splitWords above\n  static parseWords(gabcWords) {\n    var words = [];\n\n    for (var i = 0; i < gabcWords.length; i++)\n      words.push(this.parseWord(gabcWords[i]));\n\n    return words;\n  }\n\n  // returns an array of objects, each of which has the following properties\n  //  - notations (string)\n  //  - lyrics (array of strings)\n  static parseWord(gabcWord) {\n    var syllables = [];\n    var matches = [];\n\n    syllables.wordLength = gabcWord.length;\n\n    while ((match = __syllablesRegex.exec(gabcWord))) matches.push(match);\n\n    for (var j = 0; j < matches.length; j++) {\n      var match = matches[j];\n\n      var lyrics = match[1].trim().split(\"|\");\n      var notations = match[2];\n\n      syllables.push({\n        notations: notations,\n        lyrics: lyrics\n      });\n    }\n\n    return syllables;\n  }\n\n  // returns pitch\n  static gabcHeightToExsurgeHeight(gabcHeight) {\n    return gabcHeight.toLowerCase().charCodeAt(0) - \"c\".charCodeAt(0);\n  }\n\n  // returns pitch\n  static gabcHeightToExsurgePitch(clef, gabcHeight) {\n    var exsurgeHeight = this.gabcHeightToExsurgeHeight(gabcHeight);\n\n    var pitch = clef.staffPositionToPitch(exsurgeHeight);\n\n    return pitch;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Exsurge.Gabc.js","//\n// Author(s):\n// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>\n//\n// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n//\n\nimport {\n  LiquescentType,\n  NoteShape,\n  NoteShapeModifiers\n} from \"./Exsurge.Chant.js\";\nimport {\n  ChantNotationElement,\n  GlyphCode, LineaVisualizer, MarkingPositionHint,\n  NeumeLineVisualizer, VirgaLineVisualizer\n} from \"./Exsurge.Drawing.js\";\nimport { Glyphs } from \"./Exsurge.Glyphs.js\";\n\nclass NeumeBuilder {\n  constructor(ctxt, neume, startingX = 0) {\n    this.ctxt = ctxt;\n    this.neume = neume;\n    this.x = startingX;\n    this.lastNote = null;\n    this.lineIsHanging = false;\n    this.minX = 0;\n  }\n\n  // used to start a hanging line on the left of the next note\n  lineFrom(note) {\n    var previousNotation = this.ctxt.notations[this.ctxt.currNotationIndex - 1];\n    if (\n      this.x === 0 &&\n      previousNotation &&\n      previousNotation.notes &&\n      previousNotation.trailingSpace === 0\n    ) {\n      this.lastNote = previousNotation.notes.slice(-1)[0];\n      this.minX = -this.ctxt.neumeLineWeight;\n    } else {\n      this.lastNote = note;\n      this.lineIsHanging = true;\n    }\n    return this;\n  }\n\n  // add a note, with a connecting line on the left if we have one\n  noteAt(note, glyph, withLineTo = true) {\n    if (!note) throw \"NeumeBuilder.noteAt: note must be a valid note\";\n\n    if (!glyph) throw \"NeumeBuilder.noteAt: glyph must be a valid glyph code\";\n\n    note.setGlyph(this.ctxt, glyph);\n    var noteAlignsRight = note.glyphVisualizer.align === \"right\";\n\n    var needsLine =\n      withLineTo &&\n      this.lastNote !== null &&\n      (this.lineIsHanging ||\n        (this.lastNote.glyphVisualizer &&\n          this.lastNote.glyphVisualizer.align === \"right\") ||\n        Math.abs(this.lastNote.staffPosition - note.staffPosition) > 1);\n\n    if (needsLine) {\n      var line = new NeumeLineVisualizer(\n        this.ctxt,\n        this.lastNote,\n        note,\n        this.lineIsHanging\n      );\n      this.neume.addVisualizer(line);\n      line.bounds.x = Math.max(this.minX, this.x - line.bounds.width);\n\n      if (!noteAlignsRight) this.x = line.bounds.x;\n    }\n    \n    let xOffset = 0;\n    if (note.shapeModifiers & NoteShapeModifiers.Linea) {\n      var linea = new LineaVisualizer(\n        this.ctxt,\n        note\n      );\n      this.neume.addVisualizer(linea);\n      note.origin.x += linea.origin.x;\n      xOffset = linea.origin.x;\n    }\n\n    // if this is the first note of a right aligned glyph (probably an initio debilis),\n    // then there's nothing to worry about. but if it's not then first, then this\n    // subtraction will right align it visually\n    if (noteAlignsRight && this.lastNote)\n      note.bounds.x = this.x - note.bounds.width;\n    else {\n      note.bounds.x = this.x + xOffset;\n      this.x += note.bounds.width + xOffset;\n    }\n\n    this.neume.addVisualizer(note);\n\n    this.lastNote = note;\n    this.lineIsHanging = false;\n\n    return this;\n  }\n\n  // a special form of noteAdd that creates a virga\n  // uses a punctum cuadratum and a line rather than the virga glyphs\n  virgaAt(note, withLineTo = true) {\n    // add the punctum for the virga\n    this.noteAt(note, GlyphCode.PunctumQuadratum);\n\n    // add a line for the virga\n    var line = new VirgaLineVisualizer(this.ctxt, note);\n    this.x -= line.bounds.width;\n    if (note.shapeModifers & NoteShapeModifiers.Reverse) {\n      line.bounds.x = 0;\n    } else {\n      line.bounds.x = this.x;\n    }\n    this.neume.addVisualizer(line);\n\n    this.lastNote = note;\n    this.lineIsHanging = false;\n\n    return this;\n  }\n\n  advanceBy(x) {\n    this.lastNote = null;\n    this.lineIsHanging = false;\n\n    this.x += x;\n\n    return this;\n  }\n\n  // for terminating hanging lines with no lower notes\n  withLineEndingAt(note) {\n    if (this.lastNote === null) return;\n\n    var line = new NeumeLineVisualizer(this.ctxt, this.lastNote, note, true);\n    this.neume.addVisualizer(line);\n    this.x -= line.bounds.width;\n    line.bounds.x = this.x;\n\n    this.neume.addVisualizer(line);\n\n    this.lastNote = note;\n\n    return this;\n  }\n\n  withPodatus(lowerNote, upperNote) {\n    var upperGlyph;\n    var lowerGlyph;\n\n    if (lowerNote.liquescent === LiquescentType.InitioDebilis) {\n      // liquescent upper note or not?\n      if (upperNote.liquescent === LiquescentType.None)\n        upperGlyph = GlyphCode.PunctumQuadratum;\n      else upperGlyph = GlyphCode.PunctumQuadratumDesLiquescent;\n\n      lowerGlyph = GlyphCode.TerminatingDesLiquescent;\n    } else if (upperNote.liquescent & LiquescentType.Small) {\n      lowerGlyph = GlyphCode.BeginningAscLiquescent;\n      upperGlyph = GlyphCode.TerminatingAscLiquescent;\n    } else if (upperNote.liquescent & LiquescentType.Ascending) {\n      lowerGlyph = GlyphCode.PunctumQuadratum;\n      upperGlyph = GlyphCode.PunctumQuadratumAscLiquescent;\n    } else if (upperNote.liquescent & LiquescentType.Descending) {\n      lowerGlyph = GlyphCode.PunctumQuadratum;\n      upperGlyph = GlyphCode.PunctumQuadratumDesLiquescent;\n    } else {\n      // standard shape\n      lowerGlyph = GlyphCode.PodatusLower;\n      upperGlyph = GlyphCode.PodatusUpper;\n    }\n\n    // allow a quilisma pes\n    if (lowerNote.shape === NoteShape.Quilisma) lowerGlyph = GlyphCode.Quilisma;\n\n    this.noteAt(lowerNote, lowerGlyph).noteAt(upperNote, upperGlyph);\n\n    // make sure we don't have lines connected to the podatus\n    this.lastNote = null;\n\n    return this;\n  }\n\n  withClivisUpper(upper, lower, glyph = GlyphCode.PunctumQuadratum) {\n    if (upper.shape === NoteShape.Oriscus)\n      this.noteAt(upper, GlyphCode.OriscusDes, false);\n    else {\n      if (lower) {\n        this.lineFrom(lower);\n        this.lineIsHanging = lower.staffPosition < upper.staffPosition;\n        if (lower.liquescent & LiquescentType.Small) {\n          glyph = GlyphCode.BeginningDesLiquescent;\n        }\n      }\n      this.noteAt(upper, glyph);\n    }\n    return this;\n  }\n\n  withClivisLower(lower) {\n    var lowerGlyph;\n    if (lower.liquescent & LiquescentType.Small) {\n      lowerGlyph = GlyphCode.TerminatingDesLiquescent;\n    } else if (lower.liquescent === LiquescentType.Ascending)\n      lowerGlyph = GlyphCode.PunctumQuadratumAscLiquescent;\n    else if (lower.liquescent === LiquescentType.Descending)\n      lowerGlyph = GlyphCode.PunctumQuadratumDesLiquescent;\n    else lowerGlyph = GlyphCode.PunctumQuadratum;\n\n    return this.noteAt(lower, lowerGlyph);\n  }\n\n  withClivis(upper, lower) {\n    this.withClivisUpper(upper, lower);\n    this.withClivisLower(lower);\n\n    // make sure we don't have lines connected to the clivis\n    this.lastNote = null;\n\n    return this;\n  }\n\n  // lays out a sequence of notes that are inclinata (e.g., climacus, pes subpunctis)\n  withInclinata(notes) {\n    var staffPosition = notes[0].staffPosition,\n      prevStaffPosition = notes[0].staffPosition;\n\n    // it is important to advance by the width of the inclinatum glyph itself\n    // rather than by individual note widths, so that any liquescents are spaced\n    // the same as non-liquscents\n    var advanceWidth =\n      Glyphs.PunctumInclinatum.bounds.width * this.ctxt.glyphScaling;\n\n    // now add all the punctum inclinatum\n    for (var i = 0; i < notes.length; i++, prevStaffPosition = staffPosition) {\n      var note = notes[i];\n\n      if (note.liquescent & LiquescentType.Small)\n        note.setGlyph(this.ctxt, GlyphCode.PunctumInclinatumLiquescent);\n      else if (note.liquescent & LiquescentType.Large)\n        // fixme: is the large inclinatum liquescent the same as the apostropha?\n        note.setGlyph(this.ctxt, GlyphCode.Stropha);\n      // fixme: some climaci in the new chant books end with a punctum quadratum\n      // (see, for example, the antiphon \"Sancta Maria\" for October 7).\n      else note.setGlyph(this.ctxt, GlyphCode.PunctumInclinatum);\n\n      staffPosition = note.staffPosition;\n\n      var multiple = Math.abs(prevStaffPosition - staffPosition);\n      switch (multiple) {\n        case 0:\n          multiple = 1.1;\n          break;\n        default:\n          multiple *= 2 / 3;\n          break;\n      }\n\n      if (i > 0) this.x += advanceWidth * multiple;\n\n      note.bounds.x = this.x;\n\n      this.neume.addVisualizer(note);\n    }\n\n    return this;\n  }\n\n  withPorrectusSwash(start, end) {\n    var needsLine =\n      this.lastNote !== null &&\n      (this.lineIsHanging ||\n        (this.lastNote.glyphVisualizer &&\n          this.lastNote.glyphVisualizer.align === \"right\") ||\n        Math.abs(this.lastNote.staffPosition - start.staffPosition) > 1);\n\n    if (needsLine) {\n      var line = new NeumeLineVisualizer(\n        this.ctxt,\n        this.lastNote,\n        start,\n        this.lineIsHanging\n      );\n      this.x = Math.max(this.minX, this.x - line.bounds.width);\n      line.bounds.x = this.x;\n      this.neume.addVisualizer(line);\n    }\n\n    var glyph;\n\n    switch (start.staffPosition - end.staffPosition) {\n      case 1:\n        glyph = GlyphCode.Porrectus1;\n        break;\n      case 2:\n        glyph = GlyphCode.Porrectus2;\n        break;\n      case 3:\n        glyph = GlyphCode.Porrectus3;\n        break;\n      case 4:\n        glyph = GlyphCode.Porrectus4;\n        break;\n      default:\n        // fixme: should we generate an error here?\n        glyph = GlyphCode.None;\n        break;\n    }\n\n    start.setGlyph(this.ctxt, glyph);\n    start.bounds.x = this.x;\n\n    // the second glyph does not draw anything, but it still has logical importance for the editing\n    // environment...it can respond to changes which will then change the swash glyph of the first.\n    end.setGlyph(this.ctxt, GlyphCode.None);\n\n    this.x = start.bounds.right();\n    end.bounds.x = this.x - end.bounds.width;\n\n    this.neume.addVisualizer(start);\n    this.neume.addVisualizer(end);\n\n    this.lastNote = end;\n    this.lineIsHanging = false;\n\n    return this;\n  }\n}\n\n/*\n * Neumes base class\n */\nexport class Neume extends ChantNotationElement {\n  constructor(notes = []) {\n    super();\n\n    this.isNeume = true; // poor man's reflection\n    this.notes = notes;\n\n    for (var i = 0; i < notes.length; i++) notes[i].neume = this;\n  }\n\n  addNote(note) {\n    note.neume = this;\n    this.notes.push(note);\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n  }\n\n  finishLayout(ctxt) {\n    this.ledgerLines = this.requiresLedgerLine(ctxt);\n\n    // allow subclasses an opportunity to position their own markings...\n    this.positionMarkings();\n\n    // layout the markings of the notes\n    for (var i = 0; i < this.notes.length; i++) {\n      var note = this.notes[i];\n      var j;\n\n      for (j = 0; j < note.episemata.length; j++) {\n        note.episemata[j].performLayout(ctxt);\n        this.addVisualizer(note.episemata[j]);\n      }\n\n      for (j = 0; j < note.morae.length; j++) {\n        note.morae[j].performLayout(ctxt);\n        this.addVisualizer(note.morae[j]);\n      }\n\n      // if the note has an ictus, then add it here\n      if (note.ictus) {\n        note.ictus.performLayout(ctxt);\n        this.addVisualizer(note.ictus);\n      }\n\n      if (note.accent) {\n        note.accent.performLayout(ctxt);\n        this.addVisualizer(note.accent);\n      }\n\n      if (note.choralSign) {\n        note.choralSign.performLayout(ctxt);\n        this.addVisualizer(note.choralSign);\n      }\n\n      // braces are handled by the chant line, so we don't mess with them here\n      // this is because brace size depends on chant line logic (neume spacing,\n      // justification, etc.) so they are considered chant line level\n      // markings rather than note level markings\n    }\n\n    this.origin.x = this.notes[0].origin.x;\n    this.origin.y = this.notes[0].origin.y;\n\n    super.finishLayout(ctxt);\n  }\n\n  requiresLedgerLine(ctxt) {\n    var firstAbove = false,\n      needsAbove = false,\n      firstBelow = false,\n      needsBelow = false,\n      // isPorrectus = false,\n      result = [],\n      ledgerLinePositionAbove = ctxt.staffLineCount * 2 + 1;\n\n    if (!this.notes) return result;\n\n    for (var i = 0; i < this.notes.length; ++i) {\n      var note = this.notes[i];\n      var staffPosition = note.staffPosition;\n      if (staffPosition >= ledgerLinePositionAbove - 1) {\n        needsAbove = needsAbove || staffPosition >= ledgerLinePositionAbove;\n        if (firstAbove === false) firstAbove = Math.max(0, i - 1);\n        if (staffPosition >= ledgerLinePositionAbove) continue;\n      } else if (staffPosition <= 0) {\n        needsBelow = needsBelow || staffPosition <= -1;\n        if (firstBelow === false) firstBelow = Math.max(0, i - 1);\n        if (staffPosition <= -1) continue;\n      }\n      if (needsAbove || needsBelow) {\n        var endI = i; // Math.abs(staffPosition) >= 4? i : i - 1;\n        result.push({\n          element: this.notes[firstAbove || firstBelow || 0],\n          endElem: this.notes[endI],\n          staffPosition: needsAbove ? ledgerLinePositionAbove : -1\n        });\n        firstAbove = firstBelow = needsAbove = needsBelow = false;\n      }\n      // isPorrectus = /^Porrectus\\d$/.test(note.glyphVisualizer.glyphCode);\n    }\n    if (needsAbove || needsBelow) {\n      result.push({\n        element: this.notes[firstAbove || firstBelow || 0],\n        endElem: this.notes[this.notes.length - 1],\n        staffPosition: needsAbove ? ledgerLinePositionAbove : -1\n      });\n    }\n    return result;\n  }\n\n  resetDependencies() {}\n\n  build(ctxt) {\n    return new NeumeBuilder(ctxt, this);\n  }\n  positionEpisemata(note, position) {\n    var i;\n    for (i = 0; i < note.episemata.length; i++)\n      if (note.episemata[i].positionHint === MarkingPositionHint.Default)\n        note.episemata[i].positionHint = position;\n    if (note.choralSign) note.choralSign.positionHint = position;\n    return note.episemata.length;\n  }\n  positionEpisemataAbove(note) {\n    return this.positionEpisemata(note, MarkingPositionHint.Above);\n  }\n  positionEpisemataBelow(note) {\n    return this.positionEpisemata(note, MarkingPositionHint.Below);\n  }\n\n  positionPodatusEpisemata(bottomNote, topNote) {\n    // 1. episema on lower note by default be below, upper note above\n    this.positionEpisemataBelow(bottomNote);\n    this.positionEpisemataAbove(topNote);\n    if (topNote.ictus) {\n      topNote.ictus.positionHint = MarkingPositionHint.Above;\n    }\n  }\n  positionInclinataMorae(notes) {\n    notes = notes.slice(-2);\n    if (notes.length < 2 || notes[1].staffPosition > notes[0].staffPosition)\n      return;\n    var bottomNote = notes[1],\n      topNote = notes[0],\n      mark;\n\n    // The mora on the second (lower) note should be below the punctum,\n    // if the punctum is on a line and the previous punctum is in the space above.\n    if (\n      Math.abs(bottomNote.staffPosition % 2) === 1 &&\n      topNote.staffPosition - bottomNote.staffPosition === 1 &&\n      bottomNote.morae.length > 0\n    ) {\n      mark = bottomNote.morae.slice(-1)[0];\n      if (mark.positionHint === MarkingPositionHint.Default)\n        mark.positionHint = MarkingPositionHint.Below;\n    }\n  }\n  positionPodatusMorae(bottomNote, topNote) {\n    var mark;\n\n    // The mora on the first (lower) note should be below it,\n    // if it is on a line.\n    if (Math.abs(bottomNote.staffPosition % 2) === 1) {\n      if (bottomNote.morae.length === 1) {\n        mark = bottomNote.morae[0];\n      } else if (topNote.morae.length > 1) {\n        mark = topNote.morae[0];\n      }\n      if (mark && mark.positionHint === MarkingPositionHint.Default)\n        mark.positionHint = MarkingPositionHint.Below;\n    }\n\n    // if there is a mora on the first note but not on the second, and the neume\n    // continues with a punctum higher than the second note, we need to adjust\n    // the space after the neume so that it follows immediately with no gap\n    if (bottomNote.morae.length > 0 && topNote.morae.length === 0) {\n      bottomNote.morae[0].ignoreBounds = true;\n    }\n  }\n  // for any subclasses that begin with a podatus, they can call this from their own positionMarkings()\n  positionPodatusMarkings(bottomNote, topNote) {\n    this.positionPodatusEpisemata(bottomNote, topNote);\n    this.positionPodatusMorae(bottomNote, topNote);\n  }\n\n  // just like a clivis, but the first note of the three also works like the second note of the clivis:\n  // episema below, unless the middle note also has an episema\n  positionTorculusMarkings(firstNote, secondNote, thirdNote) {\n    var hasTopEpisema = this.positionClivisMarkings(secondNote, thirdNote);\n    hasTopEpisema =\n      this.positionEpisemata(\n        firstNote,\n        hasTopEpisema ? MarkingPositionHint.Above : MarkingPositionHint.Below\n      ) && hasTopEpisema;\n    return hasTopEpisema;\n  }\n  positionClivisMorae(firstNote, secondNote) {\n    // 1. second note of a clivis that ends on a line and goes down one step has its mora below:\n    var morae = firstNote.morae.concat(secondNote.morae);\n    if (\n      secondNote.morae.length &&\n      firstNote.staffPosition - secondNote.staffPosition === 1 &&\n      Math.abs(secondNote.staffPosition % 2) === 1\n    ) {\n      morae.slice(-1)[0].positionHint = MarkingPositionHint.Below;\n    }\n  }\n  positionClivisEpisemata(firstNote, secondNote) {\n    var hasTopEpisema = this.positionEpisemataAbove(firstNote);\n    this.positionEpisemata(\n      secondNote,\n      hasTopEpisema ? MarkingPositionHint.Above : MarkingPositionHint.Below\n    );\n    return hasTopEpisema;\n  }\n  positionClivisMarkings(firstNote, secondNote) {\n    this.positionClivisMorae(firstNote, secondNote);\n    return this.positionClivisEpisemata(firstNote, secondNote);\n  }\n\n  positionPorrectusMarkings(firstNote, secondNote, thirdNote) {\n    // episemata on first and second note work like a clivis,\n    // the second note should have its episema below, unless the first note also has an episema.\n    this.positionClivisEpisemata(firstNote, secondNote);\n    this.positionPodatusMarkings(secondNote, thirdNote);\n  }\n\n  positionPorrectusFlexusMarkings(first, second, third, fourth) {\n    var hasTopEpisema = this.positionEpisemataAbove(first);\n    hasTopEpisema = this.positionClivisMarkings(third, fourth) || hasTopEpisema;\n    this.positionEpisemata(\n      second,\n      hasTopEpisema ? MarkingPositionHint.Above : MarkingPositionHint.Below\n    );\n  }\n\n  // subclasses can override this in order to correctly place markings in a neume specific way\n  positionMarkings() {}\n}\n\n/*\n * Apostropha\n */\nexport class Apostropha extends Neume {\n  positionMarkings() {\n    var positionHint = MarkingPositionHint.Above;\n\n    // logic here is this: if first episema is default position, place it above.\n    // then place the second one (if there is one) opposite of the first.\n    for (var i = 0; i < this.notes[0].episemata.length; i++) {\n      if (\n        this.notes[0].episemata[i].positionHint === MarkingPositionHint.Default\n      )\n        this.notes[0].episemata[i].positionHint = positionHint;\n      else positionHint = this.notes[0].episemata[i].positionHint;\n\n      // now place the next one in the opposite position\n      positionHint =\n        positionHint === MarkingPositionHint.Above\n          ? MarkingPositionHint.Below\n          : MarkingPositionHint.Above;\n    }\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    this.build(ctxt).noteAt(\n      this.notes[0],\n      Apostropha.getNoteGlyphCode(this.notes[0])\n    );\n\n    this.finishLayout(ctxt);\n  }\n\n  static getNoteGlyphCode(note) {\n    if (note.shape === NoteShape.Stropha) return GlyphCode.Stropha;\n\n    if (note.liquescent & LiquescentType.Ascending)\n      return GlyphCode.PunctumQuadratumAscLiquescent;\n    else if (note.liquescent & LiquescentType.Descending)\n      return GlyphCode.PunctumQuadratumDesLiquescent;\n\n    if (note.shapeModifiers & NoteShapeModifiers.Cavum)\n      return GlyphCode.PunctumCavum;\n\n    return GlyphCode.PunctumQuadratum;\n  }\n}\n\n/*\n * Bivirga\n *\n * For simplicity in implementation, Bivirga's have two notes in the object\n * structure. These technically must be the same pitch though.\n */\nexport class Bivirga extends Neume {\n  positionMarkings() {\n    this.positionEpisemataAbove(this.notes[0]);\n    this.positionEpisemataAbove(this.notes[1]);\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    this.build(ctxt)\n      .virgaAt(this.notes[0])\n      .advanceBy(ctxt.intraNeumeSpacing)\n      .virgaAt(this.notes[1]);\n\n    this.finishLayout(ctxt);\n  }\n}\n\n/*\n * Trivirga\n *\n * For simplicity in implementation, Trivirga's have three notes in the object\n * structure. These technically must be the same pitch though.\n */\nexport class Trivirga extends Neume {\n  positionMarkings() {\n    this.positionEpisemataAbove(this.notes[0]);\n    this.positionEpisemataAbove(this.notes[1]);\n    this.positionEpisemataAbove(this.notes[2]);\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    this.build(ctxt)\n      .virgaAt(this.notes[0])\n      .advanceBy(ctxt.intraNeumeSpacing)\n      .virgaAt(this.notes[1])\n      .advanceBy(ctxt.intraNeumeSpacing)\n      .virgaAt(this.notes[2]);\n\n    this.finishLayout(ctxt);\n  }\n}\n\n/*\n * Climacus\n */\nexport class Climacus extends Neume {\n  positionMarkings() {\n    for (var i = 0; i < this.notes.length; i++) {\n      this.positionEpisemataAbove(this.notes[i]);\n    }\n    this.positionInclinataMorae(this.notes);\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    this.build(ctxt)\n      .virgaAt(this.notes[0])\n      .advanceBy(ctxt.intraNeumeSpacing)\n      .withInclinata(this.notes.slice(1));\n\n    this.finishLayout(ctxt);\n  }\n}\n\n/*\n * Clivis\n */\nexport class Clivis extends Neume {\n  positionMarkings() {\n    this.positionClivisMarkings(this.notes[0], this.notes[1]);\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    var upper = this.notes[0];\n    var lower = this.notes[1];\n\n    this.build(ctxt).withClivis(upper, lower);\n\n    this.finishLayout(ctxt);\n  }\n}\n\n/*\n * Ancus\n */\nexport class Ancus extends Neume {\n  positionMarkings() {\n    this.positionClivisMarkings(this.notes[0], this.notes[2]);\n    this.positionClivisMarkings(this.notes[1], this.notes[2]);\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    var upper = this.notes[0];\n    var middle = this.notes[1];\n    var lower = this.notes[2];\n\n    var builder = this.build(ctxt);\n    builder.withClivisUpper(upper, middle);\n    let middleGlyph = GlyphCode.PunctumQuadratum;\n    if (lower.liquescent & LiquescentType.Small) {\n      middleGlyph = GlyphCode.BeginningDesLiquescent;\n    }\n    if (upper.staffPosition - middle.staffPosition > 1) {\n      builder.withClivisUpper(middle, upper, middleGlyph);\n    } else {\n      builder.withClivisUpper(middle, null, middleGlyph);\n    }\n    builder.withClivisLower(lower);\n    builder.lastNote = null;\n\n    this.finishLayout(ctxt);\n  }\n}\n\n/*\n * Distropha\n *\n * For simplicity in implementation, Distropha's have two notes in the object\n * structure. These technically must be the same pitch though (like Bivirga).\n */\nexport class Distropha extends Neume {\n  positionMarkings() {\n    this.positionEpisemataAbove(this.notes[0]);\n    this.positionEpisemataAbove(this.notes[1]);\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n    let glyphCodes = this.notes.map((note) =>\n      Apostropha.getNoteGlyphCode(note)\n    );\n    let glyphAdvance = ctxt.intraNeumeSpacing;\n    glyphCodes.slice(0, 2).forEach((glyphCode) => {\n      if (glyphCode === GlyphCode.Stropha)\n        glyphAdvance -= ctxt.intraNeumeSpacing / 4;\n    });\n\n    this.build(ctxt)\n      .noteAt(this.notes[0], glyphCodes[0])\n      .advanceBy(glyphAdvance)\n      .noteAt(this.notes[1], glyphCodes[1]);\n\n    this.finishLayout(ctxt);\n  }\n}\n\n/*\n * Oriscus\n */\nexport class Oriscus extends Neume {\n  positionMarkings() {\n    this.positionEpisemataAbove(this.notes[0]);\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    // determine the glyph to use\n    var note = this.notes[0];\n    var glyph;\n\n    if (note.liquescent !== LiquescentType.None) {\n      glyph = GlyphCode.OriscusLiquescent;\n    } else {\n      if (note.shapeModifiers & NoteShapeModifiers.Ascending)\n        glyph = GlyphCode.OriscusAsc;\n      else if (note.shapeModifiers & NoteShapeModifiers.Descending)\n        glyph = GlyphCode.OriscusDes;\n      else {\n        // by default we take the descending form, unless we can figure out by a lookahead here\n        glyph = GlyphCode.OriscusDes;\n\n        // try to find a neume following this one\n        var neume = ctxt.findNextNeume();\n\n        if (neume) {\n          var nextNoteStaffPosition = ctxt.activeClef.pitchToStaffPosition(\n            neume.notes[0].pitch\n          );\n\n          if (nextNoteStaffPosition > note.staffPosition)\n            glyph = GlyphCode.OriscusAsc;\n        }\n      }\n    }\n\n    this.build(ctxt).noteAt(note, glyph);\n\n    this.finishLayout(ctxt);\n  }\n\n  resetDependencies() {\n    // a single oriscus tries to automatically use the right direction\n    // based on the following neumes. if we don't have a manually designated\n    // direction, then we reset our layout so that we can try to guess it\n    // at next layout phase.\n    if (\n      this.notes[0].shapeModifiers & NoteShapeModifiers.Ascending ||\n      this.notes[0].shapeModifiers & NoteShapeModifiers.Descending\n    )\n      return;\n\n    this.needsLayout = true;\n  }\n}\n\n/*\n * PesQuassus\n */\nexport class PesQuassus extends Neume {\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    var lower = this.notes[0];\n    var upper = this.notes[1];\n\n    var lowerGlyph;\n\n    var lowerStaffPos = lower.staffPosition;\n    var upperStaffPos = upper.staffPosition;\n\n    if (lower.shape === NoteShape.Oriscus) lowerGlyph = GlyphCode.OriscusAsc;\n    else lowerGlyph = GlyphCode.PunctumQuadratum;\n\n    var builder = this.build(ctxt).noteAt(lower, lowerGlyph);\n\n    if (upperStaffPos - lowerStaffPos === 1)\n      // use a virga glyph in this case\n      builder.virgaAt(upper);\n    else if (upper.liquescent === LiquescentType.LargeDescending)\n      builder\n        .noteAt(upper, GlyphCode.PunctumQuadratumDesLiquescent)\n        .withLineEndingAt(lower);\n    else\n      builder.noteAt(upper, GlyphCode.PunctumQuadratum).withLineEndingAt(lower);\n\n    this.finishLayout(ctxt);\n  }\n}\n\n/*\n * PesSubpunctis\n */\nexport class PesSubpunctis extends Neume {\n  positionMarkings() {\n    this.positionPodatusEpisemata(this.notes[0], this.notes[1]);\n    for (var i = 2; i < this.notes.length; ++i) {\n      this.positionEpisemataAbove(this.notes[i]);\n    }\n    this.positionInclinataMorae(this.notes.slice(1));\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    // podatus followed by inclinata\n    this.build(ctxt)\n      .withPodatus(this.notes[0], this.notes[1])\n      .advanceBy(ctxt.intraNeumeSpacing * 0.68)\n      .withInclinata(this.notes.slice(2));\n\n    this.finishLayout(ctxt);\n  }\n}\n\n/*\n * Podatus\n *\n * This podatus class handles a few neume types actually, depending on the note\n * data: Podatus (including various liquescent types on the upper note),\n * Podatus initio debilis, and Quilisma-Pes\n */\nexport class Podatus extends Neume {\n  positionMarkings() {\n    this.positionPodatusMarkings(this.notes[0], this.notes[1]);\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    this.build(ctxt).withPodatus(this.notes[0], this.notes[1]);\n\n    this.finishLayout(ctxt);\n  }\n}\n\n/*\n * Porrectus\n */\nexport class Porrectus extends Neume {\n  positionMarkings() {\n    this.positionPorrectusMarkings(this.notes[0], this.notes[1], this.notes[2]);\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    var first = this.notes[0];\n    var second = this.notes[1];\n    var third = this.notes[2];\n\n    var thirdGlyph;\n\n    if (third.liquescent & LiquescentType.Small)\n      thirdGlyph = GlyphCode.TerminatingAscLiquescent;\n    else if (third.liquescent & LiquescentType.Descending)\n      thirdGlyph = GlyphCode.PunctumQuadratumDesLiquescent;\n    else thirdGlyph = GlyphCode.PodatusUpper;\n\n    this.build(ctxt)\n      .lineFrom(second)\n      .withPorrectusSwash(first, second)\n      .noteAt(third, thirdGlyph);\n\n    this.finishLayout(ctxt);\n  }\n}\n\n/*\n * PorrectusFlexus\n */\nexport class PorrectusFlexus extends Neume {\n  positionMarkings() {\n    this.positionPorrectusFlexusMarkings(\n      this.notes[0],\n      this.notes[1],\n      this.notes[2],\n      this.notes[3]\n    );\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    var first = this.notes[0];\n    var second = this.notes[1];\n    var third = this.notes[2];\n    var fourth = this.notes[3];\n\n    var thirdGlyph = GlyphCode.PunctumQuadratum,\n      fourthGlyph;\n\n    if (fourth.liquescent & LiquescentType.Small) {\n      thirdGlyph = GlyphCode.PunctumQuadratumDesLiquescent;\n      fourthGlyph = GlyphCode.TerminatingDesLiquescent;\n    } else if (fourth.liquescent & LiquescentType.Ascending)\n      fourthGlyph = GlyphCode.PunctumQuadratumAscLiquescent;\n    else if (fourth.liquescent & LiquescentType.Descending)\n      fourthGlyph = GlyphCode.PunctumQuadratumDesLiquescent;\n    else fourthGlyph = GlyphCode.PunctumQuadratum;\n\n    this.build(ctxt)\n      .lineFrom(second)\n      .withPorrectusSwash(first, second)\n      .noteAt(third, thirdGlyph)\n      .noteAt(fourth, fourthGlyph);\n\n    this.finishLayout(ctxt);\n  }\n}\n\n// this is some type of pseudo nume right? there is no such thing as a neume\n// of puncta inclinata, but this will be part of other composite neumes.\nexport class PunctaInclinata extends Neume {\n  positionMarkings() {\n    this.positionInclinataMorae(this.notes);\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    this.build(ctxt).withInclinata(this.notes);\n\n    this.finishLayout(ctxt);\n  }\n}\n\n/*\n * Punctum\n */\nexport class Punctum extends Neume {\n  positionMarkings() {\n    this.positionEpisemataAbove(this.notes[0]);\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    var note = this.notes[0];\n    var glyph = GlyphCode.PunctumQuadratum;\n\n    // determine the glyph to use\n    if (note.liquescent !== LiquescentType.None) {\n      if (note.shape === NoteShape.Inclinatum)\n        glyph = GlyphCode.PunctumInclinatumLiquescent;\n      else if (note.shape === NoteShape.Oriscus)\n        glyph = GlyphCode.OriscusLiquescent;\n      else if (note.liquescent & LiquescentType.Ascending)\n        glyph = GlyphCode.PunctumQuadratumAscLiquescent;\n      else if (note.liquescent & LiquescentType.Descending)\n        glyph = GlyphCode.PunctumQuadratumDesLiquescent;\n      else glyph = GlyphCode.PunctumQuadratumLiquescent;\n    } else {\n      if (note.shapeModifiers & NoteShapeModifiers.Cavum)\n        glyph = GlyphCode.PunctumCavum;\n      else if (note.shape === NoteShape.Inclinatum)\n        glyph = GlyphCode.PunctumInclinatum;\n      else if (note.shape === NoteShape.Quilisma) glyph = GlyphCode.Quilisma;\n      else glyph = GlyphCode.PunctumQuadratum;\n    }\n\n    this.build(ctxt).noteAt(note, glyph);\n\n    this.finishLayout(ctxt);\n  }\n}\n\n/*\n * Salicus\n */\nexport class Salicus extends Neume {\n  positionMarkings() {\n    // by default place episema below\n    // fixme: is this correct?\n    for (var i = 0; i < this.notes.length; i++)\n      this.positionEpisemataBelow(this.notes[i]);\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    var first = this.notes[0];\n    var second = this.notes[1];\n    var third = this.notes[2];\n\n    var builder = this.build(ctxt).noteAt(first, GlyphCode.PunctumQuadratum);\n\n    // if the next note doesn't require a stem connector, then add a tad bit\n    // of spacing here\n    if (!(second.shapeModifiers & NoteShapeModifiers.Stemmed))\n      builder.advanceBy(ctxt.intraNeumeSpacing);\n\n    // second note is always an oriscus, which may or may not be stemmed\n    // to the first\n    builder.noteAt(second, GlyphCode.OriscusAsc);\n\n    // third note can be a punctum quadratum or various liquescent forms\n    if (third.liquescent & LiquescentType.Small)\n      builder.noteAt(third, GlyphCode.TerminatingAscLiquescent);\n    else if (third.liquescent === LiquescentType.Ascending)\n      builder.noteAt(third, GlyphCode.PunctumQuadratumAscLiquescent);\n    else if (third.liquescent === LiquescentType.Descending)\n      builder.noteAt(third, GlyphCode.PunctumQuadratumDesLiquescent);\n    else builder.virgaAt(third);\n\n    this.finishLayout(ctxt);\n  }\n}\n\n/*\n * Salicus Flexus\n */\nexport class SalicusFlexus extends Neume {\n  positionMarkings() {\n    var hasTopEpisema = this.positionTorculusMarkings(\n      this.notes[1],\n      this.notes[2],\n      this.notes[3]\n    );\n    this.positionEpisemata(\n      this.notes[0],\n      hasTopEpisema ? MarkingPositionHint.Above : MarkingPositionHint.Below\n    );\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    var first = this.notes[0];\n    var second = this.notes[1];\n    var third = this.notes[2];\n    var fourth = this.notes[3];\n\n    var builder = this.build(ctxt).noteAt(first, GlyphCode.PunctumQuadratum);\n\n    // if the next note doesn't require a stem connector, then add a tad bit\n    // of spacing here\n    if (!(second.shapeModifiers & NoteShapeModifiers.Stemmed))\n      builder.advanceBy(ctxt.intraNeumeSpacing);\n\n    // second note is always an oriscus, which may or may not be stemmed\n    // to the first\n    builder.noteAt(second, GlyphCode.OriscusAsc);\n\n    // third note can be a punctum quadratum or various liquescent forms,\n    // ...based on note four though!\n    if (fourth.liquescent & LiquescentType.Small)\n      builder.noteAt(third, GlyphCode.PunctumQuadratumDesLiquescent);\n    else builder.noteAt(third, GlyphCode.PunctumQuadratum);\n\n    // finally, do the fourth note\n    if (fourth.liquescent & LiquescentType.Small)\n      builder.noteAt(fourth, GlyphCode.TerminatingDesLiquescent);\n    else if (fourth.liquescent & LiquescentType.Ascending)\n      builder.noteAt(fourth, GlyphCode.PunctumQuadratumAscLiquescent);\n    else if (fourth.liquescent & LiquescentType.Descending)\n      builder.noteAt(fourth, GlyphCode.PunctumQuadratumDesLiquescent);\n    else builder.noteAt(fourth, GlyphCode.PunctumQuadratum);\n\n    this.finishLayout(ctxt);\n  }\n}\n\n/*\n * Scandicus\n */\nexport class Scandicus extends Neume {\n  positionMarkings() {\n    if (this.notes[2].shape === NoteShape.Virga) {\n      this.positionPodatusMarkings(this.notes[0], this.notes[1]);\n      this.positionEpisemataAbove(this.notes[2]);\n    } else {\n      this.positionEpisemataBelow(this.notes[0]);\n      this.positionPodatusMarkings(this.notes[1], this.notes[2]);\n    }\n  }\n\n  // if the third note shape is a virga, then the scadicus is rendered\n  // as a podatus followed by a virga. Otherwise, it's rendered as a\n  // punctum followed by a podatus...\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    var first = this.notes[0];\n    var second = this.notes[1];\n    var third = this.notes[2];\n\n    if (third.shape === NoteShape.Virga) {\n      this.build(ctxt).withPodatus(first, second).virgaAt(third);\n    } else {\n      this.build(ctxt)\n        .noteAt(\n          first,\n          first.shape === NoteShape.Quilisma\n            ? GlyphCode.Quilisma\n            : GlyphCode.PunctumQuadratum\n        )\n        .withPodatus(second, third);\n    }\n\n    this.finishLayout(ctxt);\n  }\n}\n\n/*\n * Scandicus Flexus\n */\nexport class ScandicusFlexus extends Neume {\n  positionMarkings() {\n    if (this.notes[2].shape === NoteShape.Virga) {\n      this.positionPodatusMarkings(this.notes[0], this.notes[1]);\n      this.positionClivisMarkings(this.notes[2], this.notes[3]);\n    } else {\n      this.positionEpisemataBelow(this.notes[0]);\n      this.positionPodatusMarkings(this.notes[1], this.notes[2]);\n      this.positionEpisemataAbove(this.notes[3]);\n    }\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    var first = this.notes[0];\n    var second = this.notes[1];\n    var third = this.notes[2];\n    var fourth = this.notes[3];\n\n    if (third.shape === NoteShape.Virga) {\n      this.build(ctxt)\n        .withPodatus(first, second)\n        .advanceBy(ctxt.intraNeumeSpacing)\n        .withClivis(third, fourth);\n    } else {\n      var fourthGlyph = GlyphCode.PunctumQuadratum;\n\n      if (fourth.liquescent & LiquescentType.Ascending)\n        fourthGlyph = GlyphCode.PunctumQuadratumAscLiquescent;\n      else if (fourth.liquescent & LiquescentType.Descending)\n        fourthGlyph = GlyphCode.PunctumQuadratumDesLiquescent;\n\n      this.build(ctxt)\n        .noteAt(first, GlyphCode.PunctumQuadratum)\n        .withPodatus(second, third)\n        .advanceBy(ctxt.intraNeumeSpacing)\n        .noteAt(fourth, fourthGlyph);\n    }\n\n    this.finishLayout(ctxt);\n  }\n}\n\n/*\n * Torculus\n */\nexport class Torculus extends Neume {\n  positionMarkings() {\n    this.positionTorculusMarkings(this.notes[0], this.notes[1], this.notes[2]);\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    var note1 = this.notes[0];\n    var note2 = this.notes[1];\n    var note3 = this.notes[2];\n\n    var glyph1, glyph3;\n\n    if (note1.liquescent === LiquescentType.InitioDebilis)\n      glyph1 = GlyphCode.TerminatingDesLiquescent;\n    else if (note1.shape === NoteShape.Quilisma) glyph1 = GlyphCode.Quilisma;\n    else glyph1 = GlyphCode.PunctumQuadratum;\n\n    if (note3.liquescent & LiquescentType.Small)\n      glyph3 = GlyphCode.TerminatingDesLiquescent;\n    else if (note3.liquescent & LiquescentType.Ascending)\n      glyph3 = GlyphCode.PunctumQuadratumAscLiquescent;\n    else if (note3.liquescent & LiquescentType.Descending)\n      glyph3 = GlyphCode.PunctumQuadratumDesLiquescent;\n    else glyph3 = GlyphCode.PunctumQuadratum;\n\n    this.build(ctxt)\n      .noteAt(note1, glyph1)\n      .noteAt(note2, GlyphCode.PunctumQuadratum)\n      .noteAt(note3, glyph3);\n\n    this.finishLayout(ctxt);\n  }\n}\n\n/*\n * TorculusResupinus\n */\nexport class TorculusResupinus extends Neume {\n  positionMarkings() {\n    this.positionPorrectusMarkings(this.notes[1], this.notes[2], this.notes[3]);\n    this.positionClivisEpisemata(this.notes[1], this.notes[0]);\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    var first = this.notes[0];\n    var second = this.notes[1];\n    var third = this.notes[2];\n    var fourth = this.notes[3];\n\n    var firstGlyph, fourthGlyph;\n\n    if (first.liquescent === LiquescentType.InitioDebilis) {\n      firstGlyph = GlyphCode.TerminatingDesLiquescent;\n    } else if (first.shape === NoteShape.Quilisma)\n      firstGlyph = GlyphCode.Quilisma;\n    else firstGlyph = GlyphCode.PunctumQuadratum;\n\n    if (fourth.liquescent & LiquescentType.Small)\n      fourthGlyph = GlyphCode.TerminatingAscLiquescent;\n    else if (third.liquescent & LiquescentType.Descending)\n      fourthGlyph = GlyphCode.PunctumQuadratumDesLiquescent;\n    else fourthGlyph = GlyphCode.PodatusUpper;\n\n    this.build(ctxt)\n      .noteAt(first, firstGlyph)\n      .withPorrectusSwash(second, third)\n      .noteAt(fourth, fourthGlyph);\n\n    this.finishLayout(ctxt);\n  }\n}\n\n/*\n * TorculusResupinusFlexus\n */\nexport class TorculusResupinusFlexus extends Neume {\n  positionMarkings() {\n    this.positionPorrectusFlexusMarkings(\n      this.notes[1],\n      this.notes[2],\n      this.notes[3],\n      this.notes[4]\n    );\n    this.positionClivisEpisemata(this.notes[1], this.notes[0]);\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    var first = this.notes[0];\n    var second = this.notes[1];\n    var third = this.notes[2];\n    var fourth = this.notes[3];\n    var fifth = this.notes[4];\n\n    var firstGlyph,\n      fourthGlyph = GlyphCode.PunctumQuadratum,\n      fifthGlyph;\n\n    if (first.liquescent === LiquescentType.InitioDebilis) {\n      firstGlyph = GlyphCode.TerminatingDesLiquescent;\n    } else if (first.shape === NoteShape.Quilisma)\n      firstGlyph = GlyphCode.Quilisma;\n    else firstGlyph = GlyphCode.PunctumQuadratum;\n\n    if (fifth.liquescent & LiquescentType.Small) {\n      fourthGlyph = GlyphCode.PunctumQuadratumDesLiquescent;\n      fifthGlyph = GlyphCode.TerminatingDesLiquescent;\n    } else if (fifth.liquescent & LiquescentType.Ascending)\n      fifthGlyph = GlyphCode.PunctumQuadratumAscLiquescent;\n    else if (fifth.liquescent & LiquescentType.Descending)\n      fifthGlyph = GlyphCode.PunctumQuadratumDesLiquescent;\n    else fifthGlyph = GlyphCode.PunctumQuadratum;\n\n    this.build(ctxt)\n      .noteAt(first, firstGlyph)\n      .withPorrectusSwash(second, third)\n      .noteAt(fourth, fourthGlyph)\n      .noteAt(fifth, fifthGlyph);\n\n    this.finishLayout(ctxt);\n  }\n}\n\n/*\n * Tristropha\n *\n * For simplicity in implementation, Tristropha's have three notes in the object\n * structure. These technically must be the same pitch though (like the\n * Distropha and Bivirga).\n */\nexport class Tristropha extends Neume {\n  positionMarkings() {\n    this.positionEpisemataAbove(this.notes[0]);\n    this.positionEpisemataAbove(this.notes[1]);\n    this.positionEpisemataAbove(this.notes[2]);\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n    let glyphCodes = this.notes.map((note) =>\n      Apostropha.getNoteGlyphCode(note)\n    );\n    let glyphAdvance =\n      glyphCodes[0] === GlyphCode.Stropha\n        ? ctxt.intraNeumeSpacing / 2\n        : ctxt.intraNeumeSpacing;\n\n    this.build(ctxt)\n      .noteAt(this.notes[0], glyphCodes[0])\n      .advanceBy(glyphAdvance)\n      .noteAt(this.notes[1], glyphCodes[1])\n      .advanceBy(glyphAdvance)\n      .noteAt(this.notes[2], glyphCodes[2]);\n\n    this.finishLayout(ctxt);\n  }\n}\n\n/*\n * Virga\n */\nexport class Virga extends Neume {\n  positionMarkings() {\n    this.positionEpisemataAbove(this.notes[0]);\n  }\n\n  performLayout(ctxt) {\n    super.performLayout(ctxt);\n\n    this.build(ctxt).virgaAt(this.notes[0]);\n\n    this.finishLayout(ctxt);\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Exsurge.Chant.Neumes.js","//\n// Author(s):\n// Benjamin Bloomfield <benjamin@sourceandsummit.com>\n//\n// Copyright (c) 2019\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n//\n\nimport { Rect } from \"./Exsurge.Core.js\";\nimport {\n  ChantLayoutElement, QuickSvg, Subtitle, Supertitle, TextLeftRight, Title\n} from \"./Exsurge.Drawing.js\";\n\nexport class Titles extends ChantLayoutElement {\n  constructor(\n    ctxt,\n    score,\n    { supertitle, title, subtitle, textLeft, textRight } = {}\n  ) {\n    super();\n    this.score = score;\n    this.setSupertitle(ctxt, supertitle);\n    this.setTitle(ctxt, title);\n    this.setSubtitle(ctxt, subtitle);\n    this.setTextLeft(ctxt, textLeft);\n    this.setTextRight(ctxt, textRight);\n  }\n\n  setBoundsX(ctxt, elementName, width) {\n    let element = this[elementName];\n    switch (ctxt.textStyles[elementName].alignment) {\n      case \"left\":\n        element.textAnchor = \"start\";\n        element.bounds.x = 0;\n        break;\n      case \"right\":\n        element.textAnchor = \"end\";\n        element.bounds.x = width;\n        break;\n      case \"center\":\n      default:\n        element.textAnchor = \"middle\";\n        element.bounds.x = width / 2;\n    }\n  }\n\n  /**\n   * Lays out the titles, and returns their total height\n   * @param  {ChantContext} ctxt\n   * @return {number}      the tottal height of titles laid out\n   */\n  layoutTitles(ctxt, width) {\n    this.bounds = new Rect(0, 0, 0, 0);\n    let y = 0;\n    if (this.supertitle) {\n      this.supertitle.recalculateMetrics(ctxt);\n      this.supertitle.setMaxWidth(ctxt, width);\n\n      this.setBoundsX(ctxt, \"supertitle\", width);\n      this.supertitle.bounds.y = y;\n      this.bounds.union(this.supertitle.bounds);\n      this.supertitle.bounds.y += this.supertitle.origin.y;\n      y += this.supertitle.bounds.height + this.supertitle.padding(ctxt);\n    }\n    if (this.title) {\n      if (y) y += this.title.padding(ctxt);\n      this.title.recalculateMetrics(ctxt);\n      this.title.setMaxWidth(ctxt, width);\n      this.setBoundsX(ctxt, \"title\", width);\n      this.title.bounds.y = y;\n      this.bounds.union(this.title.bounds);\n      this.title.bounds.y += this.title.origin.y;\n      y += this.title.bounds.height + this.title.padding(ctxt);\n    }\n    if (this.subtitle) {\n      if (y) y += this.subtitle.padding(ctxt);\n      this.subtitle.recalculateMetrics(ctxt);\n      this.subtitle.setMaxWidth(ctxt, width);\n      this.setBoundsX(ctxt, \"subtitle\", width);\n      this.subtitle.bounds.y = y;\n      this.bounds.union(this.subtitle.bounds);\n      this.subtitle.bounds.y += this.subtitle.origin.y;\n      y += this.subtitle.bounds.height + this.subtitle.padding(ctxt);\n    }\n    let finalY = y,\n      textLeft = this.score.overrideTextLeft || this.textLeft;\n    if (textLeft) {\n      textLeft.recalculateMetrics(ctxt);\n      textLeft.bounds.y = y;\n      this.bounds.union(textLeft.bounds);\n      textLeft.bounds.y += textLeft.origin.y;\n      finalY = y + textLeft.bounds.height + textLeft.padding(ctxt);\n    }\n    if (this.textRight) {\n      this.textRight.recalculateMetrics(ctxt);\n      this.textRight.bounds.x = width;\n      this.textRight.bounds.y = y;\n      this.bounds.union(this.textRight.bounds);\n      this.textRight.bounds.y += this.textRight.origin.y;\n      finalY = Math.max(\n        finalY,\n        y + this.textRight.bounds.height + this.textRight.padding(ctxt)\n      );\n    }\n    return finalY;\n  }\n\n  setSupertitle(ctxt, supertitle) {\n    this.supertitle = supertitle ? new Supertitle(ctxt, supertitle) : null;\n  }\n  setTitle(ctxt, title) {\n    this.title = title ? new Title(ctxt, title) : null;\n  }\n  setSubtitle(ctxt, subtitle) {\n    this.subtitle = subtitle ? new Subtitle(ctxt, subtitle) : null;\n  }\n  setTextLeft(ctxt, textLeft) {\n    this.textLeft = textLeft\n      ? new TextLeftRight(ctxt, textLeft, \"textLeft\")\n      : null;\n  }\n  setTextRight(ctxt, textRight) {\n    this.textRight = textRight\n      ? new TextLeftRight(ctxt, textRight, \"textRight\")\n      : null;\n  }\n\n  hasSupertitle(ctxt, supertitle) {\n    return !!this.supertitle;\n  }\n  hasTitle(ctxt, title) {\n    return !!this.title;\n  }\n  hasSubtitle(ctxt, subtitle) {\n    return !!this.subtitle;\n  }\n  hasTextLeft(ctxt, textLeft) {\n    return !!this.textLeft;\n  }\n  hasTextRight(ctxt, textRight) {\n    return !!this.textRight;\n  }\n\n  draw(ctxt, scale = 1) {\n    var canvasCtxt = ctxt.canvasCtxt;\n    canvasCtxt.translate(this.bounds.x, this.bounds.y);\n\n    for (let el of [\n      this.supertitle,\n      this.title,\n      this.subtitle,\n      this.score.overrideTextLeft || this.textLeft,\n      this.textRight\n    ]) {\n      if (el) el.draw(ctxt, scale);\n    }\n\n    canvasCtxt.translate(-this.bounds.x, -this.bounds.y);\n  }\n\n  getInnerNodes(ctxt, functionName = \"createSvgNode\") {\n    var nodes = [];\n\n    for (let el of [\n      this.supertitle,\n      this.title,\n      this.subtitle,\n      this.score.overrideTextLeft || this.textLeft,\n      this.textRight\n    ]) {\n      if (el) nodes.push(el[functionName](ctxt));\n    }\n    return nodes;\n  }\n\n  createSvgNode(ctxt) {\n    var nodes = this.getInnerNodes(ctxt, \"createSvgNode\");\n\n    var node = QuickSvg.createNode(\"g\", { class: \"Titles\" }, nodes);\n\n    node.source = this;\n    this.svg = node;\n\n    return node;\n  }\n\n  createSvgTree(ctxt) {\n    var nodes = this.getInnerNodes(ctxt, \"createSvgTree\");\n\n    return QuickSvg.createSvgTree(\n      \"g\",\n      { class: \"Titles\", source: this },\n      ...nodes\n    );\n  }\n\n  createSvgFragment(ctxt) {\n    var fragment = \"\";\n\n    for (let el of [\n      this.supertitle,\n      this.title,\n      this.subtitle,\n      this.score.overrideTextLeft || this.textLeft,\n      this.textRight\n    ]) {\n      if (el) fragment += el.createSvgFragment(ctxt);\n    }\n\n    fragment = QuickSvg.createFragment(\"g\", { class: \"Titles\" }, fragment);\n    return fragment;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Exsurge.Titles.js"],"sourceRoot":""}